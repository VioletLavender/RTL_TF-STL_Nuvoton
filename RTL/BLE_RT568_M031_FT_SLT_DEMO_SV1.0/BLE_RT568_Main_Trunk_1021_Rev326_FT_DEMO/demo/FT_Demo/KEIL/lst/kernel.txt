; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\kernel.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\kernel.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\..\..\..\Library\CMSIS\Include -I..\..\..\..\..\..\Library\StdDriver\inc -I..\..\..\include -I..\..\..\porting -I..\..\..\include\rf_include -I..\..\..\porting\rf_porting -I..\..\FT_Demo -I..\FT_Func -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\kernel.crf ..\..\..\source\kernel.c]
                          THUMB

                          AREA ||i.Ble_Kernel_Root||, CODE, READONLY, ALIGN=2

                  Ble_Kernel_Root PROC
;;;1021    *******************************************************************/
;;;1022   BleStackStatus Ble_Kernel_Root(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1023   {
;;;1024       BleStackStatus LLHostRun = 0;  //If no any LL/Host task is running, it is assigned 0 in Lib, means user app could do their jobs
;;;1025       Uint8 queue_id;
;;;1026       extern Uint32 seedR16;
;;;1027       extern void checkBLE_CmdTimer(void);
;;;1028       extern L2CAPBuf L2CAP_Buf;
;;;1029       extern Uint8 CheckValid_L2CAP_Buf(void);
;;;1030       extern Uint8 (* const Prcss_L2CAP_CID[])(Uint8 connID);
;;;1031       extern void Rls_L2CAP_Buf(void);
;;;1032   #ifndef _HCI_HW_
;;;1033       Uint16 L2cap_update_rsp;
;;;1034       extern void BleMHC_PostEvent(BleCmdEvent event, void *parms);
;;;1035       extern Uint8 LL_CheckConnExist(Uint8 LL_Conn_ID);
;;;1036   #endif
;;;1037       queue_id = CheckMsgQueue();
000002  f7fffffe          BL       CheckMsgQueue
000006  4604              MOV      r4,r0
;;;1038   
;;;1039       LLHostRun = BLESTACK_STATUS_ERR_BUSY;
000008  2501              MOVS     r5,#1
;;;1040       switch (queue_id)
00000a  0003              MOVS     r3,r0
00000c  f7fffffe          BL       __ARM_common_switch8
000010  0504070a          DCB      0x05,0x04,0x07,0x0a
000014  160d1500          DCB      0x16,0x0d,0x15,0x00
;;;1041       {
;;;1042       case Q_2LL:
;;;1043           LL_Root(queue_id);
000018  f7fffffe          BL       LL_Root
;;;1044           break;
00001c  e00e              B        |L1.60|
;;;1045   
;;;1046       case Q_2L2CAP:
;;;1047           L2CAP_Root(queue_id);
00001e  f7fffffe          BL       L2CAP_Root
;;;1048           break;
000022  e00b              B        |L1.60|
;;;1049   
;;;1050       case Q_2HOST:
;;;1051           Host_Root(queue_id);
000024  f7fffffe          BL       Host_Root
;;;1052           break;
000028  e008              B        |L1.60|
;;;1053   
;;;1054       case Q_2MMI:
;;;1055           //MMI_Root(queue_id);
;;;1056           break;
;;;1057   
;;;1058   #ifdef _HCI_NEW_
;;;1059       case Q_2HCI:
;;;1060           if(CheckValid_L2CAP_Buf()==NO_)
00002a  f7fffffe          BL       CheckValid_L2CAP_Buf
00002e  2800              CMP      r0,#0
000030  d104              BNE      |L1.60|
;;;1061           {
;;;1062               HCI_Root(queue_id);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HCI_Root
000038  e000              B        |L1.60|
;;;1063           }
;;;1064           break;
;;;1065   #endif
;;;1066       default:
;;;1067           LLHostRun = BLESTACK_STATUS_FREE;
00003a  2509              MOVS     r5,#9
                  |L1.60|
;;;1068   
;;;1069           /* handle error here */
;;;1070           /*
;;;1071           if(RF_PM1_chkAvlb()==SUCCESS) {
;;;1072               RF_PM1_enter();
;;;1073           }
;;;1074           */
;;;1075           break;
;;;1076       }
;;;1077       seedR16++;
00003c  4819              LDR      r0,|L1.164|
00003e  6801              LDR      r1,[r0,#0]  ; seedR16
000040  1c49              ADDS     r1,r1,#1
;;;1078   #ifndef _HCI_HW_
;;;1079       /*----- BLE Cmd Timer-------*/
;;;1080       checkBLE_CmdTimer();
000042  6001              STR      r1,[r0,#0]  ; seedR16
000044  f7fffffe          BL       checkBLE_CmdTimer
;;;1081       /*--------------------------*/
;;;1082       if(CheckValid_L2CAP_Buf()==YES_)
000048  f7fffffe          BL       CheckValid_L2CAP_Buf
00004c  2801              CMP      r0,#1
00004e  d127              BNE      |L1.160|
;;;1083       {
;;;1084           if(LL_CheckConnExist(L2CAP_Buf.connID_LL) == YES_)
000050  4c15              LDR      r4,|L1.168|
000052  7ee0              LDRB     r0,[r4,#0x1b]  ; L2CAP_Buf
000054  f7fffffe          BL       LL_CheckConnExist
000058  2801              CMP      r0,#1
00005a  d11f              BNE      |L1.156|
;;;1085           {
;;;1086               LLHostRun = BLESTACK_STATUS_ERR_BUSY;
;;;1087               Knl_MemCpy(SPIBuffer, L2CAP_Buf.DataBuf, sizeof(L2CAP_Buf.DataBuf));
00005c  4621              MOV      r1,r4
00005e  2501              MOVS     r5,#1                 ;1086
000060  22fb              MOVS     r2,#0xfb
000062  39e0              SUBS     r1,r1,#0xe0
000064  4811              LDR      r0,|L1.172|
000066  f7fffffe          BL       Knl_MemCpy
;;;1088               if((Prcss_L2CAP_CID[L2CAP_Buf.DataBuf[TAB_BASIC_L2CAP_CID_L]](L2CAP_Buf.connID_LL)) == SUCCESS_)    //channel ID
00006a  4626              MOV      r6,r4
00006c  3ee0              SUBS     r6,r6,#0xe0
00006e  78b1              LDRB     r1,[r6,#2]  ; L2CAP_Buf
000070  4a0f              LDR      r2,|L1.176|
000072  0089              LSLS     r1,r1,#2
000074  5851              LDR      r1,[r2,r1]
000076  7ee0              LDRB     r0,[r4,#0x1b]  ; L2CAP_Buf
000078  4788              BLX      r1
00007a  2800              CMP      r0,#0
00007c  d110              BNE      |L1.160|
;;;1089               {
;;;1090                   if(L2CAP_Buf.DataBuf[TAB_BASIC_L2CAP_CID_L] == L2CAP_CID_LE_L2CAP_SIGNALING_CHANNEL)
00007e  78b0              LDRB     r0,[r6,#2]  ; L2CAP_Buf
000080  2805              CMP      r0,#5
000082  d10b              BNE      |L1.156|
;;;1091                   {
;;;1092                       if(L2CAP_Buf.DataBuf[TAB_BASIC_L2CAP_OPCODE] == CODE_SIGNL_CMD_CONNECTION_PARAMETER_UPDATE_RESPONSE)
000084  7930              LDRB     r0,[r6,#4]  ; L2CAP_Buf
000086  2813              CMP      r0,#0x13
000088  d108              BNE      |L1.156|
;;;1093                       {
;;;1094                           L2cap_update_rsp = (Uint16)((L2CAP_Buf.connID_LL << 8) | L2CAP_Buf.DataBuf[TAB_BASIC_L2CAP_SIGNALING_RESULT_L]);
00008a  7ee0              LDRB     r0,[r4,#0x1b]  ; L2CAP_Buf
00008c  7a31              LDRB     r1,[r6,#8]  ; L2CAP_Buf
00008e  0200              LSLS     r0,r0,#8
000090  4308              ORRS     r0,r0,r1
000092  4669              MOV      r1,sp
000094  8008              STRH     r0,[r1,#0]
;;;1095                           BleMHC_PostEvent(BLECMD_EVENT_CONN_PARAMETER_UPDATE_RSP,(void *)&L2cap_update_rsp);
000096  2005              MOVS     r0,#5
000098  f7fffffe          BL       BleMHC_PostEvent
                  |L1.156|
;;;1096                       }
;;;1097                   }
;;;1098                   Rls_L2CAP_Buf();
;;;1099               }
;;;1100           }
;;;1101           else
;;;1102           {
;;;1103               Rls_L2CAP_Buf();
00009c  f7fffffe          BL       Rls_L2CAP_Buf
                  |L1.160|
;;;1104           }
;;;1105       }
;;;1106   #endif
;;;1107   
;;;1108       return LLHostRun;
0000a0  4628              MOV      r0,r5
;;;1109   }
0000a2  bdf8              POP      {r3-r7,pc}
;;;1110   
                          ENDP

                  |L1.164|
                          DCD      seedR16
                  |L1.168|
                          DCD      L2CAP_Buf+0xe0
                  |L1.172|
                          DCD      SPIBuffer
                  |L1.176|
                          DCD      Prcss_L2CAP_CID

                          AREA ||i.CheckMsgBlk_L1_wSizeUsed||, CODE, READONLY, ALIGN=2

                  CheckMsgBlk_L1_wSizeUsed PROC
;;;273    
;;;274    Uint8 CheckMsgBlk_L1_wSizeUsed(Uint8 len)
000000  2101              MOVS     r1,#1
;;;275    {
000002  e001              B        |L2.8|
                  |L2.4|
000004  1c49              ADDS     r1,r1,#1
;;;276        //MBLK *pmblk;
;;;277        Uint8 num_MsgBlk;
;;;278    
;;;279        num_MsgBlk = 1;
;;;280        while(len > SIZE_MBLK_ACL_DATA_UNIT)
;;;281        {
;;;282            num_MsgBlk++;
000006  b2c9              UXTB     r1,r1
                  |L2.8|
000008  2829              CMP      r0,#0x29              ;280
00000a  d8fb              BHI      |L2.4|
;;;283        }
;;;284        InterruptDisable();
00000c  b672              CPSID    i
;;;285        if(MBlk_depth_Remaining>=(num_MsgBlk+MAX_MBLK_RSV_L1))
00000e  4805              LDR      r0,|L2.36|
000010  310a              ADDS     r1,r1,#0xa
000012  7800              LDRB     r0,[r0,#0]  ; MBlk_depth_Remaining
000014  4288              CMP      r0,r1
;;;286        {
;;;287            InterruptEnable();
;;;288            return SUCCESS_;
;;;289        }
;;;290        else
;;;291        {
;;;292            InterruptEnable();
000016  b662              CPSIE    i
000018  d301              BCC      |L2.30|
00001a  2000              MOVS     r0,#0                 ;288
;;;293            return FAIL_;
;;;294        }
;;;295        //return SUCCESS or FAIL
;;;296    }
00001c  4770              BX       lr
                  |L2.30|
00001e  2001              MOVS     r0,#1                 ;293
000020  4770              BX       lr
;;;297    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      ||.data||

                          AREA ||i.CheckMsgBlk_L1_wSizeUsed_Isr||, CODE, READONLY, ALIGN=2

                  CheckMsgBlk_L1_wSizeUsed_Isr PROC
;;;562    
;;;563    Uint8 CheckMsgBlk_L1_wSizeUsed_Isr(Uint8 len)
000000  2101              MOVS     r1,#1
;;;564    {
;;;565        //MBLK *pmblk;
;;;566        Uint8 num_MsgBlk;
;;;567    
;;;568        num_MsgBlk = 1;
;;;569        while(len > SIZE_MBLK_ACL_DATA_UNIT)
000002  2829              CMP      r0,#0x29
000004  d903              BLS      |L3.14|
                  |L3.6|
000006  1c49              ADDS     r1,r1,#1              ;564
;;;570        {
;;;571            num_MsgBlk++;
000008  b2c9              UXTB     r1,r1
00000a  2829              CMP      r0,#0x29              ;569
00000c  d8fb              BHI      |L3.6|
                  |L3.14|
;;;572        }
;;;573        if(MBlk_depth_Remaining>=(num_MsgBlk+MAX_MBLK_RSV_L1))
00000e  4804              LDR      r0,|L3.32|
000010  310a              ADDS     r1,r1,#0xa
000012  7800              LDRB     r0,[r0,#0]  ; MBlk_depth_Remaining
000014  4288              CMP      r0,r1
000016  d301              BCC      |L3.28|
;;;574        {
;;;575            return SUCCESS_;
000018  2000              MOVS     r0,#0
;;;576        }
;;;577        else
;;;578        {
;;;579            return FAIL_;
;;;580        }
;;;581        //return SUCCESS or FAIL
;;;582    }
00001a  4770              BX       lr
                  |L3.28|
00001c  2001              MOVS     r0,#1                 ;579
00001e  4770              BX       lr
;;;583    
                          ENDP

                  |L3.32|
                          DCD      ||.data||

                          AREA ||i.CheckMsgBlk_L2_wSizeUsed||, CODE, READONLY, ALIGN=2

                  CheckMsgBlk_L2_wSizeUsed PROC
;;;298    
;;;299    Uint8 CheckMsgBlk_L2_wSizeUsed(Uint8 len)
000000  2101              MOVS     r1,#1
;;;300    {
000002  e003              B        |L4.12|
                  |L4.4|
000004  1c49              ADDS     r1,r1,#1
;;;301        //MBLK *pmblk;
;;;302        Uint8 num_MsgBlk;
;;;303    
;;;304        num_MsgBlk = 1;
;;;305        while(len > SIZE_MBLK_ACL_DATA_UNIT)
;;;306        {
;;;307            num_MsgBlk++;
000006  3829              SUBS     r0,r0,#0x29
000008  b2c9              UXTB     r1,r1
;;;308            len -= SIZE_MBLK_ACL_DATA_UNIT;
00000a  b2c0              UXTB     r0,r0
                  |L4.12|
00000c  2829              CMP      r0,#0x29              ;305
00000e  d8f9              BHI      |L4.4|
;;;309        }
;;;310        InterruptDisable();
000010  b672              CPSID    i
;;;311        if(MBlk_depth_Remaining>=(num_MsgBlk+MAX_MBLK_RSV_L2))
000012  4805              LDR      r0,|L4.40|
000014  311e              ADDS     r1,r1,#0x1e
000016  7800              LDRB     r0,[r0,#0]  ; MBlk_depth_Remaining
000018  4288              CMP      r0,r1
;;;312        {
;;;313            InterruptEnable();
;;;314            return SUCCESS_;
;;;315        }
;;;316        else
;;;317        {
;;;318            InterruptEnable();
00001a  b662              CPSIE    i
00001c  d301              BCC      |L4.34|
00001e  2000              MOVS     r0,#0                 ;314
;;;319            return FAIL_;
;;;320        }
;;;321        //return SUCCESS or FAIL
;;;322    }
000020  4770              BX       lr
                  |L4.34|
000022  2001              MOVS     r0,#1                 ;319
000024  4770              BX       lr
;;;323    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||.data||

                          AREA ||i.CheckMsgBlk_L2_wSizeUsed_Isr||, CODE, READONLY, ALIGN=2

                  CheckMsgBlk_L2_wSizeUsed_Isr PROC
;;;584    
;;;585    Uint8 CheckMsgBlk_L2_wSizeUsed_Isr(Uint8 len)
000000  490b              LDR      r1,|L5.48|
;;;586    {
;;;587        Uint16 num_MsgBlk;
;;;588        extern Uint8 LL_ConnID_Remaining;
;;;589    
;;;590        if(LL_ConnID_Remaining>1)
000002  780a              LDRB     r2,[r1,#0]  ; LL_ConnID_Remaining
;;;591        {
;;;592            num_MsgBlk = (LL_ConnID_Remaining-1)*MAX_MBLK_RSV_LL_ROLE;
;;;593            num_MsgBlk += MBlk_depth_Remaining;
000004  490b              LDR      r1,|L5.52|
000006  2a01              CMP      r2,#1                 ;590
000008  7809              LDRB     r1,[r1,#0]
00000a  d904              BLS      |L5.22|
00000c  1e52              SUBS     r2,r2,#1              ;586
00000e  0093              LSLS     r3,r2,#2              ;592
000010  18d2              ADDS     r2,r2,r3              ;592
000012  1851              ADDS     r1,r2,r1
000014  b289              UXTH     r1,r1
                  |L5.22|
;;;594        }
;;;595        else
;;;596        {
;;;597            num_MsgBlk = MBlk_depth_Remaining;
;;;598        }
;;;599    
;;;600    
;;;601        if(num_MsgBlk>=MAX_MBLK_RSV_L2)
000016  291e              CMP      r1,#0x1e
000018  d307              BCC      |L5.42|
;;;602        {
;;;603            num_MsgBlk = num_MsgBlk-MAX_MBLK_RSV_L2;
;;;604            num_MsgBlk = num_MsgBlk*(SIZE_MBLK_ACL_DATA_UNIT);
00001a  2229              MOVS     r2,#0x29
00001c  391e              SUBS     r1,r1,#0x1e
00001e  4351              MULS     r1,r2,r1
000020  b289              UXTH     r1,r1
;;;605            if(num_MsgBlk>=len)
000022  4281              CMP      r1,r0
000024  d301              BCC      |L5.42|
;;;606            {
;;;607                return SUCCESS_;
000026  2000              MOVS     r0,#0
;;;608            }
;;;609            else
;;;610            {
;;;611                return FAIL_;
;;;612            }
;;;613        }
;;;614        else
;;;615        {
;;;616            return FAIL_;
;;;617        }
;;;618        //return SUCCESS or FAIL
;;;619    }
000028  4770              BX       lr
                  |L5.42|
00002a  2001              MOVS     r0,#1                 ;616
00002c  4770              BX       lr
;;;620    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      LL_ConnID_Remaining
                  |L5.52|
                          DCD      ||.data||

                          AREA ||i.CheckMsgQueue||, CODE, READONLY, ALIGN=2

                  CheckMsgQueue PROC
;;;742     *******************************************************************/
;;;743    Uint8 CheckMsgQueue(void)
000000  4906              LDR      r1,|L6.28|
;;;744    {
;;;745        Uint8 queue_i;
;;;746    
;;;747        /* check message from queue #0 to the end */
;;;748        for (queue_i = 0; queue_i<MAX_QUEUE_NO; queue_i++)
000002  2000              MOVS     r0,#0
                  |L6.4|
;;;749        {
;;;750            InterruptDisable();
000004  b672              CPSID    i
;;;751            if(MsgQueue[queue_i].QOut != (MBLK *)0)
000006  00c2              LSLS     r2,r0,#3
000008  1852              ADDS     r2,r2,r1
00000a  6852              LDR      r2,[r2,#4]
00000c  2a00              CMP      r2,#0
00000e  d104              BNE      |L6.26|
;;;752            {
;;;753                break;
;;;754            }
;;;755            InterruptEnable();
000010  b662              CPSIE    i
000012  1c40              ADDS     r0,r0,#1
000014  b2c0              UXTB     r0,r0                 ;748
000016  2805              CMP      r0,#5                 ;748
000018  d3f4              BCC      |L6.4|
                  |L6.26|
;;;756        }
;;;757        return(queue_i);
;;;758    }
00001a  4770              BX       lr
;;;759    
                          ENDP

                  |L6.28|
                          DCD      ||.bss||+0xc30

                          AREA ||i.EndianSwap16||, CODE, READONLY, ALIGN=1

                  EndianSwap16 PROC
;;;1112   #pragma Otime
;;;1113   Uint16 EndianSwap16(Uint16 value)
000000  b401              PUSH     {r0}
;;;1114   {
;;;1115       Uint8 i;
;;;1116   
;;;1117       i = ((Uint8 *) &value)[0];
000002  466a              MOV      r2,sp
000004  7810              LDRB     r0,[r2,#0]
;;;1118       ((Uint8 *) &value)[0] = ((Uint8 *) &value)[1];
000006  7851              LDRB     r1,[r2,#1]
000008  7011              STRB     r1,[r2,#0]
;;;1119       ((Uint8 *) &value)[1] = i;
00000a  7050              STRB     r0,[r2,#1]
;;;1120       return (value);
00000c  8810              LDRH     r0,[r2,#0]
;;;1121   }
00000e  b001              ADD      sp,sp,#4
000010  4770              BX       lr
;;;1122   
                          ENDP


                          AREA ||i.EndianSwap16_Isr||, CODE, READONLY, ALIGN=1

                  EndianSwap16_Isr PROC
;;;977    
;;;978    Uint16 EndianSwap16_Isr(Uint16 value)
000000  b401              PUSH     {r0}
;;;979    {
;;;980        Uint8 i;
;;;981    
;;;982        i = ((Uint8 *) &value)[0];
000002  466a              MOV      r2,sp
000004  7810              LDRB     r0,[r2,#0]
;;;983        ((Uint8 *) &value)[0] = ((Uint8 *) &value)[1];
000006  7851              LDRB     r1,[r2,#1]
000008  7011              STRB     r1,[r2,#0]
;;;984        ((Uint8 *) &value)[1] = i;
00000a  7050              STRB     r0,[r2,#1]
;;;985        return (value);
00000c  8810              LDRH     r0,[r2,#0]
;;;986    }
00000e  b001              ADD      sp,sp,#4
000010  4770              BX       lr
;;;987    
                          ENDP


                          AREA ||i.EndianSwap16addr||, CODE, READONLY, ALIGN=1

                  EndianSwap16addr PROC
;;;1135   
;;;1136   void EndianSwap16addr(Uint16 *value)
000000  7801              LDRB     r1,[r0,#0]
;;;1137   {
;;;1138       Uint8 i;
;;;1139   
;;;1140       i = ((Uint8 *) value)[0];
;;;1141       ((Uint8 *) value)[0] = ((Uint8 *) value)[1];
000002  7842              LDRB     r2,[r0,#1]
000004  7002              STRB     r2,[r0,#0]
;;;1142       ((Uint8 *) value)[1] = i;
000006  7041              STRB     r1,[r0,#1]
;;;1143   }
000008  4770              BX       lr
;;;1144   
                          ENDP


                          AREA ||i.EndianSwap16addrM4||, CODE, READONLY, ALIGN=1

                  EndianSwap16addrM4 PROC
;;;1157   
;;;1158   void EndianSwap16addrM4(Uint16 *value)
000000  b081              SUB      sp,sp,#4
;;;1159   {
;;;1160       Uint16 i;
;;;1161   
;;;1162       ((Uint8 *) &i)[1] = ((Uint8 *) value)[0];
000002  7801              LDRB     r1,[r0,#0]
000004  466a              MOV      r2,sp
000006  7051              STRB     r1,[r2,#1]
;;;1163       ((Uint8 *) &i)[0] = ((Uint8 *) value)[1];
000008  7841              LDRB     r1,[r0,#1]
00000a  7011              STRB     r1,[r2,#0]
;;;1164       *value = (i<<2);
00000c  8811              LDRH     r1,[r2,#0]
00000e  0089              LSLS     r1,r1,#2
000010  8001              STRH     r1,[r0,#0]
;;;1165   }
000012  b001              ADD      sp,sp,#4
000014  4770              BX       lr
;;;1166   
                          ENDP


                          AREA ||i.EndianSwap16addrM8||, CODE, READONLY, ALIGN=1

                  EndianSwap16addrM8 PROC
;;;1167   
;;;1168   void EndianSwap16addrM8(Uint16 *value)
000000  b081              SUB      sp,sp,#4
;;;1169   {
;;;1170       Uint16 i;
;;;1171   
;;;1172       ((Uint8 *) &i)[1] = ((Uint8 *) value)[0];
000002  7801              LDRB     r1,[r0,#0]
000004  466a              MOV      r2,sp
000006  7051              STRB     r1,[r2,#1]
;;;1173       ((Uint8 *) &i)[0] = ((Uint8 *) value)[1];
000008  7841              LDRB     r1,[r0,#1]
00000a  7011              STRB     r1,[r2,#0]
;;;1174       *value = i<<3;
00000c  8811              LDRH     r1,[r2,#0]
00000e  00c9              LSLS     r1,r1,#3
000010  8001              STRH     r1,[r0,#0]
;;;1175   }
000012  b001              ADD      sp,sp,#4
000014  4770              BX       lr
;;;1176   
                          ENDP


                          AREA ||i.EndianSwap16addrM8_Isr||, CODE, READONLY, ALIGN=1

                  EndianSwap16addrM8_Isr PROC
;;;998    
;;;999    void EndianSwap16addrM8_Isr(Uint16 *value)
000000  b081              SUB      sp,sp,#4
;;;1000   {
;;;1001       Uint16 i;
;;;1002   
;;;1003       ((Uint8 *) &i)[1] = ((Uint8 *) value)[0];
000002  7801              LDRB     r1,[r0,#0]
000004  466a              MOV      r2,sp
000006  7051              STRB     r1,[r2,#1]
;;;1004       ((Uint8 *) &i)[0] = ((Uint8 *) value)[1];
000008  7841              LDRB     r1,[r0,#1]
00000a  7011              STRB     r1,[r2,#0]
;;;1005       *value = i<<3;
00000c  8811              LDRH     r1,[r2,#0]
00000e  00c9              LSLS     r1,r1,#3
000010  8001              STRH     r1,[r0,#0]
;;;1006   }
000012  b001              ADD      sp,sp,#4
000014  4770              BX       lr
;;;1007   
                          ENDP


                          AREA ||i.EndianSwap16addr_Isr||, CODE, READONLY, ALIGN=1

                  EndianSwap16addr_Isr PROC
;;;988    
;;;989    void EndianSwap16addr_Isr(Uint16 *value)
000000  7801              LDRB     r1,[r0,#0]
;;;990    {
;;;991        Uint8 i;
;;;992    
;;;993        i = ((Uint8 *) value)[0];
;;;994        ((Uint8 *) value)[0] = ((Uint8 *) value)[1];
000002  7842              LDRB     r2,[r0,#1]
000004  7002              STRB     r2,[r0,#0]
;;;995        ((Uint8 *) value)[1] = i;
000006  7041              STRB     r1,[r0,#1]
;;;996    }
000008  4770              BX       lr
;;;997    
                          ENDP


                          AREA ||i.EndianSwap32||, CODE, READONLY, ALIGN=1

                  EndianSwap32 PROC
;;;1123   
;;;1124   Uint32 EndianSwap32(Uint32 value)
000000  0a09              LSRS     r1,r1,#8
;;;1125   {
000002  0e02              LSRS     r2,r0,#24
000004  0209              LSLS     r1,r1,#8
000006  4311              ORRS     r1,r1,r2
000008  0202              LSLS     r2,r0,#8
00000a  23ff              MOVS     r3,#0xff
00000c  0e12              LSRS     r2,r2,#24
00000e  021b              LSLS     r3,r3,#8
000010  0212              LSLS     r2,r2,#8
000012  4399              BICS     r1,r1,r3
000014  401a              ANDS     r2,r2,r3
000016  4311              ORRS     r1,r1,r2
000018  0402              LSLS     r2,r0,#16
00001a  0e12              LSRS     r2,r2,#24
00001c  021b              LSLS     r3,r3,#8
00001e  0412              LSLS     r2,r2,#16
000020  4399              BICS     r1,r1,r3
000022  401a              ANDS     r2,r2,r3
000024  4311              ORRS     r1,r1,r2
000026  0209              LSLS     r1,r1,#8
000028  0a09              LSRS     r1,r1,#8
00002a  0600              LSLS     r0,r0,#24
00002c  4308              ORRS     r0,r0,r1
;;;1126       Uint32 rval;
;;;1127   
;;;1128       ((Uint8 *) &rval)[0] = ((Uint8 *) &value)[3];
;;;1129       ((Uint8 *) &rval)[1] = ((Uint8 *) &value)[2];
;;;1130       ((Uint8 *) &rval)[2] = ((Uint8 *) &value)[1];
;;;1131       ((Uint8 *) &rval)[3] = ((Uint8 *) &value)[0];
;;;1132       return (rval);
;;;1133   }
00002e  4770              BX       lr
;;;1134   
                          ENDP


                          AREA ||i.EndianSwap32addr||, CODE, READONLY, ALIGN=1

                  EndianSwap32addr PROC
;;;1145   
;;;1146   void EndianSwap32addr(Uint32 *value)
000000  6801              LDR      r1,[r0,#0]
;;;1147   {
;;;1148       Uint32 i;
;;;1149   
;;;1150       i = *value;
000002  0e0a              LSRS     r2,r1,#24
;;;1151       ((Uint8 *) value)[0] = ((Uint8 *) &i)[3];
000004  7002              STRB     r2,[r0,#0]
000006  020a              LSLS     r2,r1,#8
000008  0e12              LSRS     r2,r2,#24
;;;1152       ((Uint8 *) value)[1] = ((Uint8 *) &i)[2];
00000a  7042              STRB     r2,[r0,#1]
00000c  040a              LSLS     r2,r1,#16
00000e  0e12              LSRS     r2,r2,#24
;;;1153       ((Uint8 *) value)[2] = ((Uint8 *) &i)[1];
000010  7082              STRB     r2,[r0,#2]
;;;1154       ((Uint8 *) value)[3] = ((Uint8 *) &i)[0];
000012  70c1              STRB     r1,[r0,#3]
;;;1155   }
000014  4770              BX       lr
;;;1156   
                          ENDP


                          AREA ||i.ErrorEntry||, CODE, READONLY, ALIGN=1

                  ErrorEntry PROC
;;;1177   
;;;1178   void ErrorEntry(Uint32 errID)
000000  b672              CPSID    i
;;;1179   {
;;;1180       Uint32 i;
;;;1181       InterruptDisable();
;;;1182       i = errID;
;;;1183       if(i)
000002  2800              CMP      r0,#0
000004  d000              BEQ      |L16.8|
                  |L16.6|
;;;1184       {
;;;1185           while(1);
000006  e7fe              B        |L16.6|
                  |L16.8|
;;;1186       }
;;;1187       InterruptEnable();
000008  b662              CPSIE    i
;;;1188   }
00000a  4770              BX       lr
;;;1189   
                          ENDP


                          AREA ||i.FreeMsgBlk||, CODE, READONLY, ALIGN=2

                  FreeMsgBlk PROC
;;;355    
;;;356    void FreeMsgBlk(MBLK *pMsgBlk)
000000  b672              CPSID    i
;;;357    {
;;;358        InterruptDisable();
;;;359        if ((pMsgBlk == (MBLK *)0) || (pMsgBlk == MBlk_Free))
000002  2800              CMP      r0,#0
000004  d008              BEQ      |L17.24|
000006  4a05              LDR      r2,|L17.28|
000008  6851              LDR      r1,[r2,#4]  ; MBlk_Free
00000a  4288              CMP      r0,r1
00000c  d004              BEQ      |L17.24|
;;;360        {
;;;361            InterruptEnable();
;;;362            return;
;;;363        }
;;;364        pMsgBlk->Next = MBlk_Free;   /* return */
;;;365        MBlk_Free = pMsgBlk;
00000e  6001              STR      r1,[r0,#0]
;;;366        MBlk_depth_Remaining++;
000010  6050              STR      r0,[r2,#4]  ; MBlk_Free
000012  7810              LDRB     r0,[r2,#0]  ; MBlk_depth_Remaining
000014  1c40              ADDS     r0,r0,#1
000016  7010              STRB     r0,[r2,#0]
                  |L17.24|
000018  b662              CPSIE    i                     ;361
;;;367        InterruptEnable();
;;;368    }
00001a  4770              BX       lr
;;;369    
                          ENDP

                  |L17.28|
                          DCD      ||.data||

                          AREA ||i.FreeMsgBlk_Isr||, CODE, READONLY, ALIGN=2

                  FreeMsgBlk_Isr PROC
;;;638    
;;;639    void FreeMsgBlk_Isr(MBLK *pMsgBlk) /* the pointer of mblk that we'll free */
000000  2800              CMP      r0,#0
;;;640    {
000002  d008              BEQ      |L18.22|
;;;641        if ((pMsgBlk == (MBLK *)0) || (pMsgBlk == MBlk_Free))
000004  4a04              LDR      r2,|L18.24|
000006  6851              LDR      r1,[r2,#4]  ; MBlk_Free
000008  4288              CMP      r0,r1
00000a  d004              BEQ      |L18.22|
;;;642        {
;;;643            return;
;;;644        }
;;;645        pMsgBlk->Next = MBlk_Free;
;;;646        MBlk_Free = pMsgBlk;
00000c  6001              STR      r1,[r0,#0]
;;;647        MBlk_depth_Remaining++;
00000e  6050              STR      r0,[r2,#4]  ; MBlk_Free
000010  7810              LDRB     r0,[r2,#0]  ; MBlk_depth_Remaining
000012  1c40              ADDS     r0,r0,#1
000014  7010              STRB     r0,[r2,#0]
                  |L18.22|
;;;648    }
000016  4770              BX       lr
;;;649    
                          ENDP

                  |L18.24|
                          DCD      ||.data||

                          AREA ||i.FreeMsgBlks||, CODE, READONLY, ALIGN=2

                  FreeMsgBlks PROC
;;;393    
;;;394    void FreeMsgBlks(MBLK *pMsgBlk)
000000  b510              PUSH     {r4,lr}
;;;395    {
;;;396        MBLK *pmblk;
;;;397        Uint8 i;
;;;398    
;;;399        pmblk = pMsgBlk;
000002  4601              MOV      r1,r0
;;;400        i = 0;
000004  2200              MOVS     r2,#0
                  |L19.6|
;;;401        while(1)
;;;402        {
;;;403            if(pmblk!=(MBLK *)0)
000006  2900              CMP      r1,#0
000008  d00f              BEQ      |L19.42|
00000a  1c52              ADDS     r2,r2,#1
;;;404            {
;;;405                i++;
;;;406                if(pmblk->Next!=(MBLK *)0)
00000c  680b              LDR      r3,[r1,#0]
00000e  b2d2              UXTB     r2,r2                 ;405
000010  2b00              CMP      r3,#0
000012  d001              BEQ      |L19.24|
000014  4619              MOV      r1,r3
;;;407                    pmblk = pmblk->Next;
000016  e7f6              B        |L19.6|
                  |L19.24|
;;;408                else
;;;409                    break;
;;;410            }
;;;411            else
;;;412                break;
;;;413        }
;;;414        if(pmblk!=(MBLK *)0)
;;;415        {
;;;416            InterruptDisable();
000018  b672              CPSID    i
;;;417            pmblk->Next = MBlk_Free;
00001a  4b04              LDR      r3,|L19.44|
00001c  685c              LDR      r4,[r3,#4]  ; MBlk_Free
;;;418            MBlk_Free = pMsgBlk;
00001e  600c              STR      r4,[r1,#0]
;;;419            MBlk_depth_Remaining += i;
000020  6058              STR      r0,[r3,#4]  ; MBlk_Free
000022  7818              LDRB     r0,[r3,#0]  ; MBlk_depth_Remaining
000024  1880              ADDS     r0,r0,r2
000026  7018              STRB     r0,[r3,#0]
;;;420            InterruptEnable();
000028  b662              CPSIE    i
                  |L19.42|
;;;421        }
;;;422    }
00002a  bd10              POP      {r4,pc}
;;;423    
                          ENDP

                  |L19.44|
                          DCD      ||.data||

                          AREA ||i.FreeMsgBlks_Isr||, CODE, READONLY, ALIGN=2

                  FreeMsgBlks_Isr PROC
;;;671    
;;;672    void FreeMsgBlks_Isr(MBLK *pMsgBlk)
000000  4b07              LDR      r3,|L20.32|
;;;673    {
;;;674        MBLK *pmblk;
;;;675    
;;;676        pmblk = pMsgBlk;
000002  4601              MOV      r1,r0
                  |L20.4|
;;;677        while(1)
;;;678        {
;;;679            if(pmblk!=(MBLK *)0)
000004  2900              CMP      r1,#0
000006  d00a              BEQ      |L20.30|
;;;680            {
;;;681                MBlk_depth_Remaining++;
000008  781a              LDRB     r2,[r3,#0]  ; MBlk_depth_Remaining
00000a  1c52              ADDS     r2,r2,#1
00000c  701a              STRB     r2,[r3,#0]
;;;682                if(pmblk->Next!=(MBLK *)0)
00000e  680a              LDR      r2,[r1,#0]
000010  2a00              CMP      r2,#0
000012  d001              BEQ      |L20.24|
000014  4611              MOV      r1,r2
;;;683                    pmblk = pmblk->Next;
000016  e7f5              B        |L20.4|
                  |L20.24|
;;;684                else
;;;685                    break;
;;;686            }
;;;687            else
;;;688                break;
;;;689        }
;;;690        if(pmblk!=(MBLK *)0)
;;;691        {
;;;692            pmblk->Next = MBlk_Free;
000018  685a              LDR      r2,[r3,#4]  ; MBlk_Free
;;;693            MBlk_Free = pMsgBlk;
00001a  600a              STR      r2,[r1,#0]
00001c  6058              STR      r0,[r3,#4]  ; MBlk_Free
                  |L20.30|
;;;694        }
;;;695    }
00001e  4770              BX       lr
;;;696    
                          ENDP

                  |L20.32|
                          DCD      ||.data||

                          AREA ||i.GetMsgBlk||, CODE, READONLY, ALIGN=2

                  GetMsgBlk PROC
;;;116     *******************************************************************/
;;;117    MBLK *GetMsgBlk(void)
000000  b672              CPSID    i
;;;118    {
;;;119        MBLK *pmblk;
;;;120    
;;;121        InterruptDisable();
;;;122        if (MBlk_Free == (MBLK *)0)
000002  4a08              LDR      r2,|L21.36|
000004  6850              LDR      r0,[r2,#4]  ; MBlk_Free
000006  2800              CMP      r0,#0
000008  d00a              BEQ      |L21.32|
;;;123        {
;;;124            /* kernel error!! no free message block !! */
;;;125            /* system should be down and wait the watch dog to reset the
;;;126               syste */
;;;127            /* modify the MAX_MBLK_NO define value to add message block number */
;;;128            //while (1);
;;;129            pmblk = (MBLK *)0;
;;;130        }
;;;131        else
;;;132        {
;;;133            if(MBlk_depth_Remaining > 0)
00000a  7811              LDRB     r1,[r2,#0]  ; MBlk_depth_Remaining
00000c  2900              CMP      r1,#0
00000e  d006              BEQ      |L21.30|
000010  1e49              SUBS     r1,r1,#1
;;;134            {
;;;135                MBlk_depth_Remaining--;
000012  7011              STRB     r1,[r2,#0]
;;;136                pmblk = MBlk_Free;
;;;137                MBlk_Free = pmblk->Next;
000014  6801              LDR      r1,[r0,#0]
;;;138                pmblk->Next = (MBLK *)0;
000016  6051              STR      r1,[r2,#4]  ; MBlk_Free
000018  2100              MOVS     r1,#0
00001a  6001              STR      r1,[r0,#0]
00001c  e000              B        |L21.32|
                  |L21.30|
;;;139            }
;;;140            else
;;;141            {
;;;142                pmblk = (MBLK *)0;
00001e  2000              MOVS     r0,#0
                  |L21.32|
;;;143            }
;;;144        }
;;;145        InterruptEnable();
000020  b662              CPSIE    i
;;;146        return(pmblk);
;;;147    }
000022  4770              BX       lr
;;;148    
                          ENDP

                  |L21.36|
                          DCD      ||.data||

                          AREA ||i.GetMsgBlk_Isr||, CODE, READONLY, ALIGN=2

                  GetMsgBlk_Isr PROC
;;;426    //#pragma ot(8, SPEED)
;;;427    MBLK *GetMsgBlk_Isr (void) //using 1 //same using with "rf0_ISR"
000000  4906              LDR      r1,|L22.28|
;;;428    {
;;;429        MBLK *pmblk;
;;;430    
;;;431        if (MBlk_Free == (MBLK *)0)
000002  6848              LDR      r0,[r1,#4]  ; MBlk_Free
000004  2800              CMP      r0,#0
000006  d007              BEQ      |L22.24|
;;;432        {
;;;433            //while (1);
;;;434            //pmblk = (MBLK *)0;
;;;435            ErrorEntry(16);
;;;436        }
;;;437        else
;;;438        {
;;;439            MBlk_depth_Remaining--;
000008  780a              LDRB     r2,[r1,#0]  ; MBlk_depth_Remaining
00000a  1e52              SUBS     r2,r2,#1
00000c  700a              STRB     r2,[r1,#0]
;;;440            pmblk = MBlk_Free;
;;;441            MBlk_Free = pmblk->Next;
00000e  6802              LDR      r2,[r0,#0]
;;;442            pmblk->Next = (MBLK *)0;
000010  604a              STR      r2,[r1,#4]  ; MBlk_Free
000012  2100              MOVS     r1,#0
000014  6001              STR      r1,[r0,#0]
;;;443        }
;;;444        return(pmblk);
;;;445    }
000016  4770              BX       lr
                  |L22.24|
000018  b672              CPSID    i
                  |L22.26|
00001a  e7fe              B        |L22.26|
;;;446    
                          ENDP

                  |L22.28|
                          DCD      ||.data||

                          AREA ||i.GetMsgBlk_L1_wSize_Isr||, CODE, READONLY, ALIGN=2

                  GetMsgBlk_L1_wSize_Isr PROC
;;;504    
;;;505    MBLK *GetMsgBlk_L1_wSize_Isr(Uint8 len)
000000  b430              PUSH     {r4,r5}
;;;506    {
;;;507        MBLK *pmblk;
;;;508        MBLK *pmblk_Temp;
;;;509        //Uint8 TgtRemaining;
;;;510        Uint8 num_MsgBlk;
;;;511    
;;;512        if (MBlk_Free == (MBLK *)0)
000002  4d13              LDR      r5,|L23.80|
000004  686c              LDR      r4,[r5,#4]  ; MBlk_Free
000006  2c00              CMP      r4,#0
000008  d01f              BEQ      |L23.74|
;;;513        {
;;;514            pmblk = (MBLK *)0;
;;;515        }
;;;516        else
;;;517        {
;;;518            if(len==0)
00000a  2800              CMP      r0,#0
00000c  d01c              BEQ      |L23.72|
;;;519            {
;;;520                pmblk = (MBLK *)0;
;;;521            }
;;;522            else
;;;523            {
;;;524                num_MsgBlk = 1;
00000e  2201              MOVS     r2,#1
000010  4621              MOV      r1,r4
;;;525                pmblk_Temp = MBlk_Free;
;;;526                while(len > SIZE_MBLK_ACL_DATA_UNIT)
000012  2829              CMP      r0,#0x29
000014  d90c              BLS      |L23.48|
                  |L23.22|
000016  1c52              ADDS     r2,r2,#1
;;;527                {
;;;528                    num_MsgBlk++;
;;;529                    if(pmblk_Temp->Next != (MBLK *)0)
000018  680b              LDR      r3,[r1,#0]
00001a  b2d2              UXTB     r2,r2                 ;528
00001c  2b00              CMP      r3,#0
00001e  d005              BEQ      |L23.44|
000020  3829              SUBS     r0,r0,#0x29
;;;530                    {
;;;531                        pmblk_Temp = pmblk_Temp->Next;
;;;532                    }
;;;533                    else
;;;534                    {
;;;535                        break;
;;;536                    }
;;;537                    len -= SIZE_MBLK_ACL_DATA_UNIT;
000022  b2c0              UXTB     r0,r0
000024  4619              MOV      r1,r3                 ;529
000026  2829              CMP      r0,#0x29              ;526
000028  d8f5              BHI      |L23.22|
00002a  e001              B        |L23.48|
                  |L23.44|
;;;538                }
;;;539                if(len <= SIZE_MBLK_ACL_DATA_UNIT)
00002c  2829              CMP      r0,#0x29
00002e  d80b              BHI      |L23.72|
                  |L23.48|
;;;540                {
;;;541                    if(MBlk_depth_Remaining >= (num_MsgBlk+MAX_MBLK_RSV_L1))
000030  7828              LDRB     r0,[r5,#0]  ; MBlk_depth_Remaining
000032  4613              MOV      r3,r2
000034  330a              ADDS     r3,r3,#0xa
000036  4298              CMP      r0,r3
000038  d306              BCC      |L23.72|
;;;542                    {
;;;543                        MBlk_depth_Remaining-=num_MsgBlk;
00003a  1a80              SUBS     r0,r0,r2
00003c  7028              STRB     r0,[r5,#0]
;;;544    
;;;545                        pmblk = MBlk_Free;
;;;546                        MBlk_Free = pmblk_Temp->Next;
00003e  6808              LDR      r0,[r1,#0]
;;;547                        pmblk_Temp->Next = (MBLK *)0;
000040  6068              STR      r0,[r5,#4]  ; MBlk_Free
000042  2000              MOVS     r0,#0
000044  6008              STR      r0,[r1,#0]
000046  e000              B        |L23.74|
                  |L23.72|
;;;548                    }
;;;549                    else
;;;550                    {
;;;551                        pmblk = (MBLK *)0;
;;;552                    }
;;;553                }
;;;554                else
;;;555                {
;;;556                    pmblk = (MBLK *)0;
000048  2400              MOVS     r4,#0
                  |L23.74|
;;;557                }
;;;558            }
;;;559        }
;;;560        return(pmblk);          //return "(MBLK *)0" means fail
00004a  4620              MOV      r0,r4
;;;561    }
00004c  bc30              POP      {r4,r5}
00004e  4770              BX       lr
;;;562    
                          ENDP

                  |L23.80|
                          DCD      ||.data||

                          AREA ||i.GetMsgBlk_L2_wSize||, CODE, READONLY, ALIGN=2

                  GetMsgBlk_L2_wSize PROC
;;;212    
;;;213    MBLK *GetMsgBlk_L2_wSize(Uint8 len)
000000  b530              PUSH     {r4,r5,lr}
;;;214    {
;;;215        MBLK *pmblk;
;;;216        MBLK *pmblk_Temp;
;;;217        //Uint8 TgtRemaining;
;;;218        Uint8 num_MsgBlk;
;;;219    
;;;220        InterruptDisable();
000002  b672              CPSID    i
;;;221        if (MBlk_Free == (MBLK *)0)
000004  4d12              LDR      r5,|L24.80|
000006  686b              LDR      r3,[r5,#4]  ; MBlk_Free
000008  2b00              CMP      r3,#0
00000a  d01e              BEQ      |L24.74|
;;;222        {
;;;223            pmblk = (MBLK *)0;
;;;224        }
;;;225        else
;;;226        {
;;;227            if(len==0)
00000c  2800              CMP      r0,#0
00000e  d01b              BEQ      |L24.72|
;;;228            {
;;;229                pmblk = (MBLK *)0;
;;;230            }
;;;231            else
;;;232            {
;;;233                num_MsgBlk = 1;
000010  2201              MOVS     r2,#1
000012  4619              MOV      r1,r3
;;;234                pmblk_Temp = MBlk_Free;
;;;235                while(len > SIZE_MBLK_ACL_DATA_UNIT)
000014  e007              B        |L24.38|
                  |L24.22|
000016  1c52              ADDS     r2,r2,#1
;;;236                {
;;;237                    num_MsgBlk++;
;;;238                    if(pmblk_Temp->Next != (MBLK *)0)
000018  680c              LDR      r4,[r1,#0]
00001a  b2d2              UXTB     r2,r2                 ;237
00001c  2c00              CMP      r4,#0
00001e  d005              BEQ      |L24.44|
000020  3829              SUBS     r0,r0,#0x29
000022  4621              MOV      r1,r4
;;;239                    {
;;;240                        pmblk_Temp = pmblk_Temp->Next;
;;;241                    }
;;;242                    else
;;;243                    {
;;;244                        break;
;;;245                    }
;;;246                    len -= SIZE_MBLK_ACL_DATA_UNIT;
000024  b2c0              UXTB     r0,r0
                  |L24.38|
000026  2829              CMP      r0,#0x29              ;235
000028  d8f5              BHI      |L24.22|
00002a  e001              B        |L24.48|
                  |L24.44|
;;;247                }
;;;248                if(len <= SIZE_MBLK_ACL_DATA_UNIT)
00002c  2829              CMP      r0,#0x29
00002e  d80b              BHI      |L24.72|
                  |L24.48|
;;;249                {
;;;250                    if(MBlk_depth_Remaining >= (num_MsgBlk+MAX_MBLK_RSV_L2))
000030  7828              LDRB     r0,[r5,#0]  ; MBlk_depth_Remaining
000032  4614              MOV      r4,r2
000034  341e              ADDS     r4,r4,#0x1e
000036  42a0              CMP      r0,r4
000038  d306              BCC      |L24.72|
;;;251                    {
;;;252                        MBlk_depth_Remaining-=num_MsgBlk;
00003a  1a80              SUBS     r0,r0,r2
00003c  7028              STRB     r0,[r5,#0]
;;;253    
;;;254                        pmblk = MBlk_Free;
;;;255                        MBlk_Free = pmblk_Temp->Next;
00003e  6808              LDR      r0,[r1,#0]
;;;256                        pmblk_Temp->Next = (MBLK *)0;
000040  6068              STR      r0,[r5,#4]  ; MBlk_Free
000042  2000              MOVS     r0,#0
000044  6008              STR      r0,[r1,#0]
000046  e000              B        |L24.74|
                  |L24.72|
;;;257                    }
;;;258                    else
;;;259                    {
;;;260                        pmblk = (MBLK *)0;
;;;261                    }
;;;262                }
;;;263                else
;;;264                {
;;;265                    pmblk = (MBLK *)0;
000048  2300              MOVS     r3,#0
                  |L24.74|
;;;266                }
;;;267            }
;;;268        }
;;;269        InterruptEnable();
00004a  b662              CPSIE    i
;;;270        return(pmblk);          //return "(MBLK *)0" means fail
00004c  4618              MOV      r0,r3
;;;271    }
00004e  bd30              POP      {r4,r5,pc}
;;;272    
                          ENDP

                  |L24.80|
                          DCD      ||.data||

                          AREA ||i.GetMsgBlk_L2_wSize_Isr||, CODE, READONLY, ALIGN=2

                  GetMsgBlk_L2_wSize_Isr PROC
;;;446    
;;;447    MBLK *GetMsgBlk_L2_wSize_Isr(Uint8 len)
000000  b430              PUSH     {r4,r5}
;;;448    {
;;;449        MBLK *pmblk;
;;;450        MBLK *pmblk_Temp;
;;;451        //Uint8 TgtRemaining;
;;;452        Uint8 num_MsgBlk;
;;;453    
;;;454        if (MBlk_Free == (MBLK *)0)
000002  4d13              LDR      r5,|L25.80|
000004  686c              LDR      r4,[r5,#4]  ; MBlk_Free
000006  2c00              CMP      r4,#0
000008  d01f              BEQ      |L25.74|
;;;455        {
;;;456            pmblk = (MBLK *)0;
;;;457        }
;;;458        else
;;;459        {
;;;460            if(len==0)
00000a  2800              CMP      r0,#0
00000c  d01c              BEQ      |L25.72|
;;;461            {
;;;462                pmblk = (MBLK *)0;
;;;463            }
;;;464            else
;;;465            {
;;;466                num_MsgBlk = 1;
00000e  2201              MOVS     r2,#1
000010  4621              MOV      r1,r4
;;;467                pmblk_Temp = MBlk_Free;
;;;468                while(len > SIZE_MBLK_ACL_DATA_UNIT)
000012  2829              CMP      r0,#0x29
000014  d90c              BLS      |L25.48|
                  |L25.22|
000016  1c52              ADDS     r2,r2,#1
;;;469                {
;;;470                    num_MsgBlk++;
;;;471                    if(pmblk_Temp->Next != (MBLK *)0)
000018  680b              LDR      r3,[r1,#0]
00001a  b2d2              UXTB     r2,r2                 ;470
00001c  2b00              CMP      r3,#0
00001e  d005              BEQ      |L25.44|
000020  3829              SUBS     r0,r0,#0x29
;;;472                    {
;;;473                        pmblk_Temp = pmblk_Temp->Next;
;;;474                    }
;;;475                    else
;;;476                    {
;;;477                        break;
;;;478                    }
;;;479                    len -= SIZE_MBLK_ACL_DATA_UNIT;
000022  b2c0              UXTB     r0,r0
000024  4619              MOV      r1,r3                 ;471
000026  2829              CMP      r0,#0x29              ;468
000028  d8f5              BHI      |L25.22|
00002a  e001              B        |L25.48|
                  |L25.44|
;;;480                }
;;;481                if(len <= SIZE_MBLK_ACL_DATA_UNIT)
00002c  2829              CMP      r0,#0x29
00002e  d80b              BHI      |L25.72|
                  |L25.48|
;;;482                {
;;;483                    if(MBlk_depth_Remaining >= (num_MsgBlk+MAX_MBLK_RSV_L2))
000030  7828              LDRB     r0,[r5,#0]  ; MBlk_depth_Remaining
000032  4613              MOV      r3,r2
000034  331e              ADDS     r3,r3,#0x1e
000036  4298              CMP      r0,r3
000038  d306              BCC      |L25.72|
;;;484                    {
;;;485                        MBlk_depth_Remaining-=num_MsgBlk;
00003a  1a80              SUBS     r0,r0,r2
00003c  7028              STRB     r0,[r5,#0]
;;;486    
;;;487                        pmblk = MBlk_Free;
;;;488                        MBlk_Free = pmblk_Temp->Next;
00003e  6808              LDR      r0,[r1,#0]
;;;489                        pmblk_Temp->Next = (MBLK *)0;
000040  6068              STR      r0,[r5,#4]  ; MBlk_Free
000042  2000              MOVS     r0,#0
000044  6008              STR      r0,[r1,#0]
000046  e000              B        |L25.74|
                  |L25.72|
;;;490                    }
;;;491                    else
;;;492                    {
;;;493                        pmblk = (MBLK *)0;
;;;494                    }
;;;495                }
;;;496                else
;;;497                {
;;;498                    pmblk = (MBLK *)0;
000048  2400              MOVS     r4,#0
                  |L25.74|
;;;499                }
;;;500            }
;;;501        }
;;;502        return(pmblk);          //return "(MBLK *)0" means fail
00004a  4620              MOV      r0,r4
;;;503    }
00004c  bc30              POP      {r4,r5}
00004e  4770              BX       lr
;;;504    
                          ENDP

                  |L25.80|
                          DCD      ||.data||

                          AREA ||i.KernelCollect||, CODE, READONLY, ALIGN=1

                  KernelCollect PROC
;;;1190   
;;;1191   void KernelCollect(void)
000000  b430              PUSH     {r4,r5}
000002  6808              LDR      r0,[r1,#0]
000004  0e02              LSRS     r2,r0,#24
000006  700a              STRB     r2,[r1,#0]
000008  0202              LSLS     r2,r0,#8
00000a  0e12              LSRS     r2,r2,#24
00000c  704a              STRB     r2,[r1,#1]
00000e  0402              LSLS     r2,r0,#16
000010  0e12              LSRS     r2,r2,#24
000012  708a              STRB     r2,[r1,#2]
000014  70c8              STRB     r0,[r1,#3]
;;;1192   {
;;;1193       Uint8 *a;
;;;1194       Uint8 *b;
;;;1195   
;;;1196       EndianSwap32addr((Uint32 *)a);
;;;1197       EndianSwap32((Uint32)a);
;;;1198   
;;;1199       Knl_MemCpyInv_Isr(a, a, 1);
000016  2001              MOVS     r0,#1
000018  2200              MOVS     r2,#0
                  |L26.26|
00001a  5c8d              LDRB     r5,[r1,r2]
00001c  1e40              SUBS     r0,r0,#1
00001e  b2c0              UXTB     r0,r0
000020  1c52              ADDS     r2,r2,#1
000022  540d              STRB     r5,[r1,r0]
000024  b2d2              UXTB     r2,r2
000026  2800              CMP      r0,#0
000028  d1f7              BNE      |L26.26|
;;;1200       Knl_CodeCpyInv_Isr(a, b, 1);
00002a  2001              MOVS     r0,#1
00002c  2200              MOVS     r2,#0
                  |L26.46|
00002e  5c9d              LDRB     r5,[r3,r2]
000030  1e40              SUBS     r0,r0,#1
000032  b2c0              UXTB     r0,r0
000034  1c52              ADDS     r2,r2,#1
000036  540d              STRB     r5,[r1,r0]
000038  b2d2              UXTB     r2,r2
00003a  2800              CMP      r0,#0
00003c  d1f7              BNE      |L26.46|
;;;1201       Knl_CodeCpyInv(a, b, 1);
00003e  2001              MOVS     r0,#1
000040  2200              MOVS     r2,#0
                  |L26.66|
000042  5c9d              LDRB     r5,[r3,r2]
000044  1e40              SUBS     r0,r0,#1
000046  b2c0              UXTB     r0,r0
000048  1c52              ADDS     r2,r2,#1
00004a  540d              STRB     r5,[r1,r0]
00004c  b2d2              UXTB     r2,r2
00004e  2800              CMP      r0,#0
000050  d1f7              BNE      |L26.66|
;;;1202       //i = Knl_MemComp_Isr(a, a, 255);
;;;1203       Knl_CodeComp_Isr(a, b, 255);
000052  22ff              MOVS     r2,#0xff
                  |L26.84|
000054  5c1c              LDRB     r4,[r3,r0]
000056  5c0d              LDRB     r5,[r1,r0]
000058  42ac              CMP      r4,r5
00005a  d103              BNE      |L26.100|
00005c  1c40              ADDS     r0,r0,#1
00005e  b2c0              UXTB     r0,r0
000060  4290              CMP      r0,r2
000062  d3f7              BCC      |L26.84|
                  |L26.100|
;;;1204   }
000064  bc30              POP      {r4,r5}
000066  4770              BX       lr
;;;1205   #pragma pop
                          ENDP


                          AREA ||i.KernelInit||, CODE, READONLY, ALIGN=2

                  KernelInit PROC
;;;84      *******************************************************************/
;;;85     void KernelInit(void)
000000  4a0f              LDR      r2,|L27.64|
;;;86     {
;;;87         Uint8 i;
;;;88     
;;;89         /* Initial message block,
;;;90            link up free list of message block */
;;;91         for (i=0; i<(MAX_MBLK_NO-1); i++)
000002  2000              MOVS     r0,#0
                  |L27.4|
;;;92         {
;;;93             MsgBlk[i].Next = (MBLK *)&MsgBlk[i+1];
000004  2134              MOVS     r1,#0x34
000006  4341              MULS     r1,r0,r1
000008  188b              ADDS     r3,r1,r2
00000a  3334              ADDS     r3,r3,#0x34
00000c  1c40              ADDS     r0,r0,#1
00000e  b2c0              UXTB     r0,r0                 ;91
000010  5053              STR      r3,[r2,r1]
000012  283b              CMP      r0,#0x3b              ;91
000014  d3f6              BCC      |L27.4|
;;;94         }
;;;95         MsgBlk[i].Next = (MBLK *)0;
000016  2134              MOVS     r1,#0x34
000018  2300              MOVS     r3,#0
00001a  4348              MULS     r0,r1,r0
00001c  5013              STR      r3,[r2,r0]
;;;96         MBlk_Free = (MBLK *)&MsgBlk[0];
00001e  4809              LDR      r0,|L27.68|
;;;97         MBlk_depth_Remaining = MAX_MBLK_NO;             //initialization
000020  213c              MOVS     r1,#0x3c
000022  6042              STR      r2,[r0,#4]  ; MBlk_Free
000024  7001              STRB     r1,[r0,#0]
;;;98         MBlk_depth_Rsv = 0;                             //initialization
000026  7043              STRB     r3,[r0,#1]
;;;99     
;;;100        for (i=0; i<MAX_QUEUE_NO; i++)
;;;101        {
;;;102            MsgQueue[i].QIn = (MBLK *)0;
000028  4a07              LDR      r2,|L27.72|
00002a  4618              MOV      r0,r3                 ;100
                  |L27.44|
00002c  00c1              LSLS     r1,r0,#3
00002e  5053              STR      r3,[r2,r1]
;;;103            MsgQueue[i].QOut = (MBLK *)0;
000030  1889              ADDS     r1,r1,r2
000032  1c40              ADDS     r0,r0,#1
000034  b2c0              UXTB     r0,r0                 ;100
000036  604b              STR      r3,[r1,#4]            ;100
000038  2805              CMP      r0,#5                 ;100
00003a  d3f7              BCC      |L27.44|
;;;104        }
;;;105    }
00003c  4770              BX       lr
;;;106    
                          ENDP

00003e  0000              DCW      0x0000
                  |L27.64|
                          DCD      ||.bss||
                  |L27.68|
                          DCD      ||.data||
                  |L27.72|
                          DCD      ||.bss||+0xc30

                          AREA ||i.Knl_CodeComp||, CODE, READONLY, ALIGN=1

                  Knl_CodeComp PROC
;;;865    
;;;866    Uint8 Knl_CodeComp(Uint8 *pDst, Uint8 const *pSrc, Uint8 len)
000000  b430              PUSH     {r4,r5}
;;;867    {
;;;868        uint8_t i;
;;;869    
;;;870        for(i=0; i<len; i++)
000002  2300              MOVS     r3,#0
000004  2a00              CMP      r2,#0
000006  d907              BLS      |L28.24|
                  |L28.8|
;;;871        {
;;;872            if(*(pSrc+i) != *(pDst+i))
000008  5ccc              LDRB     r4,[r1,r3]
00000a  5cc5              LDRB     r5,[r0,r3]
00000c  42ac              CMP      r4,r5
00000e  d103              BNE      |L28.24|
000010  1c5b              ADDS     r3,r3,#1
000012  b2db              UXTB     r3,r3                 ;870
000014  4293              CMP      r3,r2                 ;870
000016  d3f7              BCC      |L28.8|
                  |L28.24|
;;;873            {
;;;874                break;
;;;875            }
;;;876        }
;;;877    
;;;878        return (len-i);     //SUCCESS: 0
000018  1ad0              SUBS     r0,r2,r3
;;;879    }
00001a  bc30              POP      {r4,r5}
00001c  b2c0              UXTB     r0,r0                 ;878
00001e  4770              BX       lr
;;;880    
                          ENDP


                          AREA ||i.Knl_CodeComp_Isr||, CODE, READONLY, ALIGN=1

                  Knl_CodeComp_Isr PROC
;;;961    
;;;962    Uint8 Knl_CodeComp_Isr(Uint8 *pDst, Uint8 const *pSrc, Uint8 len)
000000  b430              PUSH     {r4,r5}
;;;963    {
;;;964        uint8_t i;
;;;965    
;;;966        for(i=0; i<len; i++)
000002  2300              MOVS     r3,#0
000004  2a00              CMP      r2,#0
000006  d907              BLS      |L29.24|
                  |L29.8|
;;;967        {
;;;968            if(*(pSrc+i) != *(pDst+i))
000008  5ccc              LDRB     r4,[r1,r3]
00000a  5cc5              LDRB     r5,[r0,r3]
00000c  42ac              CMP      r4,r5
00000e  d103              BNE      |L29.24|
000010  1c5b              ADDS     r3,r3,#1
000012  b2db              UXTB     r3,r3                 ;966
000014  4293              CMP      r3,r2                 ;966
000016  d3f7              BCC      |L29.8|
                  |L29.24|
;;;969            {
;;;970                break;
;;;971            }
;;;972        }
;;;973    
;;;974        return (len-i);     //SUCCESS: 0
000018  1ad0              SUBS     r0,r2,r3
;;;975    }
00001a  bc30              POP      {r4,r5}
00001c  b2c0              UXTB     r0,r0                 ;974
00001e  4770              BX       lr
;;;976    
                          ENDP


                          AREA ||i.Knl_CodeCpy||, CODE, READONLY, ALIGN=1

                  Knl_CodeCpy PROC
;;;817    
;;;818    void Knl_CodeCpy(Uint8 *pDst, Uint8 const *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;819    {
000002  d005              BEQ      |L30.16|
                  |L30.4|
000004  1e52              SUBS     r2,r2,#1
;;;820        if(len)
;;;821        {
;;;822            do
;;;823            {
;;;824                len--;
000006  0612              LSLS     r2,r2,#24
000008  0e12              LSRS     r2,r2,#24
;;;825                *(pDst+len) = *(pSrc+len);
00000a  5c8b              LDRB     r3,[r1,r2]
00000c  5483              STRB     r3,[r0,r2]
;;;826            }
;;;827            while(len != 0);
00000e  d1f9              BNE      |L30.4|
                  |L30.16|
;;;828        }
;;;829    }
000010  4770              BX       lr
;;;830    
                          ENDP


                          AREA ||i.Knl_CodeCpyInv||, CODE, READONLY, ALIGN=1

                  Knl_CodeCpyInv PROC
;;;831    
;;;832    void Knl_CodeCpyInv(Uint8 *pDst, Uint8 const *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;833    {
;;;834        Uint8 i;
;;;835    
;;;836        if(len)
000002  d00b              BEQ      |L31.28|
000004  b410              PUSH     {r4}                  ;833
;;;837        {
;;;838            i = 0;
000006  2300              MOVS     r3,#0
                  |L31.8|
;;;839            do
;;;840            {
;;;841                len--;
;;;842                *(pDst+len) = *(pSrc+i);
000008  5ccc              LDRB     r4,[r1,r3]
00000a  1e52              SUBS     r2,r2,#1              ;833
00000c  b2d2              UXTB     r2,r2                 ;841
00000e  1c5b              ADDS     r3,r3,#1
000010  5484              STRB     r4,[r0,r2]
;;;843                i++;
000012  b2db              UXTB     r3,r3
;;;844            }
;;;845            while(len != 0);
000014  2a00              CMP      r2,#0
000016  d1f7              BNE      |L31.8|
;;;846        }
;;;847    }
000018  bc10              POP      {r4}
00001a  4770              BX       lr
                  |L31.28|
00001c  4770              BX       lr
;;;848    
                          ENDP


                          AREA ||i.Knl_CodeCpyInv_Isr||, CODE, READONLY, ALIGN=1

                  Knl_CodeCpyInv_Isr PROC
;;;927    
;;;928    void Knl_CodeCpyInv_Isr(Uint8 *pDst, Uint8 const *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;929    {
;;;930        Uint8 i;
;;;931    
;;;932        if(len)
000002  d00b              BEQ      |L32.28|
000004  b410              PUSH     {r4}                  ;929
;;;933        {
;;;934            i = 0;
000006  2300              MOVS     r3,#0
                  |L32.8|
;;;935            do
;;;936            {
;;;937                len--;
;;;938                *(pDst+len) = *(pSrc+i);
000008  5ccc              LDRB     r4,[r1,r3]
00000a  1e52              SUBS     r2,r2,#1              ;929
00000c  b2d2              UXTB     r2,r2                 ;937
00000e  1c5b              ADDS     r3,r3,#1
000010  5484              STRB     r4,[r0,r2]
;;;939                i++;
000012  b2db              UXTB     r3,r3
;;;940            }
;;;941            while(len != 0);
000014  2a00              CMP      r2,#0
000016  d1f7              BNE      |L32.8|
;;;942        }
;;;943    }
000018  bc10              POP      {r4}
00001a  4770              BX       lr
                  |L32.28|
00001c  4770              BX       lr
;;;944    
                          ENDP


                          AREA ||i.Knl_CodeCpy_Isr||, CODE, READONLY, ALIGN=1

                  Knl_CodeCpy_Isr PROC
;;;913    
;;;914    void Knl_CodeCpy_Isr(Uint8 *pDst, Uint8 const *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;915    {
000002  d005              BEQ      |L33.16|
                  |L33.4|
000004  1e52              SUBS     r2,r2,#1
;;;916        if(len)
;;;917        {
;;;918            do
;;;919            {
;;;920                len--;
000006  0612              LSLS     r2,r2,#24
000008  0e12              LSRS     r2,r2,#24
;;;921                *(pDst+len) = *(pSrc+len);
00000a  5c8b              LDRB     r3,[r1,r2]
00000c  5483              STRB     r3,[r0,r2]
;;;922            }
;;;923            while(len != 0);
00000e  d1f9              BNE      |L33.4|
                  |L33.16|
;;;924        }
;;;925    }
000010  4770              BX       lr
;;;926    
                          ENDP


                          AREA ||i.Knl_MemComp||, CODE, READONLY, ALIGN=1

                  Knl_MemComp PROC
;;;849    
;;;850    Uint8 Knl_MemComp(Uint8 *pDst, Uint8 *pSrc, Uint8 len)
000000  b430              PUSH     {r4,r5}
;;;851    {
;;;852        uint8_t i;
;;;853    
;;;854        for(i=0; i<len; i++)
000002  2300              MOVS     r3,#0
000004  2a00              CMP      r2,#0
000006  d907              BLS      |L34.24|
                  |L34.8|
;;;855        {
;;;856            if(*(pSrc+i) != *(pDst+i))
000008  5ccc              LDRB     r4,[r1,r3]
00000a  5cc5              LDRB     r5,[r0,r3]
00000c  42ac              CMP      r4,r5
00000e  d103              BNE      |L34.24|
000010  1c5b              ADDS     r3,r3,#1
000012  b2db              UXTB     r3,r3                 ;854
000014  4293              CMP      r3,r2                 ;854
000016  d3f7              BCC      |L34.8|
                  |L34.24|
;;;857            {
;;;858                break;
;;;859            }
;;;860        }
;;;861    
;;;862        return (len-i);     //SUCCESS: 0
000018  1ad0              SUBS     r0,r2,r3
;;;863    }
00001a  bc30              POP      {r4,r5}
00001c  b2c0              UXTB     r0,r0                 ;862
00001e  4770              BX       lr
;;;864    
                          ENDP


                          AREA ||i.Knl_MemComp_Isr||, CODE, READONLY, ALIGN=1

                  Knl_MemComp_Isr PROC
;;;945    
;;;946    Uint8 Knl_MemComp_Isr(Uint8 *pDst, Uint8 *pSrc, Uint8 len)
000000  b430              PUSH     {r4,r5}
;;;947    {
;;;948        uint8_t i;
;;;949    
;;;950        for(i=0; i<len; i++)
000002  2300              MOVS     r3,#0
000004  2a00              CMP      r2,#0
000006  d907              BLS      |L35.24|
                  |L35.8|
;;;951        {
;;;952            if(*(pSrc+i) != *(pDst+i))
000008  5ccc              LDRB     r4,[r1,r3]
00000a  5cc5              LDRB     r5,[r0,r3]
00000c  42ac              CMP      r4,r5
00000e  d103              BNE      |L35.24|
000010  1c5b              ADDS     r3,r3,#1
000012  b2db              UXTB     r3,r3                 ;950
000014  4293              CMP      r3,r2                 ;950
000016  d3f7              BCC      |L35.8|
                  |L35.24|
;;;953            {
;;;954                break;
;;;955            }
;;;956        }
;;;957    
;;;958        return (len-i);     //SUCCESS: 0
000018  1ad0              SUBS     r0,r2,r3
;;;959    }
00001a  bc30              POP      {r4,r5}
00001c  b2c0              UXTB     r0,r0                 ;958
00001e  4770              BX       lr
;;;960    
                          ENDP


                          AREA ||i.Knl_MemCpy||, CODE, READONLY, ALIGN=1

                  Knl_MemCpy PROC
;;;774     *******************************************************************/
;;;775    void Knl_MemCpy(Uint8 *pDst, Uint8 *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;776    {
000002  d005              BEQ      |L36.16|
                  |L36.4|
000004  1e52              SUBS     r2,r2,#1
;;;777        if(len)
;;;778        {
;;;779            do
;;;780            {
;;;781                len--;
000006  0612              LSLS     r2,r2,#24
000008  0e12              LSRS     r2,r2,#24
;;;782                *(pDst+len) = *(pSrc+len);
00000a  5c8b              LDRB     r3,[r1,r2]
00000c  5483              STRB     r3,[r0,r2]
;;;783            }
;;;784            while(len != 0);
00000e  d1f9              BNE      |L36.4|
                  |L36.16|
;;;785        }
;;;786    }
000010  4770              BX       lr
;;;787    
                          ENDP


                          AREA ||i.Knl_MemCpyInv||, CODE, READONLY, ALIGN=1

                  Knl_MemCpyInv PROC
;;;799    
;;;800    void Knl_MemCpyInv(Uint8 *pDst, Uint8 *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;801    {
;;;802        Uint8 i;
;;;803    
;;;804        if(len)
000002  d00b              BEQ      |L37.28|
000004  b410              PUSH     {r4}                  ;801
;;;805        {
;;;806            i = 0;
000006  2300              MOVS     r3,#0
                  |L37.8|
;;;807            do
;;;808            {
;;;809                len--;
;;;810                *(pDst+len) = *(pSrc+i);
000008  5ccc              LDRB     r4,[r1,r3]
00000a  1e52              SUBS     r2,r2,#1              ;801
00000c  b2d2              UXTB     r2,r2                 ;809
00000e  1c5b              ADDS     r3,r3,#1
000010  5484              STRB     r4,[r0,r2]
;;;811                i++;
000012  b2db              UXTB     r3,r3
;;;812            }
;;;813            while(len != 0);
000014  2a00              CMP      r2,#0
000016  d1f7              BNE      |L37.8|
;;;814        }
;;;815    }
000018  bc10              POP      {r4}
00001a  4770              BX       lr
                  |L37.28|
00001c  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.Knl_MemCpyInv_Isr||, CODE, READONLY, ALIGN=1

                  Knl_MemCpyInv_Isr PROC
;;;895    
;;;896    void Knl_MemCpyInv_Isr(Uint8 *pDst, Uint8 *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;897    {
;;;898        Uint8 i;
;;;899    
;;;900        if(len)
000002  d00b              BEQ      |L38.28|
000004  b410              PUSH     {r4}                  ;897
;;;901        {
;;;902            i = 0;
000006  2300              MOVS     r3,#0
                  |L38.8|
;;;903            do
;;;904            {
;;;905                len--;
;;;906                *(pDst+len) = *(pSrc+i);
000008  5ccc              LDRB     r4,[r1,r3]
00000a  1e52              SUBS     r2,r2,#1              ;897
00000c  b2d2              UXTB     r2,r2                 ;905
00000e  1c5b              ADDS     r3,r3,#1
000010  5484              STRB     r4,[r0,r2]
;;;907                i++;
000012  b2db              UXTB     r3,r3
;;;908            }
;;;909            while(len != 0);
000014  2a00              CMP      r2,#0
000016  d1f7              BNE      |L38.8|
;;;910        }
;;;911    }
000018  bc10              POP      {r4}
00001a  4770              BX       lr
                  |L38.28|
00001c  4770              BX       lr
;;;912    
                          ENDP


                          AREA ||i.Knl_MemCpy_Fwd||, CODE, READONLY, ALIGN=1

                  Knl_MemCpy_Fwd PROC
;;;788    
;;;789    void Knl_MemCpy_Fwd(Uint8 *pDst, Uint8 *pSrc, Uint8 len)
000000  2300              MOVS     r3,#0
;;;790    {
;;;791        Uint8 i;
;;;792    
;;;793        for(i=0; i<len; i++)
000002  2a00              CMP      r2,#0
000004  d908              BLS      |L39.24|
000006  b410              PUSH     {r4}                  ;790
                  |L39.8|
;;;794        {
;;;795            *(pDst+i) = *(pSrc+i);
000008  5ccc              LDRB     r4,[r1,r3]
00000a  54c4              STRB     r4,[r0,r3]
00000c  1c5b              ADDS     r3,r3,#1
00000e  b2db              UXTB     r3,r3                 ;793
000010  4293              CMP      r3,r2                 ;793
000012  d3f9              BCC      |L39.8|
;;;796        }
;;;797    }
000014  bc10              POP      {r4}
000016  4770              BX       lr
                  |L39.24|
000018  4770              BX       lr
;;;798    
                          ENDP


                          AREA ||i.Knl_MemCpy_Isr||, CODE, READONLY, ALIGN=1

                  Knl_MemCpy_Isr PROC
;;;881    
;;;882    void Knl_MemCpy_Isr(Uint8 *pDst, Uint8 *pSrc, Uint8 len)
000000  2a00              CMP      r2,#0
;;;883    {
000002  d005              BEQ      |L40.16|
                  |L40.4|
000004  1e52              SUBS     r2,r2,#1
;;;884        if(len)
;;;885        {
;;;886            do
;;;887            {
;;;888                len--;
000006  0612              LSLS     r2,r2,#24
000008  0e12              LSRS     r2,r2,#24
;;;889                *(pDst+len) = *(pSrc+len);
00000a  5c8b              LDRB     r3,[r1,r2]
00000c  5483              STRB     r3,[r0,r2]
;;;890            }
;;;891            while(len != 0);
00000e  d1f9              BNE      |L40.4|
                  |L40.16|
;;;892        }
;;;893    }
000010  4770              BX       lr
;;;894    
                          ENDP


                          AREA ||i.RcvMsgBlk||, CODE, READONLY, ALIGN=2

                  RcvMsgBlk PROC
;;;710     *******************************************************************/
;;;711    MBLK *RcvMsgBlk(Uint8 QueueId)
000000  4907              LDR      r1,|L41.32|
;;;712    {
;;;713        MQUEUE *pqueue;
;;;714        MBLK *pmblk;
;;;715    
;;;716        pqueue = (MQUEUE *)&MsgQueue[QueueId];
000002  00c0              LSLS     r0,r0,#3
000004  1841              ADDS     r1,r0,r1
;;;717        InterruptDisable();
000006  b672              CPSID    i
;;;718        pmblk = pqueue->QOut;
;;;719        if (pqueue->QOut == pqueue->QIn)
000008  680a              LDR      r2,[r1,#0]
00000a  6848              LDR      r0,[r1,#4]
00000c  4290              CMP      r0,r2
00000e  d103              BNE      |L41.24|
;;;720        {
;;;721            pqueue->QOut = (MBLK *)0;
000010  2200              MOVS     r2,#0
;;;722            pqueue->QIn = (MBLK *)0;
000012  604a              STR      r2,[r1,#4]
000014  600a              STR      r2,[r1,#0]
000016  e001              B        |L41.28|
                  |L41.24|
;;;723        }
;;;724        else
;;;725        {
;;;726            pqueue->QOut = pmblk->Next;
000018  6802              LDR      r2,[r0,#0]
00001a  604a              STR      r2,[r1,#4]
                  |L41.28|
;;;727        }
;;;728        InterruptEnable();
00001c  b662              CPSIE    i
;;;729        return(pmblk);  /* return the indexer of message block which we retrived */
;;;730    }
00001e  4770              BX       lr
;;;731    
                          ENDP

                  |L41.32|
                          DCD      ||.bss||+0xc30

                          AREA ||i.SndMsgBlk||, CODE, READONLY, ALIGN=2

                  SndMsgBlk PROC
;;;335     *******************************************************************/
;;;336    void SndMsgBlk(MBLK *pMsgBlk, Uint8 QueueId)
000000  4a06              LDR      r2,|L42.28|
;;;337    {
;;;338        MQUEUE *pqueue;
;;;339    
;;;340        pqueue = &MsgQueue[QueueId];
000002  00c9              LSLS     r1,r1,#3
000004  1889              ADDS     r1,r1,r2
;;;341        InterruptDisable();
000006  b672              CPSID    i
;;;342        if (pqueue->QIn == (MBLK *)0)
000008  680a              LDR      r2,[r1,#0]
00000a  2a00              CMP      r2,#0
00000c  d003              BEQ      |L42.22|
;;;343        {
;;;344            pqueue->QOut = pMsgBlk;
;;;345            pqueue->QIn = pMsgBlk;
;;;346        }
;;;347        else
;;;348        {
;;;349            (pqueue->QIn)->Next = (MBLK *)pMsgBlk;
00000e  6010              STR      r0,[r2,#0]
                  |L42.16|
;;;350            pqueue->QIn = (MBLK *)pMsgBlk;
;;;351        }
;;;352        InterruptEnable();
000010  6008              STR      r0,[r1,#0]
000012  b662              CPSIE    i
;;;353    }
000014  4770              BX       lr
                  |L42.22|
000016  6048              STR      r0,[r1,#4]            ;345
000018  e7fa              B        |L42.16|
;;;354    
                          ENDP

00001a  0000              DCW      0x0000
                  |L42.28|
                          DCD      ||.bss||+0xc30

                          AREA ||i.SndMsgBlk_Isr||, CODE, READONLY, ALIGN=2

                  SndMsgBlk_Isr PROC
;;;620    
;;;621    void SndMsgBlk_Isr(MBLK *pMsgBlk, Uint8 QueueId) //using 1 //same using with "rf0_ISR"
000000  4a05              LDR      r2,|L43.24|
;;;622    {
;;;623        MQUEUE *pqueue;
;;;624    
;;;625        pqueue = &MsgQueue[QueueId];
000002  00c9              LSLS     r1,r1,#3
000004  1889              ADDS     r1,r1,r2
;;;626        if (pqueue->QIn == (MBLK *)0)
000006  680a              LDR      r2,[r1,#0]
000008  2a00              CMP      r2,#0
00000a  d002              BEQ      |L43.18|
;;;627        {
;;;628            pqueue->QOut = pMsgBlk;
;;;629            pqueue->QIn = pMsgBlk;
;;;630        }
;;;631        else
;;;632        {
;;;633            (pqueue->QIn)->Next = (MBLK *)pMsgBlk;
00000c  6010              STR      r0,[r2,#0]
                  |L43.14|
00000e  6008              STR      r0,[r1,#0]            ;629
;;;634            pqueue->QIn = (MBLK *)pMsgBlk;
;;;635        }
;;;636    }
000010  4770              BX       lr
                  |L43.18|
000012  6048              STR      r0,[r1,#4]            ;629
000014  e7fb              B        |L43.14|
;;;637    
                          ENDP

000016  0000              DCW      0x0000
                  |L43.24|
                          DCD      ||.bss||+0xc30

                          AREA ||i.SndMsgBlks||, CODE, READONLY, ALIGN=2

                  SndMsgBlks PROC
;;;370    
;;;371    void SndMsgBlks(MBLK *pMsgBlk, Uint8 QueueId)
000000  4a08              LDR      r2,|L44.36|
;;;372    {
;;;373        MQUEUE *pqueue;
;;;374    
;;;375        pqueue = &MsgQueue[QueueId];
000002  00c9              LSLS     r1,r1,#3
000004  1889              ADDS     r1,r1,r2
;;;376        InterruptDisable();
000006  b672              CPSID    i
;;;377        if (pqueue->QIn == (MBLK *)0)
000008  680a              LDR      r2,[r1,#0]
00000a  2a00              CMP      r2,#0
00000c  d002              BEQ      |L44.20|
;;;378        {
;;;379            pqueue->QOut = pMsgBlk;
;;;380            pqueue->QIn = pMsgBlk;
;;;381        }
;;;382        else
;;;383        {
;;;384            (pqueue->QIn)->Next = (MBLK *)pMsgBlk;
;;;385        }
;;;386        while((pqueue->QIn)->Next != (MBLK *)0)
00000e  6010              STR      r0,[r2,#0]
000010  6808              LDR      r0,[r1,#0]            ;384
000012  e001              B        |L44.24|
                  |L44.20|
000014  6048              STR      r0,[r1,#4]            ;379
                  |L44.22|
;;;387        {
;;;388            pqueue->QIn = (pqueue->QIn)->Next;
000016  6008              STR      r0,[r1,#0]
                  |L44.24|
000018  6800              LDR      r0,[r0,#0]            ;386
00001a  2800              CMP      r0,#0                 ;386
00001c  d1fb              BNE      |L44.22|
;;;389        }
;;;390        InterruptEnable();
00001e  b662              CPSIE    i
;;;391    }
000020  4770              BX       lr
;;;392    
                          ENDP

000022  0000              DCW      0x0000
                  |L44.36|
                          DCD      ||.bss||+0xc30

                          AREA ||i.SndMsgBlks_Isr||, CODE, READONLY, ALIGN=2

                  SndMsgBlks_Isr PROC
;;;650    
;;;651    void SndMsgBlks_Isr(MBLK *pMsgBlk, Uint8 QueueId)
000000  4a0a              LDR      r2,|L45.44|
;;;652    {
;;;653        MQUEUE *pqueue;
;;;654    
;;;655        pqueue = &MsgQueue[QueueId];
000002  00c9              LSLS     r1,r1,#3
000004  1889              ADDS     r1,r1,r2
;;;656        if (pqueue->QIn == (MBLK *)0)
000006  680a              LDR      r2,[r1,#0]
000008  2a00              CMP      r2,#0
00000a  d00b              BEQ      |L45.36|
;;;657        {
;;;658            pqueue->QOut = pMsgBlk;
;;;659            pqueue->QIn = pMsgBlk;
;;;660        }
;;;661        else
;;;662        {
;;;663            (pqueue->QIn)->Next = (MBLK *)pMsgBlk;
;;;664        }
;;;665        while((pqueue->QIn)->Next != (MBLK *)0)
00000c  6010              STR      r0,[r2,#0]
00000e  6808              LDR      r0,[r1,#0]
                  |L45.16|
000010  6800              LDR      r0,[r0,#0]
000012  2800              CMP      r0,#0
000014  d005              BEQ      |L45.34|
                  |L45.22|
;;;666        {
;;;667            pqueue->QIn = (pqueue->QIn)->Next;
000016  6808              LDR      r0,[r1,#0]
000018  6800              LDR      r0,[r0,#0]
00001a  6008              STR      r0,[r1,#0]            ;665
00001c  6800              LDR      r0,[r0,#0]            ;665
00001e  2800              CMP      r0,#0                 ;665
000020  d1f9              BNE      |L45.22|
                  |L45.34|
;;;668        }
;;;669    }
000022  4770              BX       lr
                  |L45.36|
000024  6048              STR      r0,[r1,#4]            ;659
000026  6008              STR      r0,[r1,#0]            ;659
000028  e7f2              B        |L45.16|
;;;670    
                          ENDP

00002a  0000              DCW      0x0000
                  |L45.44|
                          DCD      ||.bss||+0xc30

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MsgBlk
                          %        3120
                  MsgQueue
                          %        40

                          AREA ||.data||, DATA, ALIGN=2

                  MBlk_depth_Remaining
000000  00                DCB      0x00
                  MBlk_depth_Rsv
000001  000000            DCB      0x00,0x00,0x00
                  MBlk_Free
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L272.16|
00000e  461d              MOV      r5,r3
                  |L272.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_e521616c____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_kernel_c_e521616c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_e521616c____REVSH|
#line 402
|__asm___8_kernel_c_e521616c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
