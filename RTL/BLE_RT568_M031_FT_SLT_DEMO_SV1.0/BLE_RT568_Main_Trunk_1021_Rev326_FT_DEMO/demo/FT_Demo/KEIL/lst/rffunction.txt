; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\rffunction.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\rffunction.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\..\..\..\Library\CMSIS\Include -I..\..\..\..\..\..\Library\StdDriver\inc -I..\..\..\include -I..\..\..\porting -I..\..\..\include\rf_include -I..\..\..\porting\rf_porting -I..\..\FT_Demo -I..\FT_Func -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\rffunction.crf ..\..\..\source\rffunction.c]
                          THUMB

                          AREA ||i.checkBLE_CmdTimer||, CODE, READONLY, ALIGN=2

                  checkBLE_CmdTimer PROC
;;;96      ************************************************************************/
;;;97     void checkBLE_CmdTimer(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;98     {
000002  b08b              SUB      sp,sp,#0x2c
;;;99         uint8_t i, j;
;;;100    #ifndef _HCI_HW_
;;;101        extern void BleMHC_PostEvent(BleCmdEvent event, void *parms);
;;;102    #endif
;;;103    
;;;104        for(i=0; i<MAX_NUM_CONN_HDL; i++)
000004  2500              MOVS     r5,#0
                  |L1.6|
;;;105        {
;;;106            for(j=0; j<TOTAL_TIMER_EVENT; j++)
;;;107            {
;;;108                if(CmdTimer[i][j].Event != TIMER_EVENT_NULL)
000006  481e              LDR      r0,|L1.128|
000008  2124              MOVS     r1,#0x24
00000a  2700              MOVS     r7,#0                 ;106
00000c  4369              MULS     r1,r5,r1
00000e  180c              ADDS     r4,r1,r0
                  |L1.16|
000010  463e              MOV      r6,r7
000012  200c              MOVS     r0,#0xc
000014  4346              MULS     r6,r0,r6
000016  5da0              LDRB     r0,[r4,r6]
000018  28ff              CMP      r0,#0xff
00001a  d026              BEQ      |L1.106|
;;;109                {
;;;110                    if(((LLTimeline_Get() - CmdTimer[i][j].Current_T)&0x0FFFFFFF) > CmdTimer[i][j].TimeOut_Base)
00001c  f7fffffe          BL       LLTimeline_Get
000020  19a1              ADDS     r1,r4,r6
000022  684a              LDR      r2,[r1,#4]
000024  6889              LDR      r1,[r1,#8]
000026  1a80              SUBS     r0,r0,r2
000028  0100              LSLS     r0,r0,#4
00002a  0900              LSRS     r0,r0,#4
00002c  4288              CMP      r0,r1
00002e  d91c              BLS      |L1.106|
;;;111                    {
;;;112                        switch (CmdTimer[i][j].Event)
000030  5da0              LDRB     r0,[r4,r6]
000032  2800              CMP      r0,#0
000034  d004              BEQ      |L1.64|
000036  2801              CMP      r0,#1
000038  d008              BEQ      |L1.76|
00003a  2802              CMP      r0,#2
00003c  d115              BNE      |L1.106|
00003e  e00b              B        |L1.88|
                  |L1.64|
;;;113                        {
;;;114                        case TIMER_EVENT_CONN_PARAMETER_UPDATE_RSP:
;;;115                        {
;;;116    #ifndef _HCI_HW_
;;;117                            Uint16 L2cap_update_rsp;
;;;118                            L2cap_update_rsp = (Uint16)((i << 8) | CMD_TIMEOUT);
000040  0228              LSLS     r0,r5,#8
000042  4669              MOV      r1,sp
000044  1c80              ADDS     r0,r0,#2
000046  8008              STRH     r0,[r1,#0]
;;;119    
;;;120                            BleMHC_PostEvent(BLECMD_EVENT_CONN_PARAMETER_UPDATE_RSP,(void *)&L2cap_update_rsp);
000048  2005              MOVS     r0,#5
;;;121    #endif
;;;122                            CmdTimer[i][j].Event = TIMER_EVENT_NULL; //close CmdTimer
;;;123                        }
;;;124                        break;
00004a  e00a              B        |L1.98|
                  |L1.76|
;;;125    
;;;126                        case TIMER_EVENT_CONN_UPDATE_COMPLETE:
;;;127                        {
;;;128    #ifndef _HCI_HW_
;;;129                            struct MHC_Le_Conn_Update_Complete_Para event_param;
;;;130    
;;;131                            event_param.HCI_Conn_Hdl_L = i;
00004c  4669              MOV      r1,sp
00004e  70cd              STRB     r5,[r1,#3]
;;;132                            event_param.HCI_Status = CMD_TIMEOUT;  //Timeout Result
000050  2002              MOVS     r0,#2
000052  7088              STRB     r0,[r1,#2]
;;;133    
;;;134                            BleMHC_PostEvent(BLECMD_EVENT_CONN_UPDATE_COMPLETE,(void *)&event_param);
000054  2006              MOVS     r0,#6
;;;135    #endif
;;;136                            CmdTimer[i][j].Event = TIMER_EVENT_NULL; //close CmdTimer
;;;137                        }
;;;138                        break;
000056  e004              B        |L1.98|
                  |L1.88|
;;;139    
;;;140                        case TIMER_EVENT_AUTH_STATUS:
;;;141                        {
;;;142    #ifndef _HCI_HW_
;;;143                            struct MHC_Le_Auth_status_Para event_param;
;;;144                            event_param.HCI_Conn_Hdl_L = i;
000058  4669              MOV      r1,sp
00005a  700d              STRB     r5,[r1,#0]
;;;145                            event_param.HCI_AUTH_STATUS = AUTH_ERR_TIMEOUT;  //Timeout Result
00005c  200f              MOVS     r0,#0xf
00005e  7048              STRB     r0,[r1,#1]
;;;146    
;;;147                            BleMHC_PostEvent(BLECMD_EVENT_AUTH_STATUS,(void *)&event_param);
000060  200d              MOVS     r0,#0xd
                  |L1.98|
000062  f7fffffe          BL       BleMHC_PostEvent
;;;148    #endif
;;;149                            CmdTimer[i][j].Event = TIMER_EVENT_NULL; //close CmdTimer
000066  20ff              MOVS     r0,#0xff
000068  55a0              STRB     r0,[r4,r6]
                  |L1.106|
00006a  1c7f              ADDS     r7,r7,#1
00006c  b2ff              UXTB     r7,r7                 ;106
00006e  2f03              CMP      r7,#3                 ;106
000070  d3ce              BCC      |L1.16|
000072  1c6d              ADDS     r5,r5,#1              ;106
000074  b2ed              UXTB     r5,r5                 ;104
000076  2d05              CMP      r5,#5                 ;104
000078  d3c5              BCC      |L1.6|
;;;150                        }
;;;151                        break;
;;;152    
;;;153                        default:
;;;154                            break;
;;;155                        }
;;;156                    }
;;;157                }
;;;158            }
;;;159        }
;;;160    }
00007a  b00b              ADD      sp,sp,#0x2c
00007c  bdf0              POP      {r4-r7,pc}
;;;161    
                          ENDP

00007e  0000              DCW      0x0000
                  |L1.128|
                          DCD      ||.bss||+0x12c

                          AREA ||i.chkBLE_ATTRIBUTE_PERMISSION_Read||, CODE, READONLY, ALIGN=2

                  chkBLE_ATTRIBUTE_PERMISSION_Read PROC
;;;368     ************************************************************************/
;;;369    Uint8 chkBLE_ATTRIBUTE_PERMISSION_Read(Uint8 ATT_Handle)
000000  4913              LDR      r1,|L2.80|
;;;370    {
;;;371        Uint8 i, Rsp_Error;
;;;372    
;;;373        i = *(*(ATTRIBUTE_SERVER_PERMISSION+ATT_Handle)+TAB_ATTRIBUTE_SERVER_PERMISSION_R_W);
000002  0080              LSLS     r0,r0,#2
000004  5808              LDR      r0,[r1,r0]
;;;374        Rsp_Error = 0;
;;;375        if((i & (ATT_PERMISSION_READ|ATT_PERMISSION_ENC_READ|ATT_PERMISSION_AUTHE_READ|ATT_PERMISSION_AUTHO_READ)) == 0)
000006  2255              MOVS     r2,#0x55
000008  7801              LDRB     r1,[r0,#0]            ;373
00000a  2000              MOVS     r0,#0                 ;374
00000c  4211              TST      r1,r2
00000e  d101              BNE      |L2.20|
;;;376        {
;;;377            Rsp_Error = ERR_CODE_ATT_READ_NOT_PERMITTED;
000010  2002              MOVS     r0,#2
                  |L2.18|
;;;378        }
;;;379    #ifdef _SMP_ON_
;;;380        else
;;;381        {
;;;382            if((i & ATT_PERMISSION_AUTHO_READ) != 0)
;;;383            {
;;;384                if(smp_Authorization == 0)
;;;385                {
;;;386                    Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_AUTHORIZATION;
;;;387                    //break;
;;;388                }
;;;389            }
;;;390            if(Rsp_Error == 0)
;;;391            {
;;;392                if((i & ATT_PERMISSION_AUTHE_READ) != 0)
;;;393                {
;;;394                    if(smp_Security_Mode < SMP_SECURITY_MODE_MINIMUN)
;;;395                    {
;;;396                        Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_AUTHENTICATION;
;;;397                    }
;;;398                }
;;;399            }
;;;400            if(Rsp_Error == 0)
;;;401            {
;;;402                if((i & (ATT_PERMISSION_ENC_READ|ATT_PERMISSION_AUTHE_READ)) != 0)
;;;403                {
;;;404                    if(smp_Encryption == 0)
;;;405                        //if(smp_Phase == 0)
;;;406                    {
;;;407                        Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_ENCRYPTION;
;;;408                    }
;;;409                    else
;;;410                    {
;;;411                        //if(smp_PReq_Max_Encr_Key_Size < SIZE_MINIMUM_ENCRYPTION_KEY)
;;;412                        if(smp_Para_Bond[SMP_PREQ_MAX_ENCR_KEY_SIZE] < SIZE_MINIMUM_ENCRYPTION_KEY)
;;;413                        {
;;;414                            Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE;
;;;415                        }
;;;416                    }
;;;417                }
;;;418            }
;;;419        }
;;;420    #endif  //#ifdef _SMP_ON_
;;;421        return Rsp_Error;
;;;422    }
000012  4770              BX       lr
                  |L2.20|
000014  4a0f              LDR      r2,|L2.84|
000016  064b              LSLS     r3,r1,#25             ;382
000018  d502              BPL      |L2.32|
00001a  7813              LDRB     r3,[r2,#0]            ;384  ; smp_Authorization
00001c  2b00              CMP      r3,#0                 ;384
00001e  d010              BEQ      |L2.66|
                  |L2.32|
000020  06cb              LSLS     r3,r1,#27             ;392
000022  d502              BPL      |L2.42|
000024  7893              LDRB     r3,[r2,#2]            ;394  ; smp_Security_Mode
000026  2b00              CMP      r3,#0                 ;394
000028  d00d              BEQ      |L2.70|
                  |L2.42|
00002a  2314              MOVS     r3,#0x14              ;402
00002c  4219              TST      r1,r3                 ;402
00002e  d0f0              BEQ      |L2.18|
000030  7851              LDRB     r1,[r2,#1]            ;404  ; smp_Encryption
000032  2900              CMP      r1,#0                 ;404
000034  d009              BEQ      |L2.74|
000036  4908              LDR      r1,|L2.88|
000038  7c49              LDRB     r1,[r1,#0x11]         ;412  ; smp_Para_Bond
00003a  2910              CMP      r1,#0x10              ;412
00003c  d2e9              BCS      |L2.18|
00003e  200c              MOVS     r0,#0xc               ;414
000040  4770              BX       lr
                  |L2.66|
000042  2008              MOVS     r0,#8                 ;386
000044  4770              BX       lr
                  |L2.70|
000046  2005              MOVS     r0,#5                 ;396
000048  4770              BX       lr
                  |L2.74|
00004a  200f              MOVS     r0,#0xf               ;407
00004c  4770              BX       lr
;;;423    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      ATTRIBUTE_SERVER_PERMISSION
                  |L2.84|
                          DCD      ||area_number.47||
                  |L2.88|
                          DCD      ||.bss||+0x1f0

                          AREA ||i.chkBLE_ATTRIBUTE_PERMISSION_Write||, CODE, READONLY, ALIGN=2

                  chkBLE_ATTRIBUTE_PERMISSION_Write PROC
;;;430     ************************************************************************/
;;;431    Uint8 chkBLE_ATTRIBUTE_PERMISSION_Write(Uint8 ATT_Handle)
000000  4913              LDR      r1,|L3.80|
;;;432    {
;;;433        Uint8 i, Rsp_Error;
;;;434    
;;;435        i = *(*(ATTRIBUTE_SERVER_PERMISSION+ATT_Handle)+TAB_ATTRIBUTE_SERVER_PERMISSION_R_W);
000002  0080              LSLS     r0,r0,#2
000004  5808              LDR      r0,[r1,r0]
;;;436        Rsp_Error = 0;
;;;437        if((i & (ATT_PERMISSION_WRITE|ATT_PERMISSION_ENC_WRITE|ATT_PERMISSION_AUTHE_WRITE|ATT_PERMISSION_AUTHO_WRITE)) == 0)
000006  22aa              MOVS     r2,#0xaa
000008  7801              LDRB     r1,[r0,#0]            ;435
00000a  2000              MOVS     r0,#0                 ;436
00000c  4211              TST      r1,r2
00000e  d101              BNE      |L3.20|
;;;438        {
;;;439            Rsp_Error = ERR_CODE_ATT_WRITE_NOT_PERMITTED;
000010  2003              MOVS     r0,#3
                  |L3.18|
;;;440        }
;;;441    #ifdef _SMP_ON_
;;;442        else
;;;443        {
;;;444            if((i & ATT_PERMISSION_AUTHO_WRITE) != 0)
;;;445            {
;;;446                if(smp_Authorization == 0)
;;;447                {
;;;448                    Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_AUTHORIZATION;
;;;449                    //break;
;;;450                }
;;;451            }
;;;452            if(Rsp_Error == 0)
;;;453            {
;;;454                if((i & ATT_PERMISSION_AUTHE_WRITE) != 0)
;;;455                {
;;;456                    //if(smp_Authentication == 0)
;;;457                    if(smp_Security_Mode < SMP_SECURITY_MODE_MINIMUN)
;;;458                    {
;;;459                        Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_AUTHENTICATION;
;;;460                    }
;;;461                }
;;;462            }
;;;463            if(Rsp_Error == 0)
;;;464            {
;;;465                if((i & (ATT_PERMISSION_ENC_WRITE|ATT_PERMISSION_AUTHE_WRITE)) != 0)
;;;466                {
;;;467                    if(smp_Encryption == 0)
;;;468                        //if(smp_Phase == 0)
;;;469                    {
;;;470                        Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_ENCRYPTION;
;;;471                    }
;;;472                    else
;;;473                    {
;;;474                        //if(smp_PReq_Max_Encr_Key_Size < SIZE_MINIMUM_ENCRYPTION_KEY)
;;;475                        if(smp_Para_Bond[SMP_PREQ_MAX_ENCR_KEY_SIZE] < SIZE_MINIMUM_ENCRYPTION_KEY)
;;;476                        {
;;;477                            Rsp_Error = ERR_CODE_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE;
;;;478                        }
;;;479                    }
;;;480                }
;;;481            }
;;;482        }
;;;483    #endif  //#ifdef _SMP_ON_
;;;484        return Rsp_Error;
;;;485    }
000012  4770              BX       lr
                  |L3.20|
000014  4a0f              LDR      r2,|L3.84|
000016  060b              LSLS     r3,r1,#24             ;444
000018  d502              BPL      |L3.32|
00001a  7813              LDRB     r3,[r2,#0]            ;446  ; smp_Authorization
00001c  2b00              CMP      r3,#0                 ;446
00001e  d010              BEQ      |L3.66|
                  |L3.32|
000020  068b              LSLS     r3,r1,#26             ;454
000022  d502              BPL      |L3.42|
000024  7893              LDRB     r3,[r2,#2]            ;457  ; smp_Security_Mode
000026  2b00              CMP      r3,#0                 ;457
000028  d00d              BEQ      |L3.70|
                  |L3.42|
00002a  2328              MOVS     r3,#0x28              ;465
00002c  4219              TST      r1,r3                 ;465
00002e  d0f0              BEQ      |L3.18|
000030  7851              LDRB     r1,[r2,#1]            ;467  ; smp_Encryption
000032  2900              CMP      r1,#0                 ;467
000034  d009              BEQ      |L3.74|
000036  4908              LDR      r1,|L3.88|
000038  7c49              LDRB     r1,[r1,#0x11]         ;475  ; smp_Para_Bond
00003a  2910              CMP      r1,#0x10              ;475
00003c  d2e9              BCS      |L3.18|
00003e  200c              MOVS     r0,#0xc               ;477
000040  4770              BX       lr
                  |L3.66|
000042  2008              MOVS     r0,#8                 ;448
000044  4770              BX       lr
                  |L3.70|
000046  2005              MOVS     r0,#5                 ;459
000048  4770              BX       lr
                  |L3.74|
00004a  200f              MOVS     r0,#0xf               ;470
00004c  4770              BX       lr
;;;486    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      ATTRIBUTE_SERVER_PERMISSION
                  |L3.84|
                          DCD      ||area_number.47||
                  |L3.88|
                          DCD      ||.bss||+0x1f0

                          AREA ||i.chkBLE_ATT_Chr_AcssRd_ByUser||, CODE, READONLY, ALIGN=1

                  chkBLE_ATT_Chr_AcssRd_ByUser PROC
;;;554     ************************************************************************/
;;;555    Uint8 chkBLE_ATT_Chr_AcssRd_ByUser(Uint8 *AddrAttHandle)
000000  2000              MOVS     r0,#0
;;;556    {
;;;557        Uint8 Rsp_Error;
;;;558        //Uint8 *p;
;;;559    
;;;560        Rsp_Error = 0;
;;;561        return Rsp_Error;
;;;562    }
000002  4770              BX       lr
;;;563    
                          ENDP


                          AREA ||i.chkBLE_ATT_Chr_AcssWr_ByUser||, CODE, READONLY, ALIGN=1

                  chkBLE_ATT_Chr_AcssWr_ByUser PROC
;;;570     ************************************************************************/
;;;571    Uint8 chkBLE_ATT_Chr_AcssWr_ByUser(Uint8 *AddrAttHandle, Uint8 *wrDataBuf)
000000  2000              MOVS     r0,#0
;;;572    {
;;;573        Uint8 Rsp_Error;
;;;574        //Uint8 *p;
;;;575    
;;;576        Rsp_Error = 0;
;;;577    
;;;578        return Rsp_Error;
;;;579    }
000002  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.chkIfBLE_ATT_Chr_Acss_ByUser||, CODE, READONLY, ALIGN=2

                  chkIfBLE_ATT_Chr_Acss_ByUser PROC
;;;535     ************************************************************************/
;;;536    Uint8 chkIfBLE_ATT_Chr_Acss_ByUser(Uint8 AttHandle)
000000  4904              LDR      r1,|L6.20|
;;;537    {
;;;538        if((*(*(ATTRIBUTE_SERVER_PERMISSION+AttHandle)+TAB_ATTRIBUTE_SERVER_PERMISSION_ATT_TYPE_FORMAT) & ATT_TYPE_FORMAT_ATT_CHR_ACSS_USER) != 0)
000002  0080              LSLS     r0,r0,#2
000004  5808              LDR      r0,[r1,r0]
000006  7840              LDRB     r0,[r0,#1]
000008  0700              LSLS     r0,r0,#28
00000a  d501              BPL      |L6.16|
;;;539        {
;;;540            return YES_;
00000c  2001              MOVS     r0,#1
;;;541        }
;;;542        else
;;;543        {
;;;544            return NO_;
;;;545        }
;;;546    }
00000e  4770              BX       lr
                  |L6.16|
000010  2000              MOVS     r0,#0                 ;544
000012  4770              BX       lr
;;;547    
                          ENDP

                  |L6.20|
                          DCD      ATTRIBUTE_SERVER_PERMISSION

                          AREA ||i.clearBLE_CmdTimer||, CODE, READONLY, ALIGN=2

                  clearBLE_CmdTimer PROC
;;;167     ************************************************************************/
;;;168    void clearBLE_CmdTimer(uint8_t connID, CmdTimerEvent event)
000000  2224              MOVS     r2,#0x24
;;;169    {
;;;170        Uint8 i;
;;;171    
;;;172        if(event == TIMER_EVENT_NULL)
;;;173        {
;;;174            for(i=0; i<TOTAL_TIMER_EVENT; i++)
;;;175            {
;;;176                CmdTimer[connID][i].Event = TIMER_EVENT_NULL; //close
000002  4350              MULS     r0,r2,r0
000004  4a09              LDR      r2,|L7.44|
000006  23ff              MOVS     r3,#0xff              ;169
000008  1882              ADDS     r2,r0,r2
00000a  29ff              CMP      r1,#0xff              ;172
00000c  d005              BEQ      |L7.26|
;;;177            }
;;;178        }
;;;179        else if(event < TOTAL_TIMER_EVENT)
00000e  2903              CMP      r1,#3
000010  d202              BCS      |L7.24|
;;;180        {
;;;181            CmdTimer[connID][event].Event = TIMER_EVENT_NULL; //close
000012  200c              MOVS     r0,#0xc
000014  4341              MULS     r1,r0,r1
000016  5453              STRB     r3,[r2,r1]
                  |L7.24|
;;;182        }
;;;183    }
000018  4770              BX       lr
                  |L7.26|
00001a  2000              MOVS     r0,#0                 ;174
                  |L7.28|
00001c  210c              MOVS     r1,#0xc               ;176
00001e  4341              MULS     r1,r0,r1              ;176
000020  1c40              ADDS     r0,r0,#1              ;176
000022  b2c0              UXTB     r0,r0                 ;174
000024  5453              STRB     r3,[r2,r1]            ;176
000026  2803              CMP      r0,#3                 ;174
000028  d3f8              BCC      |L7.28|
00002a  4770              BX       lr
;;;184    
                          ENDP

                  |L7.44|
                          DCD      ||.bss||+0x12c

                          AREA ||i.getBLE_ATTRIBUTE_TYPE_Size||, CODE, READONLY, ALIGN=2

                  getBLE_ATTRIBUTE_TYPE_Size PROC
;;;493     ************************************************************************/
;;;494    Uint8 getBLE_ATTRIBUTE_TYPE_Size(Uint8 ATT_Handle)
000000  4905              LDR      r1,|L8.24|
;;;495    {
;;;496        Uint8 i;
;;;497    
;;;498        i = (*(*(ATTRIBUTE_SERVER_PERMISSION+ATT_Handle)+TAB_ATTRIBUTE_SERVER_PERMISSION_ATT_TYPE_FORMAT) & 0x03);
000002  0080              LSLS     r0,r0,#2
000004  5808              LDR      r0,[r1,r0]
000006  7840              LDRB     r0,[r0,#1]
000008  0780              LSLS     r0,r0,#30
00000a  0f80              LSRS     r0,r0,#30
;;;499        if(i == ATT_TYPE_FORMAT_16UUID)
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L8.20|
;;;500        {
;;;501            i = 2;
;;;502        }
;;;503        else
;;;504        {
;;;505            i = 16;
000010  2010              MOVS     r0,#0x10
;;;506        }
;;;507        return i;
;;;508    }
000012  4770              BX       lr
                  |L8.20|
000014  2002              MOVS     r0,#2                 ;501
000016  4770              BX       lr
;;;509    
                          ENDP

                  |L8.24|
                          DCD      ATTRIBUTE_SERVER_PERMISSION

                          AREA ||i.getBLE_ATTRIBUTE_Value_DynmcLngth||, CODE, READONLY, ALIGN=2

                  getBLE_ATTRIBUTE_Value_DynmcLngth PROC
;;;516     ************************************************************************/
;;;517    Uint8 getBLE_ATTRIBUTE_Value_DynmcLngth(Uint8 AttHandle, Uint8 SizeAtt)
000000  0082              LSLS     r2,r0,#2
;;;518    {
;;;519    
;;;520        if((*(*(ATTRIBUTE_SERVER_PERMISSION+AttHandle)+TAB_ATTRIBUTE_SERVER_PERMISSION_ATT_TYPE_FORMAT) & ATT_TYPE_FORMAT_DYN_LLENGTH) != 0)
000002  4805              LDR      r0,|L9.24|
000004  5880              LDR      r0,[r0,r2]
000006  7840              LDRB     r0,[r0,#1]
000008  0740              LSLS     r0,r0,#29
00000a  d502              BPL      |L9.18|
;;;521        {
;;;522            SizeAtt = ATTRIBUTE_SERVER_PARAM[AttHandle][SizeAtt];
00000c  4803              LDR      r0,|L9.28|
00000e  5880              LDR      r0,[r0,r2]
000010  5c41              LDRB     r1,[r0,r1]
                  |L9.18|
;;;523        }
;;;524        return (SizeAtt);
000012  4608              MOV      r0,r1
;;;525    }
000014  4770              BX       lr
;;;526    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      ATTRIBUTE_SERVER_PERMISSION
                  |L9.28|
                          DCD      ATTRIBUTE_SERVER_PARAM

                          AREA ||i.getBLE_CmdTimerEvent||, CODE, READONLY, ALIGN=2

                  getBLE_CmdTimerEvent PROC
;;;190     ************************************************************************/
;;;191    uint8_t getBLE_CmdTimerEvent(uint8_t connID, CmdTimerEvent event)
000000  2224              MOVS     r2,#0x24
;;;192    {
;;;193        return CmdTimer[connID][event].Event;
000002  4350              MULS     r0,r2,r0
000004  4a02              LDR      r2,|L10.16|
000006  1880              ADDS     r0,r0,r2
000008  220c              MOVS     r2,#0xc
00000a  4351              MULS     r1,r2,r1
00000c  5c40              LDRB     r0,[r0,r1]
;;;194    }
00000e  4770              BX       lr
;;;195    
                          ENDP

                  |L10.16|
                          DCD      ||.bss||+0x12c

                          AREA ||i.initBLE_AttServParamter||, CODE, READONLY, ALIGN=2

                  initBLE_AttServParamter PROC
;;;316     ************************************************************************/
;;;317    void initBLE_AttServParamter(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;318    {
;;;319        Uint8 i, j, prmt;
;;;320        Uint8 size, offset;
;;;321    //    Uint8 *pATT_param;
;;;322    
;;;323        i = (size_ATTRIBUTE_SERVER -1);
000002  481b              LDR      r0,|L11.112|
000004  7800              LDRB     r0,[r0,#0]  ; size_ATTRIBUTE_SERVER
000006  1e40              SUBS     r0,r0,#1
000008  b2c3              UXTB     r3,r0
00000a  e02d              B        |L11.104|
                  |L11.12|
;;;324        while(i!=0)
;;;325        {
;;;326            //*(*(ATTRIBUTE_SERVER_PARAM+i)) = 0xFF;
;;;327            //if(*(*(ATTRIBUTE_SERVER_PARAM+i)) != 0) //test if writable.
;;;328            {
;;;329                prmt = *(*(ATTRIBUTE_SERVER_PERMISSION+i)+1);
00000c  4919              LDR      r1,|L11.116|
00000e  0098              LSLS     r0,r3,#2
000010  5809              LDR      r1,[r1,r0]
000012  784d              LDRB     r5,[r1,#1]
;;;330                if((prmt & 0x03) == ATT_TYPE_FORMAT_16UUID)
000014  07a9              LSLS     r1,r5,#30
000016  0f89              LSRS     r1,r1,#30
000018  2901              CMP      r1,#1
;;;331                {
;;;332                    size = *(*(ATTRIBUTE_SERVER+i)+2+2);        //2: Handle, 2: 16bitUUID
;;;333                    offset = 3+2;
;;;334                }
;;;335                else
;;;336                {
;;;337                    size = *(*(ATTRIBUTE_SERVER+i)+16+2);       //2: Handle, 16: 128bitUUID
00001a  4917              LDR      r1,|L11.120|
00001c  5809              LDR      r1,[r1,r0]
00001e  d00a              BEQ      |L11.54|
000020  7c8c              LDRB     r4,[r1,#0x12]
;;;338                    offset = 3+16;
000022  2213              MOVS     r2,#0x13
                  |L11.36|
;;;339                }
;;;340                if((*(ATTRIBUTE_SERVER_PARAM+i)) != (*(ATTRIBUTE_SERVER+i)+(offset)))
000024  4e14              LDR      r6,|L11.120|
000026  4915              LDR      r1,|L11.124|
000028  5837              LDR      r7,[r6,r0]
00002a  5809              LDR      r1,[r1,r0]
00002c  18bf              ADDS     r7,r7,r2
00002e  42b9              CMP      r1,r7
000030  d018              BEQ      |L11.100|
;;;341                {
;;;342                    for(j=0; j<size; j++)
000032  2100              MOVS     r1,#0
000034  e00b              B        |L11.78|
                  |L11.54|
000036  790c              LDRB     r4,[r1,#4]            ;332
000038  2205              MOVS     r2,#5                 ;333
00003a  e7f3              B        |L11.36|
                  |L11.60|
;;;343                    {
;;;344                        //*(*(ATTRIBUTE_SERVER_PARAM+i)+j) = *(*(ATTRIBUTE_SERVER+i)+(offset+j));
;;;345                        *((Uint8 *)*(ATTRIBUTE_SERVER_PARAM+i)+j) = *(*(ATTRIBUTE_SERVER+i)+(offset+j));
00003c  4e0e              LDR      r6,|L11.120|
00003e  1857              ADDS     r7,r2,r1
000040  5836              LDR      r6,[r6,r0]
000042  5df7              LDRB     r7,[r6,r7]
000044  4e0d              LDR      r6,|L11.124|
000046  5836              LDR      r6,[r6,r0]
000048  5477              STRB     r7,[r6,r1]
00004a  1c49              ADDS     r1,r1,#1
00004c  b2c9              UXTB     r1,r1                 ;342
                  |L11.78|
00004e  42a1              CMP      r1,r4                 ;342
000050  d3f4              BCC      |L11.60|
;;;346                        //                pATT_param = (Uint8 *)(*ATTRIBUTE_SERVER_PARAM[i]);
;;;347                        //                *(pATT_param+j) = *(*(ATTRIBUTE_SERVER+i)+(offset+j));
;;;348                    }
;;;349                    if((prmt & ATT_TYPE_FORMAT_DYN_LLENGTH) == ATT_TYPE_FORMAT_DYN_LLENGTH)
000052  076c              LSLS     r4,r5,#29
000054  d506              BPL      |L11.100|
;;;350                    {
;;;351                        //*(*(ATTRIBUTE_SERVER_PARAM+i)+j) = *(*(ATTRIBUTE_SERVER+i)+(offset-1));
;;;352                        *((Uint8 *)*(ATTRIBUTE_SERVER_PARAM+i)+j) = *(*(ATTRIBUTE_SERVER+i)+(offset-1));
000056  4c08              LDR      r4,|L11.120|
000058  1e52              SUBS     r2,r2,#1
00005a  5824              LDR      r4,[r4,r0]
00005c  5ca4              LDRB     r4,[r4,r2]
00005e  4a07              LDR      r2,|L11.124|
000060  5810              LDR      r0,[r2,r0]
000062  5444              STRB     r4,[r0,r1]
                  |L11.100|
000064  1e5b              SUBS     r3,r3,#1
;;;353                        //                pATT_param = (Uint8 *)(*ATTRIBUTE_SERVER_PARAM[i]);
;;;354                        //                *(pATT_param+j) = *(*(ATTRIBUTE_SERVER+i)+(offset-1));
;;;355                    }
;;;356                }
;;;357                i--;
000066  b2db              UXTB     r3,r3
                  |L11.104|
000068  2b00              CMP      r3,#0                 ;324
00006a  d1cf              BNE      |L11.12|
;;;358            }
;;;359        }
;;;360    }
00006c  bdf0              POP      {r4-r7,pc}
;;;361    
                          ENDP

00006e  0000              DCW      0x0000
                  |L11.112|
                          DCD      size_ATTRIBUTE_SERVER
                  |L11.116|
                          DCD      ATTRIBUTE_SERVER_PERMISSION
                  |L11.120|
                          DCD      ATTRIBUTE_SERVER
                  |L11.124|
                          DCD      ATTRIBUTE_SERVER_PARAM

                          AREA ||i.init_q_att_HDL_PreWr||, CODE, READONLY, ALIGN=2

                  init_q_att_HDL_PreWr PROC
;;;295    
;;;296    void init_q_att_HDL_PreWr(void)
000000  2030              MOVS     r0,#0x30
;;;297    {
;;;298        Uint8 i;
;;;299    
;;;300        i = MAX_SIZE_ATT_VALUE_OVER_MTU_WR+3;
;;;301        while(i)
;;;302        {
;;;303            i--;
;;;304            q_att_HDL_PreWr[i] = 0;
000002  4a04              LDR      r2,|L12.20|
000004  2100              MOVS     r1,#0                 ;300
                  |L12.6|
000006  1e40              SUBS     r0,r0,#1
000008  0600              LSLS     r0,r0,#24             ;303
00000a  0e00              LSRS     r0,r0,#24             ;303
00000c  5411              STRB     r1,[r2,r0]
00000e  d1fa              BNE      |L12.6|
;;;305        }
;;;306    }
000010  4770              BX       lr
;;;307    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      ||.bss||+0xfb

                          AREA ||i.setBLE_CmdTimer||, CODE, READONLY, ALIGN=2

                  setBLE_CmdTimer PROC
;;;74      ************************************************************************/
;;;75     Uint8 setBLE_CmdTimer(Uint8 connID, CmdTimerEvent event, Uint32 timeout_base)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
000002  4616              MOV      r6,r2
;;;77         if(CmdTimer[connID][event].Event == TIMER_EVENT_NULL)
000004  2224              MOVS     r2,#0x24
000006  4350              MULS     r0,r2,r0
000008  4a08              LDR      r2,|L13.44|
00000a  460d              MOV      r5,r1
00000c  1884              ADDS     r4,r0,r2
00000e  200c              MOVS     r0,#0xc
000010  4345              MULS     r5,r0,r5
000012  5d60              LDRB     r0,[r4,r5]
000014  28ff              CMP      r0,#0xff
000016  d001              BEQ      |L13.28|
;;;78         {
;;;79             CmdTimer[connID][event].Event = event;
;;;80             CmdTimer[connID][event].Current_T = LLTimeline_Get();
;;;81             CmdTimer[connID][event].TimeOut_Base = timeout_base;
;;;82     
;;;83             return SUCCESS_;
;;;84         }
;;;85         else
;;;86         {
;;;87             return FAIL_;
000018  2001              MOVS     r0,#1
;;;88         }
;;;89     }
00001a  bd70              POP      {r4-r6,pc}
                  |L13.28|
00001c  5561              STRB     r1,[r4,r5]            ;79
00001e  f7fffffe          BL       LLTimeline_Get
000022  1961              ADDS     r1,r4,r5              ;80
000024  608e              STR      r6,[r1,#8]            ;83
000026  6048              STR      r0,[r1,#4]            ;83
000028  2000              MOVS     r0,#0                 ;83
00002a  bd70              POP      {r4-r6,pc}
;;;90     
                          ENDP

                  |L13.44|
                          DCD      ||.bss||+0x12c

                          AREA ||i.setBLE_ConnTxData||, CODE, READONLY, ALIGN=1

                  setBLE_ConnTxData PROC
;;;201     ************************************************************************/
;;;202    Uint8 setBLE_ConnTxData(Uint8 connID, Uint8 * ScanRspData, Uint8 Length)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204        //MBLK *mblk;
;;;205        extern Uint8 LL_Data2ConnTxFIFO(Uint8 connID, Uint8 *Data, Uint8 Length);
;;;206    
;;;207        if(LL_Data2ConnTxFIFO(connID, ScanRspData, Length)==FAIL_)
000002  f7fffffe          BL       LL_Data2ConnTxFIFO
000006  2801              CMP      r0,#1
000008  d000              BEQ      |L14.12|
;;;208        {
;;;209            return FAIL_;
;;;210        }
;;;211        else
;;;212        {
;;;213            return SUCCESS_;
00000a  2000              MOVS     r0,#0
                  |L14.12|
;;;214        }
;;;215    }
00000c  bd10              POP      {r4,pc}
;;;216    
                          ENDP


                          AREA ||i.setBLE_ConnTxData_ATT_ERROR_RESPONSE||, CODE, READONLY, ALIGN=1

                  setBLE_ConnTxData_ATT_ERROR_RESPONSE PROC
;;;271     ************************************************************************/
;;;272    Uint8 setBLE_ConnTxData_ATT_ERROR_RESPONSE(Uint8 connID, Uint8 Request_Opcode_In_Error, Uint8 ATT_handle_in_error_L, Uint8 ATT_handle_in_error_H, Uint8 Error_code)
000000  b5fe              PUSH     {r1-r7,lr}
;;;273    {
;;;274        Uint8 temp[9];
;;;275    
;;;276        temp[0] = SIZE_PDU_ATT_ERROR_RESPONSE;     //PDU Length
000002  2405              MOVS     r4,#5
000004  466f              MOV      r7,sp
000006  9e08              LDR      r6,[sp,#0x20]
000008  703c              STRB     r4,[r7,#0]
;;;277        temp[1] = 0x00;                            //PDU Length
00000a  2400              MOVS     r4,#0
00000c  707c              STRB     r4,[r7,#1]
;;;278        temp[2] = L2CAP_CID_ATTRIBUTE_PROTOCOL;    //Attribute Protocol
00000e  2504              MOVS     r5,#4
000010  70bd              STRB     r5,[r7,#2]
;;;279        temp[3] = 0x00;                            //Attribute Protocol
000012  70fc              STRB     r4,[r7,#3]
;;;280        temp[4] = OPCODE_ATT_ERROR_RESPONSE;       //Attribute Opcode: Error Response
000014  2401              MOVS     r4,#1
000016  713c              STRB     r4,[r7,#4]
;;;281        temp[5] = Request_Opcode_In_Error;
000018  7179              STRB     r1,[r7,#5]
;;;282        temp[6] = ATT_handle_in_error_L;
00001a  71ba              STRB     r2,[r7,#6]
;;;283        temp[7] = ATT_handle_in_error_H;
00001c  71fb              STRB     r3,[r7,#7]
;;;284        temp[8] = Error_code;
00001e  723e              STRB     r6,[r7,#8]
;;;285        if(setBLE_ConnTxData(connID, temp, (SIZE_BASIC_L2CAP_HEADER+SIZE_PDU_ATT_ERROR_RESPONSE)) == SUCCESS_)
000020  2209              MOVS     r2,#9
000022  4669              MOV      r1,sp
000024  f7fffffe          BL       setBLE_ConnTxData
000028  2800              CMP      r0,#0
00002a  d000              BEQ      |L15.46|
;;;286        {
;;;287            return SUCCESS_;
;;;288        }
;;;289        else
;;;290        {
;;;291            return FAIL_;
00002c  2001              MOVS     r0,#1
                  |L15.46|
;;;292        }
;;;293    }
00002e  bdfe              POP      {r1-r7,pc}
;;;294    
                          ENDP


                          AREA ||i.setBLE_ConnTxData_SMP||, CODE, READONLY, ALIGN=1

                  setBLE_ConnTxData_SMP PROC
;;;2273   
;;;2274   Uint8 setBLE_ConnTxData_SMP(Uint8 connID, Uint8 L2CAP_Code_SMP, Uint8 * L2CAP_RspDataSMP, Uint8 Length)
000000  b570              PUSH     {r4-r6,lr}
;;;2275   {
000002  461c              MOV      r4,r3
000004  b08e              SUB      sp,sp,#0x38
000006  4613              MOV      r3,r2
;;;2276       extern Uint8 LL_Data2ConnTxFIFO_smp(Uint8 connID, Uint8 *Data, Uint8 Length);
;;;2277       MBLK Mblk;
;;;2278   
;;;2279       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_PDU_LENGTH_L] = (Length+1);       //1byte code + 1byte reason
000008  1c62              ADDS     r2,r4,#1
00000a  466e              MOV      r6,sp
00000c  4605              MOV      r5,r0                 ;2275
00000e  72f2              STRB     r2,[r6,#0xb]
;;;2280       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_PDU_LENGTH_H] = 0x00;
000010  2000              MOVS     r0,#0
000012  7330              STRB     r0,[r6,#0xc]
;;;2281       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CID_L] = L2CAP_CID_SECURITY_MANAGER_PROTOCOL;
000014  2206              MOVS     r2,#6
000016  7372              STRB     r2,[r6,#0xd]
;;;2282       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CID_H] = 0x00;
000018  73b0              STRB     r0,[r6,#0xe]
;;;2283       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CODE_SMP] = L2CAP_Code_SMP;
00001a  73f1              STRB     r1,[r6,#0xf]
;;;2284   
;;;2285       //if(Length > 1) {
;;;2286       Knl_MemCpyInv(&Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CODE_SMP+1], L2CAP_RspDataSMP, Length);
00001c  4622              MOV      r2,r4
00001e  4619              MOV      r1,r3
000020  a804              ADD      r0,sp,#0x10
000022  f7fffffe          BL       Knl_MemCpyInv
000026  1d64              ADDS     r4,r4,#5
;;;2287   
;;;2288       if(LL_Data2ConnTxFIFO_smp(connID, Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data, (Length+SIZE_BASIC_L2CAP_HEADER+1))==FAIL_)
000028  a902              ADD      r1,sp,#8
00002a  b2e2              UXTB     r2,r4
00002c  4628              MOV      r0,r5
00002e  3103              ADDS     r1,#3
000030  f7fffffe          BL       LL_Data2ConnTxFIFO_smp
000034  2801              CMP      r0,#1
000036  d000              BEQ      |L16.58|
;;;2289       {
;;;2290           return FAIL_;
;;;2291       }
;;;2292       else
;;;2293       {
;;;2294           return SUCCESS_;
000038  2000              MOVS     r0,#0
                  |L16.58|
;;;2295       }
;;;2296   }
00003a  b00e              ADD      sp,sp,#0x38
00003c  bd70              POP      {r4-r6,pc}
;;;2297   
                          ENDP


                          AREA ||i.setBLE_ConnTxData_SMP_Isr||, CODE, READONLY, ALIGN=1

                  setBLE_ConnTxData_SMP_Isr PROC
;;;2299   #pragma Otime
;;;2300   Uint8 setBLE_ConnTxData_SMP_Isr(Uint8 connID, Uint8 L2CAP_Code_SMP, Uint8 * L2CAP_RspDataSMP, Uint8 Length)
000000  b570              PUSH     {r4-r6,lr}
;;;2301   {
000002  461c              MOV      r4,r3
000004  b08e              SUB      sp,sp,#0x38
000006  4613              MOV      r3,r2
000008  4605              MOV      r5,r0
;;;2302       extern Uint8 LL_Data2ConnTxFIFO_smp_Isr(Uint8 connID, Uint8 *Data, Uint8 Length);
;;;2303       MBLK Mblk;
;;;2304   
;;;2305       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_PDU_LENGTH_L] = (Length+1);       //1byte code + 1byte reason
00000a  1c62              ADDS     r2,r4,#1
00000c  4668              MOV      r0,sp
00000e  72c2              STRB     r2,[r0,#0xb]
;;;2306       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_PDU_LENGTH_H] = 0x00;
000010  2200              MOVS     r2,#0
000012  7302              STRB     r2,[r0,#0xc]
;;;2307       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CID_L] = L2CAP_CID_SECURITY_MANAGER_PROTOCOL;
000014  2606              MOVS     r6,#6
000016  7346              STRB     r6,[r0,#0xd]
;;;2308       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CID_H] = 0x00;
000018  7382              STRB     r2,[r0,#0xe]
;;;2309       Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CODE_SMP] = L2CAP_Code_SMP;
00001a  73c1              STRB     r1,[r0,#0xf]
;;;2310   
;;;2311       //if(Length > 1) {
;;;2312       Knl_MemCpyInv_Isr(&Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data[TAB_BASIC_L2CAP_CODE_SMP+1], L2CAP_RspDataSMP, Length);
00001c  4622              MOV      r2,r4
00001e  4619              MOV      r1,r3
000020  a804              ADD      r0,sp,#0x10
000022  f7fffffe          BL       Knl_MemCpyInv_Isr
000026  1d64              ADDS     r4,r4,#5
;;;2313   
;;;2314       if(LL_Data2ConnTxFIFO_smp_Isr(connID, Mblk.Para.HCLL_LE_ACL_Data_Pkt_Para.HCI_DataPkt_Data, (Length+SIZE_BASIC_L2CAP_HEADER+1))==FAIL_)
000028  a902              ADD      r1,sp,#8
00002a  b2e2              UXTB     r2,r4
00002c  4628              MOV      r0,r5
00002e  3103              ADDS     r1,#3
000030  f7fffffe          BL       LL_Data2ConnTxFIFO_smp_Isr
000034  2801              CMP      r0,#1
000036  d000              BEQ      |L17.58|
;;;2315       {
;;;2316           return FAIL_;
;;;2317       }
;;;2318       else
;;;2319       {
;;;2320           return SUCCESS_;
000038  2000              MOVS     r0,#0
                  |L17.58|
;;;2321       }
;;;2322   }
00003a  b00e              ADD      sp,sp,#0x38
00003c  bd70              POP      {r4-r6,pc}
;;;2323   #endif
                          ENDP


                          AREA ||i.smpC1||, CODE, READONLY, ALIGN=2

                  smpC1 PROC
;;;2176    ************************************************************************/
;;;2177   void smpC1(Uint8 * k, Uint8 * r, Uint8 * smpC1_out)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2178   {
000002  b085              SUB      sp,sp,#0x14
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
;;;2179       Uint8 i;
;;;2180       Uint8 p_AES[16];
;;;2181       //Uint8 temp_aes[16];
;;;2182       extern void smpAES_in_PlainText(Uint8 * plaintextData);
;;;2183       extern void smpAES_out(Uint8 * encDataOut);
;;;2184       extern const Uint8 TAB_ZERO_128[];
;;;2185   
;;;2186       smpAES_in_key(k);
000008  f7fffffe          BL       smpAES_in_key
;;;2187       Knl_CodeCpyInv_Isr(p_AES, &rsp_pairing_request_table[(TAB_BASIC_L2CAP_CID_H+1)], 7);
00000c  2207              MOVS     r2,#7
00000e  492a              LDR      r1,|L18.184|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       Knl_CodeCpyInv_Isr
;;;2188       p_AES[7] = smp_PReq_Resp_Key_Distr;
000016  4829              LDR      r0,|L18.188|
000018  466a              MOV      r2,sp
00001a  7981              LDRB     r1,[r0,#6]  ; smp_PReq_Resp_Key_Distr
00001c  71d1              STRB     r1,[r2,#7]
;;;2189       p_AES[8] = smp_PReq_Init_Key_Distr;
;;;2190       p_AES[9] = smp_Para_Bond[SMP_PREQ_MAX_ENCR_KEY_SIZE];
00001e  4f26              LDR      r7,|L18.184|
000020  7941              LDRB     r1,[r0,#5]            ;2189  ; smp_PReq_Init_Key_Distr
000022  7211              STRB     r1,[r2,#8]            ;2189
000024  3f29              SUBS     r7,r7,#0x29
000026  7c79              LDRB     r1,[r7,#0x11]  ; smp_Para_Bond
000028  7251              STRB     r1,[r2,#9]
;;;2191       p_AES[10] = smp_Para_Bond[SMP_PREQ_AUTHREQ];
00002a  4639              MOV      r1,r7
00002c  3120              ADDS     r1,r1,#0x20
00002e  7909              LDRB     r1,[r1,#4]  ; smp_Para_Bond
000030  7291              STRB     r1,[r2,#0xa]
;;;2192       p_AES[11] = smp_PReq_OOB_data;
000032  7901              LDRB     r1,[r0,#4]  ; smp_PReq_OOB_data
000034  72d1              STRB     r1,[r2,#0xb]
;;;2193       p_AES[12] = smp_PReq_IO_Capab;
000036  78c0              LDRB     r0,[r0,#3]  ; smp_PReq_IO_Capab
000038  7310              STRB     r0,[r2,#0xc]
;;;2194       p_AES[13] = CODE_SMP_PAIRING_REQUEST;
00003a  2001              MOVS     r0,#1
00003c  7350              STRB     r0,[r2,#0xd]
;;;2195   
;;;2196       p_AES[14] = smp_Local_Addr[MAX_NUM_CONN_MAS_HDL][0];    //PUBLIC_ADDR or RANDOM_ADDR, 0x00 or 0x01
00003e  4638              MOV      r0,r7
000040  3050              ADDS     r0,r0,#0x50
000042  7800              LDRB     r0,[r0,#0]  ; smp_Local_Addr
000044  7390              STRB     r0,[r2,#0xe]
;;;2197       p_AES[15] = smp_Para_Bond[SMP_INI_ADDR_TYPE];   //HCI_ADDR_TYPE_PUBLIC or HCI_ADDR_TYPE_RANDOM, 0x00 or 0x01
000046  7838              LDRB     r0,[r7,#0]  ; smp_Para_Bond
000048  73d0              STRB     r0,[r2,#0xf]
;;;2198   
;;;2199       for(i=0; i <16; i++)
00004a  2000              MOVS     r0,#0
00004c  4614              MOV      r4,r2                 ;2180
                  |L18.78|
;;;2200       {
;;;2201           p_AES[i] = r[i] ^ p_AES[i];             //p_AES: P1
00004e  5c31              LDRB     r1,[r6,r0]
000050  5c22              LDRB     r2,[r4,r0]
000052  4051              EORS     r1,r1,r2
000054  5421              STRB     r1,[r4,r0]
000056  1c40              ADDS     r0,r0,#1
000058  b2c0              UXTB     r0,r0                 ;2199
00005a  2810              CMP      r0,#0x10              ;2199
00005c  d3f7              BCC      |L18.78|
;;;2202       }
;;;2203       smpAES_in_PlainText(p_AES);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       smpAES_in_PlainText
;;;2204       smpAES_En();
000064  f7fffffe          BL       smpAES_En
;;;2205   
;;;2206       Knl_CodeCpy_Isr(p_AES, TAB_ZERO_128, 4);
000068  2204              MOVS     r2,#4
00006a  4915              LDR      r1,|L18.192|
00006c  4668              MOV      r0,sp
00006e  f7fffffe          BL       Knl_CodeCpy_Isr
;;;2207       Knl_MemCpyInv_Isr(&p_AES[4], &smp_Para_Bond[SMP_INI_ADDR], 6);
000072  2206              MOVS     r2,#6
000074  1c79              ADDS     r1,r7,#1
000076  1d20              ADDS     r0,r4,#4
000078  f7fffffe          BL       Knl_MemCpyInv_Isr
;;;2208       Knl_MemCpyInv_Isr(&p_AES[10], &smp_Local_Addr[MAX_NUM_CONN_MAS_HDL][2], 6);
00007c  490e              LDR      r1,|L18.184|
00007e  a802              ADD      r0,sp,#8
000080  2206              MOVS     r2,#6
000082  3129              ADDS     r1,r1,#0x29
000084  3002              ADDS     r0,#2
000086  f7fffffe          BL       Knl_MemCpyInv_Isr
;;;2209       smpAES_out(smpC1_out);
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       smpAES_out
;;;2210       for(i=0; i <16; i++)
000090  2000              MOVS     r0,#0
                  |L18.146|
;;;2211       {
;;;2212           p_AES[i] = smpC1_out[i] ^ p_AES[i];     //p_AES: P2
000092  5c29              LDRB     r1,[r5,r0]
000094  5c22              LDRB     r2,[r4,r0]
000096  4051              EORS     r1,r1,r2
000098  5421              STRB     r1,[r4,r0]
00009a  1c40              ADDS     r0,r0,#1
00009c  b2c0              UXTB     r0,r0                 ;2210
00009e  2810              CMP      r0,#0x10              ;2210
0000a0  d3f7              BCC      |L18.146|
;;;2213       }
;;;2214       smpAES_in_PlainText(p_AES);
0000a2  4668              MOV      r0,sp
0000a4  f7fffffe          BL       smpAES_in_PlainText
;;;2215       smpAES_En();
0000a8  f7fffffe          BL       smpAES_En
;;;2216       smpAES_out(smpC1_out);
0000ac  4628              MOV      r0,r5
0000ae  f7fffffe          BL       smpAES_out
;;;2217   }
0000b2  b005              ADD      sp,sp,#0x14
0000b4  bdf0              POP      {r4-r7,pc}
;;;2218   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L18.184|
                          DCD      ||.bss||+0x219
                  |L18.188|
                          DCD      ||area_number.47||
                  |L18.192|
                          DCD      TAB_ZERO_128

                          AREA ||i.smpPasskey_init||, CODE, READONLY, ALIGN=2

                  smpPasskey_init PROC
;;;2241   
;;;2242   void smpPasskey_init(void)
000000  2000              MOVS     r0,#0
;;;2243   {
;;;2244       Uint8 i;
;;;2245   
;;;2246       for(i=0; i<16; i++)
;;;2247       {
;;;2248           k_AES_passkey[i] = 0;
000002  4a04              LDR      r2,|L19.20|
000004  4601              MOV      r1,r0                 ;2246
                  |L19.6|
000006  5411              STRB     r1,[r2,r0]
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0                 ;2246
00000c  2810              CMP      r0,#0x10              ;2246
00000e  d3fa              BCC      |L19.6|
;;;2249       }
;;;2250   }
000010  4770              BX       lr
;;;2251   
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      ||.bss||+0x1e0

                          AREA ||i.smpPasskey_set||, CODE, READONLY, ALIGN=2

                  smpPasskey_set PROC
;;;2252   
;;;2253   Uint8 smpPasskey_set(Uint32 hexPasskey, Uint8 connID)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;2254   {
000002  460c              MOV      r4,r1
;;;2255       Knl_MemCpyInv(&k_AES_passkey[12], (Uint8 *)&hexPasskey, 4);
000004  2204              MOVS     r2,#4
000006  4669              MOV      r1,sp
000008  4806              LDR      r0,|L20.36|
00000a  f7fffffe          BL       Knl_MemCpyInv
;;;2256       if(PassEC_BLE_CODE_SMP(connID, SMEC_LE_CODE_SMP_PAIRING_CONFIRM, SPIBuffer, 1) == SUCCESS_) //SPIBuffer dont care.
00000e  2301              MOVS     r3,#1
000010  4a05              LDR      r2,|L20.40|
000012  2156              MOVS     r1,#0x56
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       PassEC_BLE_CODE_SMP
00001a  2800              CMP      r0,#0
00001c  d000              BEQ      |L20.32|
;;;2257       {
;;;2258           return SUCCESS_;
;;;2259       }
;;;2260       else
;;;2261       {
;;;2262           return FAIL_;
00001e  2001              MOVS     r0,#1
                  |L20.32|
;;;2263       }
;;;2264   }
000020  bd1c              POP      {r2-r4,pc}
;;;2265   
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      ||.bss||+0x1ec
                  |L20.40|
                          DCD      ||.bss||

                          AREA ||i.smpS1||, CODE, READONLY, ALIGN=1

                  smpS1 PROC
;;;2227    ************************************************************************/
;;;2228   void smpS1(Uint8 * k, Uint8 * r1, Uint8 * r2, Uint8 * smpS1_out)
000000  b57f              PUSH     {r0-r6,lr}
;;;2229   {
000002  4615              MOV      r5,r2
000004  461c              MOV      r4,r3
;;;2230       Uint8 temp_aes[16];
;;;2231       extern void smpAES_in_PlainText(Uint8 * plaintextData);
;;;2232       extern void smpAES_out(Uint8 * encDataOut);
;;;2233   
;;;2234       Knl_MemCpy_Isr(temp_aes, &r1[8], 8);
000006  2208              MOVS     r2,#8
000008  4668              MOV      r0,sp
00000a  3108              ADDS     r1,r1,#8
00000c  f7fffffe          BL       Knl_MemCpy_Isr
;;;2235       Knl_MemCpy_Isr(&temp_aes[8], &r2[8], 8);
000010  2208              MOVS     r2,#8
000012  18a9              ADDS     r1,r5,r2
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       Knl_MemCpy_Isr
;;;2236       smpAES_in_PlainText(temp_aes);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       smpAES_in_PlainText
;;;2237       smpAES_En();
000020  f7fffffe          BL       smpAES_En
;;;2238       smpAES_out(smpS1_out);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       smpAES_out
;;;2239   }
00002a  bd7f              POP      {r0-r6,pc}
;;;2240   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  SPIBuffer
                          %        251
                  q_att_HDL_PreWr
                          %        49
                  CmdTimer
                          %        180
                  k_AES_passkey
                          %        16
                  smp_Para_Bond
                          %        37
                  rsp_pairing_request_table
                          %        11
                  smp_Local_Addr
                          %        40

                          AREA ||area_number.24||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.bss||
                  smp_Temp16
                          %        16

                          AREA ||area_number.25||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.bss||
                  smp_IRKm
                          %        16

                          AREA ||area_number.26||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.bss||
                  smp_CSRKm
                          %        16

                          AREA ||area_number.27||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.bss||
                  r_AES
                          %        16

                          AREA ||area_number.28||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.bss||
                  LTK
                          %        16

                          AREA ||area_number.29||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.29||, ||.bss||
                  LTK_SEED
                          %        10

                          AREA ||area_number.30||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.30||, ||.bss||
                  smp_Para_Bond_tmp
                          %        70

                          AREA ||area_number.31||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.31||, ||.bss||
                  SECBuffer
                          %        42

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  UUID_BLUETOOTH_BASE
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  00001000          DCB      0x00,0x00,0x10,0x00
000008  80000080          DCB      0x80,0x00,0x00,0x80
00000c  5f9b34fb          DCB      0x5f,0x9b,0x34,0xfb

                          AREA ||area_number.34||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.34||, ||.constdata||
                  k_AES
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||area_number.35||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.35||, ||.constdata||
                  r_AES_INI
000000  64e8b677          DCB      0x64,0xe8,0xb6,0x77
000004  1b498323          DCB      0x1b,0x49,0x83,0x23
000008  07004ff6          DCB      0x07,0x00,0x4f,0xf6
00000c  c9162e1d          DCB      0xc9,0x16,0x2e,0x1d

                          AREA ||area_number.36||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.36||, ||.constdata||
                  RSP_PAIRING_REQUEST
000000  07000600          DCB      0x07,0x00,0x06,0x00
000004  02000005          DCB      0x02,0x00,0x00,0x05
000008  100101            DCB      0x10,0x01,0x01

                          AREA ||area_number.37||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.37||, ||.constdata||
                  SKDS_FIXED
000000  02132435          DCB      0x02,0x13,0x24,0x35
000004  46576879          DCB      0x46,0x57,0x68,0x79

                          AREA ||area_number.38||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.38||, ||.constdata||
                  IVS_FIXED
000000  deafbabe          DCB      0xde,0xaf,0xba,0xbe

                          AREA ||area_number.39||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.39||, ||.constdata||
                  LTK_FIXED
000000  e2485a7a          DCB      0xe2,0x48,0x5a,0x7a
000004  d8d97c22          DCB      0xd8,0xd9,0x7c,0x22
000008  3057fa42          DCB      0x30,0x57,0xfa,0x42
00000c  db598b25          DCB      0xdb,0x59,0x8b,0x25

                          AREA ||area_number.40||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.40||, ||.constdata||
                  EDIV_FIXED
000000  6775              DCB      0x67,0x75

                          AREA ||area_number.41||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.41||, ||.constdata||
                  RAND_FIXED
000000  47304af6          DCB      0x47,0x30,0x4a,0xf6
000004  d91a28dd          DCB      0xd9,0x1a,0x28,0xdd

                          AREA ||area_number.42||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.constdata||
                  IRK_FIXED
000000  b5b7e148          DCB      0xb5,0xb7,0xe1,0x48
000004  ac7e3b91          DCB      0xac,0x7e,0x3b,0x91
000008  8aa6d71c          DCB      0x8a,0xa6,0xd7,0x1c
00000c  4533e50b          DCB      0x45,0x33,0xe5,0x0b

                          AREA ||area_number.43||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.constdata||
                  CSRK_FIXED
000000  e58be88d          DCB      0xe5,0x8b,0xe8,0x8d
000004  786175a7          DCB      0x78,0x61,0x75,0xa7
000008  e34b0180          DCB      0xe3,0x4b,0x01,0x80
00000c  a0fbf982          DCB      0xa0,0xfb,0xf9,0x82

                          AREA ||area_number.44||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.44||, ||.constdata||
                  SEL_STK_GEN_MTHD
000000  00000200          DCB      0x00,0x00,0x02,0x00
000004  02000002          DCB      0x02,0x00,0x00,0x02
000008  00020101          DCB      0x00,0x02,0x01,0x01
00000c  01000100          DCB      0x01,0x00,0x01,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  01010200          DCB      0x01,0x01,0x02,0x00
000018  01                DCB      0x01

                          AREA ||.data||, DATA, ALIGN=0

                  aTT_MTU
                          DCDU     0x00000000
000004  00                DCB      0x00

                          AREA ||area_number.46||, DATA, ALIGN=0

                          EXPORTAS ||area_number.46||, ||.data||
                  L2cap_Identifier
000000  00                DCB      0x00

                          AREA ||area_number.47||, DATA, ALIGN=0

                          EXPORTAS ||area_number.47||, ||.data||
                  smp_Authorization
000000  00                DCB      0x00
                  smp_Encryption
000001  00                DCB      0x00
                  smp_Security_Mode
000002  00                DCB      0x00
                  smp_PReq_IO_Capab
000003  00                DCB      0x00
                  smp_PReq_OOB_data
000004  00                DCB      0x00
                  smp_PReq_Init_Key_Distr
000005  00                DCB      0x00
                  smp_PReq_Resp_Key_Distr
000006  00                DCB      0x00

                          AREA ||area_number.48||, DATA, ALIGN=0

                          EXPORTAS ||area_number.48||, ||.data||
                  smp_Phase
000000  00                DCB      0x00

                          AREA ||area_number.49||, DATA, ALIGN=0

                          EXPORTAS ||area_number.49||, ||.data||
                  smp_TempDef
000000  00                DCB      0x00

                          AREA ||area_number.50||, DATA, ALIGN=0

                          EXPORTAS ||area_number.50||, ||.data||
                  smp_Rand
                          %        8

                          AREA ||area_number.51||, DATA, ALIGN=0

                          EXPORTAS ||area_number.51||, ||.data||
                  smp_EDIV
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.52||, DATA, ALIGN=0

                          EXPORTAS ||area_number.52||, ||.data||
                  smp_SKDm
                          %        8

                          AREA ||area_number.53||, DATA, ALIGN=0

                          EXPORTAS ||area_number.53||, ||.data||
                  smp_IVm
                          DCDU     0x00000000

                          AREA ||area_number.54||, DATA, ALIGN=0

                          EXPORTAS ||area_number.54||, ||.data||
                  smp_Local_Addr_advTemp
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\rffunction.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rffunction_c_4a4bcafd____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rffunction_c_4a4bcafd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rffunction_c_4a4bcafd____REVSH|
#line 402
|__asm___12_rffunction_c_4a4bcafd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
