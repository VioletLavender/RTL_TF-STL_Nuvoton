; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\rf_phy.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\rf_phy.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\..\..\..\Library\CMSIS\Include -I..\..\..\..\..\..\Library\StdDriver\inc -I..\..\..\include -I..\..\..\porting -I..\..\..\include\rf_include -I..\..\..\porting\rf_porting -I..\..\FT_Demo -I..\FT_Func -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 --omf_browse=.\obj\rf_phy.crf ..\..\..\source\rf_phy.c]
                          THUMB

                          AREA ||i.BleRFMode_Get||, CODE, READONLY, ALIGN=2

                  BleRFMode_Get PROC
;;;1923   
;;;1924   BleRF_Mode BleRFMode_Get(void)
000000  4801              LDR      r0,|L1.8|
;;;1925   {
;;;1926       return gSleep;
000002  7800              LDRB     r0,[r0,#0]  ; gSleep
;;;1927   }
000004  4770              BX       lr
;;;1928   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      gSleep

                          AREA ||i.BleTxFIFOAddr_Get||, CODE, READONLY, ALIGN=2

                  BleTxFIFOAddr_Get PROC
;;;1917   
;;;1918   uint32_t BleTxFIFOAddr_Get(void)
000000  4801              LDR      r0,|L2.8|
;;;1919   {
;;;1920       return addr_TxFIFO;
000002  6800              LDR      r0,[r0,#0]  ; addr_TxFIFO
;;;1921   }
000004  4770              BX       lr
;;;1922   
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      addr_TxFIFO

                          AREA ||i.Ble_SW_Init||, CODE, READONLY, ALIGN=2

                  Ble_SW_Init PROC
;;;726    
;;;727    void Ble_SW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;728    {
;;;729        Uint8 i;
;;;730        extern void initHCI(void);
;;;731        extern void initLL(void);
;;;732        extern void initL2CAP(void);
;;;733        extern void initInt(void);
;;;734        extern void KernelInit(void);
;;;735    //    extern void MMI_Init(void);
;;;736        extern void initBLEsw(void);
;;;737        extern void clearBLE_CmdTimer(uint8_t connID, BleCmdEvent event);
;;;738    
;;;739    #ifdef _SMP_ON_
;;;740    #ifdef _BOND_ON_
;;;741        extern uint8_t* cmd_FlashBond(uint8_t opcode, uint8_t * para_data);
;;;742        uint8_t *tmp;
;;;743    #endif
;;;744    #endif
;;;745    
;;;746        InterruptDisable();
000002  b672              CPSID    i
;;;747    #ifdef _HCI_NEW_
;;;748        initHCI();
000004  f7fffffe          BL       initHCI
;;;749    #endif
;;;750    //    MMI_Init();
;;;751        initBLEsw();
000008  f7fffffe          BL       initBLEsw
;;;752    
;;;753        initInt();
00000c  f7fffffe          BL       initInt
;;;754    
;;;755        RF_Tmr_Periodic_initial(DUR_LL_WAKEUP_MIN, RF_SLEEP_DISABLE);
000010  2100              MOVS     r1,#0
000012  2019              MOVS     r0,#0x19
000014  0180              LSLS     r0,r0,#6
000016  f7fffffe          BL       RF_Tmr_Periodic_initial
;;;756    
;;;757        KernelInit();
00001a  f7fffffe          BL       KernelInit
;;;758    
;;;759        initLL();
00001e  f7fffffe          BL       initLL
;;;760        initL2CAP();
000022  f7fffffe          BL       initL2CAP
;;;761        //enable RT568 timer wakeup INT
;;;762        RF_Header_Rdy_intOn();
000026  f7fffffe          BL       RF_Header_Rdy_intOn
;;;763        RF_WTR_intOn();
00002a  f7fffffe          BL       RF_WTR_intOn
;;;764    
;;;765        InterruptEnable();
00002e  b662              CPSIE    i
;;;766    #ifdef _SMP_ON_
;;;767    #ifdef _BOND_ON_
;;;768        tmp = cmd_FlashBond(CMD_FB_CHK_IF_FLASH_INITED, (uint8_t*)smp_Para_Bond_tmp);
000030  490d              LDR      r1,|L3.104|
000032  2004              MOVS     r0,#4
000034  f7fffffe          BL       cmd_FlashBond
;;;769        if(*(tmp+0) == FLH_BND_ERR_CODE_FLASH_NOT_INI)
000038  7800              LDRB     r0,[r0,#0]
00003a  2801              CMP      r0,#1
;;;770        {
;;;771            tmp = cmd_FlashBond(CMD_FB_INIT_INFO_FLASHBOND, (uint8_t*)smp_Para_Bond_tmp);
;;;772            tmp = cmd_FlashBond(CMD_FB_INIT_DATA_FLASHBOND, (uint8_t*)smp_Para_Bond_tmp);
;;;773        }
;;;774        else
;;;775        {
;;;776            cmd_FlashBond(CMD_FB_CHK_IF_FLASHBOND_NEED_TO_ERASE_PAGE, (uint8_t*)smp_Para_Bond_tmp);
00003c  490a              LDR      r1,|L3.104|
00003e  d00c              BEQ      |L3.90|
000040  200a              MOVS     r0,#0xa
                  |L3.66|
000042  f7fffffe          BL       cmd_FlashBond
;;;777        }
;;;778    #endif
;;;779    #endif
;;;780        for(i=0; i<MAX_NUM_CONN_HDL; i++)
000046  2400              MOVS     r4,#0
                  |L3.72|
;;;781        {
;;;782            clearBLE_CmdTimer(i, TIMER_EVENT_NULL);
000048  21ff              MOVS     r1,#0xff
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       clearBLE_CmdTimer
000050  1c64              ADDS     r4,r4,#1
000052  b2e4              UXTB     r4,r4                 ;780
000054  2c05              CMP      r4,#5                 ;780
000056  d3f7              BCC      |L3.72|
;;;783        }
;;;784    }
000058  bd10              POP      {r4,pc}
                  |L3.90|
00005a  2002              MOVS     r0,#2                 ;771
00005c  f7fffffe          BL       cmd_FlashBond
000060  4901              LDR      r1,|L3.104|
000062  2003              MOVS     r0,#3                 ;772
000064  e7ed              B        |L3.66|
;;;785    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      smp_Para_Bond_tmp

                          AREA ||i.ChipId_Get||, CODE, READONLY, ALIGN=2

                  ChipId_Get PROC
;;;1911   
;;;1912   uint8_t ChipId_Get(void)
000000  4801              LDR      r0,|L4.8|
;;;1913   {
;;;1914       return ble_device_param.ble_deviceChipId;
000002  7800              LDRB     r0,[r0,#0]  ; ble_device_param
;;;1915   }
000004  4770              BX       lr
;;;1916   
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ble_device_param

                          AREA ||i.LLTimeline_Get||, CODE, READONLY, ALIGN=2

                  LLTimeline_Get PROC
;;;1899   
;;;1900   uint32_t LLTimeline_Get(void)
000000  4801              LDR      r0,|L5.8|
;;;1901   {
;;;1902       return Timeline24;      //BLE LL timer
000002  6800              LDR      r0,[r0,#0]  ; Timeline24
;;;1903   }
000004  4770              BX       lr
;;;1904   
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      Timeline24

                          AREA ||i.RF_CCM_AES_Key_set||, CODE, READONLY, ALIGN=1

                  RF_CCM_AES_Key_set PROC
;;;1358   
;;;1359   void RF_CCM_AES_Key_set(uint8_t *addrAesKey)
000000  b510              PUSH     {r4,lr}
;;;1360   {
;;;1361       SPI_PDMA_SetTx(RFIP_REG_139, (uint32_t)addrAesKey, LEN_AES_KEY);
000002  2210              MOVS     r2,#0x10
000004  4601              MOV      r1,r0
000006  208b              MOVS     r0,#0x8b
000008  f7fffffe          BL       SPI_PDMA_SetTx
;;;1362   }
00000c  bd10              POP      {r4,pc}
;;;1363   
                          ENDP


                          AREA ||i.RF_CCM_AES_Mode_set||, CODE, READONLY, ALIGN=2

                  RF_CCM_AES_Mode_set PROC
;;;1343   
;;;1344   void RF_CCM_AES_Mode_set(uint8_t setting)
000000  b508              PUSH     {r3,lr}
;;;1345   {
;;;1346       uint8_t LL_SMP_DATACH_CONV[] =
000002  a105              ADR      r1,|L7.24|
000004  6809              LDR      r1,[r1,#0]
;;;1347       {
;;;1348           REG_155_AES_MODE_BYPASS,
;;;1349           REG_155_AES_MODE_CCM_TX_ENCRY,
;;;1350           REG_155_AES_MODE_CCM_RX_DECRY,
;;;1351           REG_155_AES_MODE_CCM_ENABLE,
;;;1352       };
;;;1353       //Ref. LL_SMP_DATA_CH_R_T_NORMAL, LL_SMP_DATA_CH_T_CCM, LL_SMP_DATA_CH_R_CCM & LL_SMP_DATA_CH_R_T_CCM
;;;1354   
;;;1355       SPI_1BYT_SetTx_Isr(RFIP_REG_155, LL_SMP_DATACH_CONV[(setting&REG_155_AES_MODE)]);
000006  0740              LSLS     r0,r0,#29
000008  0f40              LSRS     r0,r0,#29
00000a  9100              STR      r1,[sp,#0]
00000c  4669              MOV      r1,sp
00000e  5c09              LDRB     r1,[r1,r0]
000010  209b              MOVS     r0,#0x9b
000012  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1356   }
000016  bd08              POP      {r3,pc}
;;;1357   
                          ENDP

                  |L7.24|
000018  00                DCB      0
000019  020301            DCB      2,3,1

                          AREA ||i.RF_CRCInit||, CODE, READONLY, ALIGN=1

                  RF_CRCInit PROC
;;;1208   
;;;1209   void RF_CRCInit(uint8_t *initParaAddr)       //LL__019
000000  b510              PUSH     {r4,lr}
;;;1210   {
;;;1211       SPI_PDMA_SetTx(RFIP_REG_112, (uint32_t)(initParaAddr), LEN_CRC_INIT);
000002  2203              MOVS     r2,#3
000004  4601              MOV      r1,r0
000006  2070              MOVS     r0,#0x70
000008  f7fffffe          BL       SPI_PDMA_SetTx
;;;1212   }
00000c  bd10              POP      {r4,pc}
;;;1213   
                          ENDP


                          AREA ||i.RF_CRCchk||, CODE, READONLY, ALIGN=1

                  RF_CRCchk PROC
;;;1012   
;;;1013   uint8_t RF_CRCchk(void)     //use FALSE to judgement
000000  b510              PUSH     {r4,lr}
;;;1014   {
;;;1015       uint8_t result;
;;;1016   
;;;1017       if(SPI_1BYT_SetRx_Isr(RFIP_REG_107)&REG_107_CRC_OK)
000002  206b              MOVS     r0,#0x6b
000004  f7fffffe          BL       SPI_1BYT_SetRx_Isr
000008  0740              LSLS     r0,r0,#29
00000a  d501              BPL      |L9.16|
;;;1018       {
;;;1019           result = TRUE;
00000c  2001              MOVS     r0,#1
;;;1020       }
;;;1021       else          //0: CRC fail
;;;1022       {
;;;1023           result = FALSE;
;;;1024       }
;;;1025   
;;;1026       return (result);
;;;1027   }
00000e  bd10              POP      {r4,pc}
                  |L9.16|
000010  2000              MOVS     r0,#0                 ;1023
000012  bd10              POP      {r4,pc}
;;;1028   
                          ENDP


                          AREA ||i.RF_DC_Rstr_Isr||, CODE, READONLY, ALIGN=2

                  RF_DC_Rstr_Isr PROC
;;;1623   
;;;1624   void RF_DC_Rstr_Isr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1625   {
;;;1626       if(g16MHzClkOut == DISABLE_)
000002  4d08              LDR      r5,|L10.36|
000004  7928              LDRB     r0,[r5,#4]  ; g16MHzClkOut
000006  2800              CMP      r0,#0
000008  d108              BNE      |L10.28|
;;;1627       {
;;;1628           //SPI_PDMA_SetTx(RFIP_REG_41, (uint32_t)&RFIP_init_reg[RFIP_REG_41], 2);
;;;1629           SPI_1BYT_SetTx_Isr(RFIP_REG_41, RFIP_reg_MEM[RFIP_REG_MEM_41]);      //restore R41,R42 after wakeup
00000a  4c07              LDR      r4,|L10.40|
00000c  78e1              LDRB     r1,[r4,#3]  ; RFIP_reg_MEM
00000e  2029              MOVS     r0,#0x29
000010  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1630           SPI_1BYT_SetTx_Isr(RFIP_REG_42, RFIP_reg_MEM[RFIP_REG_MEM_42]);
000014  7921              LDRB     r1,[r4,#4]  ; RFIP_reg_MEM
000016  202a              MOVS     r0,#0x2a
000018  f7fffffe          BL       SPI_1BYT_SetTx_Isr
                  |L10.28|
;;;1631       }
;;;1632       gSleep = BLERFMODE_ACTIVE;
00001c  2000              MOVS     r0,#0
00001e  71a8              STRB     r0,[r5,#6]
;;;1633   }
000020  bd70              POP      {r4-r6,pc}
;;;1634   
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      ||area_number.73||
                  |L10.40|
                          DCD      ||.bss||

                          AREA ||i.RF_Enter_DeepSleep||, CODE, READONLY, ALIGN=2

                  RF_Enter_DeepSleep PROC
;;;1745   
;;;1746   void RF_Enter_DeepSleep(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1747   {
;;;1748       //Enter Deep Sleep mode (32K off)
;;;1749       uint8_t temp41, temp42;
;;;1750   
;;;1751       //R41[6:5]=11(N power smallest), R41[7],42[0]=11 (P power smallest)
;;;1752       temp41 = (RFIP_reg_MEM[RFIP_REG_MEM_41] & 0x1F) | 0xE0;
000002  4d0a              LDR      r5,|L11.44|
000004  78e9              LDRB     r1,[r5,#3]  ; RFIP_reg_MEM
000006  20e0              MOVS     r0,#0xe0
000008  4301              ORRS     r1,r1,r0
;;;1753       temp42 = (RFIP_reg_MEM[RFIP_REG_MEM_42] & 0x7E) | 0x81;
00000a  792c              LDRB     r4,[r5,#4]  ; RFIP_reg_MEM
00000c  2081              MOVS     r0,#0x81
00000e  4304              ORRS     r4,r4,r0
;;;1754   
;;;1755       SPI_1BYT_SetTx(RFIP_REG_41, temp41);
000010  2029              MOVS     r0,#0x29
000012  f7fffffe          BL       SPI_1BYT_SetTx
;;;1756       SPI_1BYT_SetTx(RFIP_REG_42, temp42);
000016  4621              MOV      r1,r4
000018  202a              MOVS     r0,#0x2a
00001a  f7fffffe          BL       SPI_1BYT_SetTx
;;;1757   
;;;1758       //set R120 bit1, bit7
;;;1759       SPI_1BYT_SetTx(RFIP_REG_120, (RFIP_reg_MEM[RFIP_REG_MEM_120]|0x82));
00001e  7aa9              LDRB     r1,[r5,#0xa]  ; RFIP_reg_MEM
000020  2082              MOVS     r0,#0x82
000022  4301              ORRS     r1,r1,r0
000024  2078              MOVS     r0,#0x78
000026  f7fffffe          BL       SPI_1BYT_SetTx
;;;1760   }
00002a  bd70              POP      {r4-r6,pc}
;;;1761   
                          ENDP

                  |L11.44|
                          DCD      ||.bss||

                          AREA ||i.RF_External_Wakeup||, CODE, READONLY, ALIGN=2

                  RF_External_Wakeup PROC
;;;1762   
;;;1763   void RF_External_Wakeup(void)
000000  b510              PUSH     {r4,lr}
;;;1764   {
;;;1765       uint8_t r28Value;
;;;1766     
;;;1767       //external wakeup from Sleep or Deep Sleep, by SPI write R0 any value
;;;1768       SPI_1BYT_SetTx(RFIP_REG_0, 0);
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       SPI_1BYT_SetTx
;;;1769       //Tiny_Delay(2000);  // XTAL_TURNON_TIME is set to 1ms, delay must > 1ms
;;;1770       Tiny_Delay(3500);    // XTAL_TURNON_TIME is set to 3ms, delay must > 3ms
00000a  4810              LDR      r0,|L12.76|
00000c  f7fffffe          BL       Tiny_Delay
;;;1771   
;;;1772   
;;;1773       /* ====== Re-enable BG ============================ */
;;;1774       r28Value = SPI_1BYT_SetRx(RFIP_REG_28);
000010  201c              MOVS     r0,#0x1c
000012  f7fffffe          BL       SPI_1BYT_SetRx
000016  4604              MOV      r4,r0
;;;1775       SPI_1BYT_SetTx(RFIP_REG_28, r28Value & 0xFE);  // disable BG R28[0] = 0
000018  0841              LSRS     r1,r0,#1
00001a  0049              LSLS     r1,r1,#1
00001c  201c              MOVS     r0,#0x1c
00001e  f7fffffe          BL       SPI_1BYT_SetTx
;;;1776       Tiny_Delay(500);
000022  20ff              MOVS     r0,#0xff
000024  30f5              ADDS     r0,r0,#0xf5
000026  f7fffffe          BL       Tiny_Delay
;;;1777       SPI_1BYT_SetTx(RFIP_REG_28, r28Value | 0x01);  // enable BG R28[0] = 1
00002a  2001              MOVS     r0,#1
00002c  4304              ORRS     r4,r4,r0
00002e  4621              MOV      r1,r4
000030  201c              MOVS     r0,#0x1c
000032  f7fffffe          BL       SPI_1BYT_SetTx
;;;1778   
;;;1779       //Set noraml R41,R42 values
;;;1780       //SPI_2BYT_SetTx_Isr(RFIP_REG_41, RFIP_init_reg+41);
;;;1781       SPI_1BYT_SetTx(RFIP_REG_41, RFIP_reg_MEM[RFIP_REG_MEM_41]);
000036  4c06              LDR      r4,|L12.80|
000038  78e1              LDRB     r1,[r4,#3]  ; RFIP_reg_MEM
00003a  2029              MOVS     r0,#0x29
00003c  f7fffffe          BL       SPI_1BYT_SetTx
;;;1782       SPI_1BYT_SetTx(RFIP_REG_42, RFIP_reg_MEM[RFIP_REG_MEM_42]);
000040  7921              LDRB     r1,[r4,#4]  ; RFIP_reg_MEM
000042  202a              MOVS     r0,#0x2a
000044  f7fffffe          BL       SPI_1BYT_SetTx
;;;1783   
;;;1784   }
000048  bd10              POP      {r4,pc}
;;;1785   
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      0x00000dac
                  |L12.80|
                          DCD      ||.bss||

                          AREA ||i.RF_Get_LastRssi||, CODE, READONLY, ALIGN=2

                  RF_Get_LastRssi PROC
;;;1640   uint8_t rssi_read_data[3];
;;;1641   int8_t RF_Get_LastRssi(void)
000000  b510              PUSH     {r4,lr}
;;;1642   {
;;;1643   
;;;1644   
;;;1645   #if (ENABLE_RF_RSSI==1)  //do not calculate RSSI in RX->TIFS critical section
;;;1646   
;;;1647       RT568_Gain_Info RT568_rf_gain;
;;;1648       int16_t rssi_dbm;
;;;1649       uint16_t lna_gain;
;;;1650       uint16_t tia_gain;
;;;1651       uint16_t vga_gain;
;;;1652   
;;;1653       SPI_PDMA_waitFinish();      //rssi_read_data[] is set by RF_Get_LastRssiRaw using SPI_PDMA_SetRx_Isr.
000002  f7fffffe          BL       SPI_PDMA_waitFinish
;;;1654       RT568_rf_gain.LNA_gain = (uint8_t)((rssi_read_data[0]&0xF0)>>4);
000006  4911              LDR      r1,|L13.76|
000008  7808              LDRB     r0,[r1,#0]  ; rssi_read_data
00000a  0903              LSRS     r3,r0,#4
;;;1655       RT568_rf_gain.TIA_gain = (uint8_t)(rssi_read_data[1]&0x0F);
00000c  7848              LDRB     r0,[r1,#1]  ; rssi_read_data
00000e  0702              LSLS     r2,r0,#28
;;;1656       RT568_rf_gain.VGA_gain = (uint8_t)((rssi_read_data[1]&0xF0)>>4);
000010  0900              LSRS     r0,r0,#4
;;;1657       RT568_rf_gain.BB_rssi_dbm = (uint8_t)rssi_read_data[2];
000012  7889              LDRB     r1,[r1,#2]  ; rssi_read_data
;;;1658   
;;;1659       lna_gain = R568_lna_agc[RT568_rf_gain.LNA_gain]; //gain*128
000014  005b              LSLS     r3,r3,#1
000016  4c0e              LDR      r4,|L13.80|
000018  5ae3              LDRH     r3,[r4,r3]
;;;1660       tia_gain = R568_tia_agc[RT568_rf_gain.TIA_gain]; //gain*128
00001a  0ed2              LSRS     r2,r2,#27
00001c  4c0d              LDR      r4,|L13.84|
00001e  5aa2              LDRH     r2,[r4,r2]
;;;1661       vga_gain = R568_vga_agc[RT568_rf_gain.VGA_gain]; //gain*128
000020  0040              LSLS     r0,r0,#1
000022  4c0d              LDR      r4,|L13.88|
000024  5a20              LDRH     r0,[r4,r0]
;;;1662   
;;;1663       rssi_dbm =(int16_t)(0-(lna_gain + tia_gain + vga_gain)) - (int16_t)((255-RT568_rf_gain.BB_rssi_dbm)<<7);
000026  189a              ADDS     r2,r3,r2
000028  1810              ADDS     r0,r2,r0
00002a  4240              RSBS     r0,r0,#0
00002c  22ff              MOVS     r2,#0xff
00002e  1a52              SUBS     r2,r2,r1
000030  01d2              LSLS     r2,r2,#7
000032  1a80              SUBS     r0,r0,r2
000034  b200              SXTH     r0,r0
;;;1664   
;;;1665       // Compensation 3.5 db
;;;1666       if(rssi_read_data[2] == 254)
000036  29fe              CMP      r1,#0xfe
000038  d102              BNE      |L13.64|
00003a  30ff              ADDS     r0,r0,#0xff
00003c  30c1              ADDS     r0,r0,#0xc1
;;;1667       {
;;;1668           //rssi_dbm += 350;   //3.5*100
;;;1669           rssi_dbm += 448;   //3.5*128
00003e  b200              SXTH     r0,r0
                  |L13.64|
;;;1670       }
;;;1671   
;;;1672       rssi_dbm = ((rssi_dbm >> 7) + rssiOffsetValue); // Add offset value
000040  11c0              ASRS     r0,r0,#7
000042  4906              LDR      r1,|L13.92|
000044  78c9              LDRB     r1,[r1,#3]  ; rssiOffsetValue
000046  1840              ADDS     r0,r0,r1
;;;1673   
;;;1674       return rssi_dbm;
000048  b240              SXTB     r0,r0
;;;1675   #else
;;;1676       return 0x1F;
;;;1677   #endif
;;;1678   
;;;1679   }
00004a  bd10              POP      {r4,pc}
;;;1680   
                          ENDP

                  |L13.76|
                          DCD      ||area_number.73||+0x9
                  |L13.80|
                          DCD      ||.constdata||+0xca
                  |L13.84|
                          DCD      ||.constdata||+0xea
                  |L13.88|
                          DCD      ||.constdata||+0x10a
                  |L13.92|
                          DCD      ||area_number.73||

                          AREA ||i.RF_Get_MaximumTxPowerLevel||, CODE, READONLY, ALIGN=1

                  RF_Get_MaximumTxPowerLevel PROC
;;;1740   
;;;1741   int8_t RF_Get_MaximumTxPowerLevel(void)
000000  200a              MOVS     r0,#0xa
;;;1742   {
;;;1743       return (int8_t)TX_POWER_10_DBM;
;;;1744   }
000002  4770              BX       lr
;;;1745   
                          ENDP


                          AREA ||i.RF_Get_TxPowerLevel||, CODE, READONLY, ALIGN=2

                  RF_Get_TxPowerLevel PROC
;;;1712   
;;;1713   int8_t RF_Get_TxPowerLevel(void)
000000  b508              PUSH     {r3,lr}
;;;1714   {
;;;1715       uint8_t txpower_read_data[4];
;;;1716   
;;;1717       SPI_PDMA_SetRx_Isr(RFIP_REG_23, (uint32_t)&txpower_read_data[0], 4);
000002  2204              MOVS     r2,#4
000004  4669              MOV      r1,sp
000006  2017              MOVS     r0,#0x17
000008  f7fffffe          BL       SPI_PDMA_SetRx_Isr
;;;1718       SPI_PDMA_waitFinish();
00000c  f7fffffe          BL       SPI_PDMA_waitFinish
;;;1719   
;;;1720       if(memcmp(txpower_0dbm_reg,txpower_read_data,4) == 0)
000010  2204              MOVS     r2,#4
000012  4669              MOV      r1,sp
000014  480e              LDR      r0,|L15.80|
000016  f7fffffe          BL       memcmp
00001a  2800              CMP      r0,#0
00001c  d013              BEQ      |L15.70|
;;;1721       {
;;;1722           return (int8_t)TX_POWER_0_DBM;
;;;1723       }
;;;1724       else if(memcmp(txpower_4dbm_reg,txpower_read_data,4) == 0)
00001e  2204              MOVS     r2,#4
000020  4669              MOV      r1,sp
000022  480c              LDR      r0,|L15.84|
000024  f7fffffe          BL       memcmp
000028  2800              CMP      r0,#0
00002a  d00d              BEQ      |L15.72|
;;;1725       {
;;;1726           return (int8_t)TX_POWER_4_DBM;
;;;1727       }
;;;1728       else if(memcmp(txpower_8dbm_reg,txpower_read_data,4) == 0)
00002c  2204              MOVS     r2,#4
00002e  4669              MOV      r1,sp
000030  4809              LDR      r0,|L15.88|
000032  f7fffffe          BL       memcmp
000036  2800              CMP      r0,#0
000038  d008              BEQ      |L15.76|
;;;1729       {
;;;1730           return (int8_t)TX_POWER_8_DBM;
;;;1731       }
;;;1732       else if(memcmp(txpower_10dbm_reg,txpower_read_data,4) == 0)
00003a  2204              MOVS     r2,#4
00003c  4669              MOV      r1,sp
00003e  4807              LDR      r0,|L15.92|
000040  f7fffffe          BL       memcmp
;;;1733       {
;;;1734           return (int8_t)TX_POWER_10_DBM;
;;;1735       }
;;;1736   
;;;1737       return TX_POWER_10_DBM;
000044  200a              MOVS     r0,#0xa
                  |L15.70|
;;;1738   }
000046  bd08              POP      {r3,pc}
                  |L15.72|
000048  2004              MOVS     r0,#4                 ;1726
00004a  bd08              POP      {r3,pc}
                  |L15.76|
00004c  2008              MOVS     r0,#8                 ;1730
00004e  bd08              POP      {r3,pc}
;;;1739   
                          ENDP

                  |L15.80|
                          DCD      ||.constdata||
                  |L15.84|
                          DCD      ||.constdata||+0x4
                  |L15.88|
                          DCD      ||.constdata||+0x8
                  |L15.92|
                          DCD      ||.constdata||+0xc

                          AREA ||i.RF_Header_Rdy_intOn||, CODE, READONLY, ALIGN=2

                  RF_Header_Rdy_intOn PROC
;;;1142   
;;;1143   void RF_Header_Rdy_intOn(void)
000000  4902              LDR      r1,|L16.12|
;;;1144   {
;;;1145       uint8_t i;
;;;1146   
;;;1147       i = (RFIP_reg_MEM[RFIP_REG_MEM_61]|REG_61_HEADER_RDY);
000002  79c8              LDRB     r0,[r1,#7]  ; RFIP_reg_MEM
000004  2201              MOVS     r2,#1
000006  4310              ORRS     r0,r0,r2
;;;1148       RFIP_reg_MEM[RFIP_REG_MEM_61] = i;
000008  71c8              STRB     r0,[r1,#7]
;;;1149       //SPI_1BYT_SetTx_Isr(RFIP_REG_61, i);   //The following function RF_WTR_intOn will run SPI to init..
;;;1150   }
00000a  4770              BX       lr
;;;1151   
                          ENDP

                  |L16.12|
                          DCD      ||.bss||

                          AREA ||i.RF_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  RF_Init PROC
;;;809    
;;;810    void RF_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;811    {
;;;812        uint32_t u32i;
;;;813        extern void initBleDeviceParam(BLE_Device_Param *bleDevice);
;;;814    
;;;815    #if (ENABLE_RF_VOLT_DETECT==1)
;;;816    #ifndef _HCI_HW_
;;;817        uint8_t volt;
;;;818    #endif
;;;819    #endif
;;;820    
;;;821        MCU_GpioIntDisable();
000002  f7fffffe          BL       MCU_GpioIntDisable
;;;822    
;;;823        //Init_flag = 0;
;;;824        rf_initial_flag = DISABLE_;
000006  2000              MOVS     r0,#0
000008  4d50              LDR      r5,|L17.332|
00000a  7168              STRB     r0,[r5,#5]
;;;825    
;;;826    #ifdef _DEBUG_PINS_
;;;827        Debug_Pins_Init();
;;;828    #endif  //(#ifdef _DEBUG_PINS_)
;;;829    
;;;830    #ifdef _HCI_HW_
;;;831    #ifdef _HCI_VIRTUAL_
;;;832        HCI_VIRTUAL_Init();
;;;833    #else
;;;834        UART_Init();
;;;835    #endif
;;;836    #endif //(_HCI_HW_)
;;;837    
;;;838        //  MUST init global device parameter first
;;;839        initBleDeviceParam(&ble_device_param);
00000c  4850              LDR      r0,|L17.336|
00000e  f7fffffe          BL       initBleDeviceParam
;;;840    
;;;841        /* Must read ChipID first */
;;;842        ble_device_param.ble_deviceChipId = SPI_1BYT_SetRx(RFIP_REG_0);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       SPI_1BYT_SetRx
000018  4e4d              LDR      r6,|L17.336|
00001a  7030              STRB     r0,[r6,#0]
;;;843    //#ifndef _HCI_HW_
;;;844    //    printf("Chip_ID=%d\n",ble_device_param.ble_deviceChipId);
;;;845    //#endif
;;;846    
;;;847        //Initial RFIP_reg_MEM[] ram
;;;848        for(u32i=0; u32i<SIZE_RFIP_REG; u32i++)
00001c  2000              MOVS     r0,#0
;;;849        {
;;;850            RFIP_reg_MEM[u32i] = RFIP_init_reg[RFIP_REG_IDX[u32i]];
00001e  494d              LDR      r1,|L17.340|
000020  460a              MOV      r2,r1
000022  3a80              SUBS     r2,r2,#0x80
000024  4c4c              LDR      r4,|L17.344|
                  |L17.38|
000026  5c0b              LDRB     r3,[r1,r0]
000028  5cd3              LDRB     r3,[r2,r3]
00002a  5423              STRB     r3,[r4,r0]
00002c  1c40              ADDS     r0,r0,#1
00002e  280d              CMP      r0,#0xd               ;848
000030  d3f9              BCC      |L17.38|
;;;851        }
;;;852    
;;;853    
;;;854    //#if (_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_) || (_BOARD_SELECTION_==_BOARD_NUVOTON_M487JIDAE_B3_)  //?
;;;855        addr_TxFIFO = 2;
000032  2002              MOVS     r0,#2
;;;856        //SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)(TAB_ZERO_128), LEN_CONN_DATA_MAX);
;;;857        Knl_CodeCpy(ram_Tab,TAB_ZERO_128,48);
000034  2230              MOVS     r2,#0x30
000036  4949              LDR      r1,|L17.348|
000038  6168              STR      r0,[r5,#0x14]  ; addr_TxFIFO
00003a  4849              LDR      r0,|L17.352|
00003c  f7fffffe          BL       Knl_CodeCpy
;;;858        SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)(&ram_Tab), LEN_CONN_DATA_MAX);
000040  221b              MOVS     r2,#0x1b
000042  4947              LDR      r1,|L17.352|
000044  20fe              MOVS     r0,#0xfe
000046  f7fffffe          BL       SPI_PDMA_SetTx
;;;859        //To avoid one strange problem on next calling function SPI_PDMA_SetTx(RFIP_REG_8,......
;;;860        //The SS pin will go high after the first byte sent, the discontinuous SS signal will cause RT568 failing to initialize.
;;;861    //#endif  //(_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_) || (_BOARD_SELECTION_==_BOARD_NUVOTON_M487JIDAE_B3_)
;;;862    
;;;863        //RF_init
;;;864    //    SPI_PDMA_SetTx(RFIP_REG_8, ((uint32_t)(RFIP_init_reg+8)), RADIO_RF_INIT_REG_NUM);        //R8~R46
;;;865        SPI_PDMA_waitFinish();
00004a  f7fffffe          BL       SPI_PDMA_waitFinish
;;;866        Knl_MemCpy(ram_Tab,(uint8_t *)(RFIP_init_reg+8),RADIO_RF_INIT_REG_NUM);
00004e  2227              MOVS     r2,#0x27
000050  4940              LDR      r1,|L17.340|
000052  3978              SUBS     r1,r1,#0x78
000054  4842              LDR      r0,|L17.352|
000056  f7fffffe          BL       Knl_MemCpy
;;;867        SPI_PDMA_SetTx(RFIP_REG_8, (uint32_t)ram_Tab, RADIO_RF_INIT_REG_NUM);        //R8~R46
00005a  2227              MOVS     r2,#0x27
00005c  4940              LDR      r1,|L17.352|
00005e  2008              MOVS     r0,#8
000060  f7fffffe          BL       SPI_PDMA_SetTx
;;;868    //    SPI_PDMA_SetTx(RFIP_REG_47, ((uint32_t)(RFIP_init_reg+47)), RADIO_BB_INIT_REG_NUM);      //R48~R127
;;;869        SPI_PDMA_waitFinish();
000064  f7fffffe          BL       SPI_PDMA_waitFinish
;;;870        Knl_MemCpy(ram_Tab,(uint8_t *)(RFIP_init_reg+47), 48);                 //R48~96
000068  2230              MOVS     r2,#0x30
00006a  493a              LDR      r1,|L17.340|
00006c  3951              SUBS     r1,r1,#0x51
00006e  483c              LDR      r0,|L17.352|
000070  f7fffffe          BL       Knl_MemCpy
;;;871        SPI_PDMA_SetTx(RFIP_REG_47, (uint32_t)ram_Tab, 48);      //R48~R127
000074  2230              MOVS     r2,#0x30
000076  493a              LDR      r1,|L17.352|
000078  202f              MOVS     r0,#0x2f
00007a  f7fffffe          BL       SPI_PDMA_SetTx
;;;872        SPI_PDMA_waitFinish();
00007e  f7fffffe          BL       SPI_PDMA_waitFinish
;;;873        Knl_MemCpy(ram_Tab,(uint8_t *)(RFIP_init_reg+95), RADIO_BB_INIT_REG_NUM-48);                 //R48~96
000082  2221              MOVS     r2,#0x21
000084  4933              LDR      r1,|L17.340|
000086  3921              SUBS     r1,r1,#0x21
000088  4835              LDR      r0,|L17.352|
00008a  f7fffffe          BL       Knl_MemCpy
;;;874        SPI_PDMA_SetTx(RFIP_REG_95, (uint32_t)ram_Tab, RADIO_BB_INIT_REG_NUM-48);      //R~R127
00008e  2221              MOVS     r2,#0x21
000090  4933              LDR      r1,|L17.352|
000092  205f              MOVS     r0,#0x5f
000094  f7fffffe          BL       SPI_PDMA_SetTx
;;;875    
;;;876        if(ble_device_param.ble_deviceChipId==MP_A1)
000098  7830              LDRB     r0,[r6,#0]  ; ble_device_param
00009a  2866              CMP      r0,#0x66
00009c  d103              BNE      |L17.166|
;;;877        {
;;;878            SPI_1BYT_SetTx(RFIP_REG_74, (RFIP_init_reg[RFIP_REG_74] | REG_74_EDGE));  //use edge trigger mode
00009e  215d              MOVS     r1,#0x5d
0000a0  204a              MOVS     r0,#0x4a
0000a2  f7fffffe          BL       SPI_1BYT_SetTx
                  |L17.166|
;;;879        }
;;;880    
;;;881        // check if enable 16M CLK Output
;;;882        if(g16MHzClkOut == ENABLE_)
0000a6  7928              LDRB     r0,[r5,#4]  ; g16MHzClkOut
0000a8  2801              CMP      r0,#1
0000aa  d103              BNE      |L17.180|
;;;883        {
;;;884            SPI_1BYT_SetTx(RFIP_REG_47, (RFIP_init_reg[RFIP_REG_47] & 0xFE)); // R47[0] = 0  //CLK output enable
0000ac  2100              MOVS     r1,#0
0000ae  202f              MOVS     r0,#0x2f
0000b0  f7fffffe          BL       SPI_1BYT_SetTx
                  |L17.180|
;;;885        }
;;;886    
;;;887        //------- If (received header[1]<MAX_PAYLOAD_LEN), CRC_err! -------//
;;;888        //SPI_1BYT_SetTx(RFIP_REG_165, 0xFF); //()
;;;889        //RF_RxLengthLimit(MAX_PAYLOAD_LEN);  //255
;;;890    
;;;891        //R172=0x0D. //b0=1:system_normal (0 is reset_n); b1=0, b2=1; b3=1:wait RC32K cal_done before Sleep; b5:4=00; b7:6=0/1/2(cal_time=1ms/2ms/4ms)
;;;892        SPI_1BYT_SetTx(RFIP_REG_172, 0x0D);
0000b4  210d              MOVS     r1,#0xd
0000b6  20ac              MOVS     r0,#0xac
0000b8  f7fffffe          BL       SPI_1BYT_SetTx
;;;893    
;;;894        //TX low_IF, R175=0x40
;;;895        SPI_1BYT_SetTx(RFIP_REG_175, 0x40);
0000bc  2140              MOVS     r1,#0x40
0000be  20af              MOVS     r0,#0xaf
0000c0  f7fffffe          BL       SPI_1BYT_SetTx
;;;896    
;;;897        //normal SPI, R250=0x00
;;;898        SPI_1BYT_SetTx(RFIP_REG_250, 0x00);
0000c4  2100              MOVS     r1,#0
0000c6  20fa              MOVS     r0,#0xfa
0000c8  f7fffffe          BL       SPI_1BYT_SetTx
;;;899    
;;;900        //-------Init BB/MAC register--------//
;;;901        //clear IRQ status
;;;902        SPI_1BYT_SetTx(RFIP_REG_62, 0x7f);                      //write 1 to clear status
0000cc  217f              MOVS     r1,#0x7f
0000ce  203e              MOVS     r0,#0x3e
0000d0  f7fffffe          BL       SPI_1BYT_SetTx
;;;903    
;;;904        //R98~R102'b0 are RTC timer count, initial are all 0
;;;905        //R102[7]=1, update RTC
;;;906        SPI_1BYT_SetTx(RFIP_REG_102, 0x80);
0000d4  2180              MOVS     r1,#0x80
0000d6  2066              MOVS     r0,#0x66
0000d8  f7fffffe          BL       SPI_1BYT_SetTx
;;;907    
;;;908        RFIP_reg_MEM[RFIP_REG_MEM_119] &= (~(REG_119_MANUAL_TRX_EN|REG_119_TR_TRIG_MODE));
0000dc  7a60              LDRB     r0,[r4,#9]  ; RFIP_reg_MEM
0000de  0680              LSLS     r0,r0,#26
0000e0  0e80              LSRS     r0,r0,#26
0000e2  7260              STRB     r0,[r4,#9]
;;;909        SPI_1BYT_SetTx(RFIP_REG_119, RFIP_reg_MEM[RFIP_REG_MEM_119]);   //RFIP_init_reg[119] is 0 as init..
0000e4  7a61              LDRB     r1,[r4,#9]  ; RFIP_reg_MEM
0000e6  2077              MOVS     r0,#0x77
0000e8  f7fffffe          BL       SPI_1BYT_SetTx
;;;910    
;;;911        //Auto switch TX/RX => R120[2]
;;;912    
;;;913    #if (ENABLE_AUTOMATIC_SWITCH_MODE==1)
;;;914        RFIP_reg_MEM[RFIP_REG_MEM_120] |= REG_120_AUTO_TRX;  //enable auto TR switch
0000ec  7aa0              LDRB     r0,[r4,#0xa]  ; RFIP_reg_MEM
0000ee  2604              MOVS     r6,#4
0000f0  4330              ORRS     r0,r0,r6
0000f2  72a0              STRB     r0,[r4,#0xa]
;;;915    #else
;;;916        RFIP_reg_MEM[RFIP_REG_MEM_120] &= (~REG_120_AUTO_TRX);
;;;917    #endif  //(ENABLE_AUTOMATIC_SWITCH_MODE==1)
;;;918    
;;;919        //clear bit7 first before set R120, disable RX access search time-out function.
;;;920        RFIP_reg_MEM[RFIP_REG_MEM_120] &= (~(REG_120_UPD_WAKE_TMR|REG_120_RX_TMROUT_EN));
0000f4  7aa0              LDRB     r0,[r4,#0xa]  ; RFIP_reg_MEM
0000f6  215f              MOVS     r1,#0x5f
0000f8  4008              ANDS     r0,r0,r1
0000fa  72a0              STRB     r0,[r4,#0xa]
;;;921        //rafael_spi_write(SPI_MASTER_PORT, 120, RFIP_init_reg+120, 1);
;;;922        SPI_1BYT_SetTx(RFIP_REG_120, RFIP_reg_MEM[RFIP_REG_MEM_120]);
0000fc  7aa1              LDRB     r1,[r4,#0xa]  ; RFIP_reg_MEM
0000fe  2078              MOVS     r0,#0x78
000100  f7fffffe          BL       SPI_1BYT_SetTx
;;;923    
;;;924        //reset MAC state write 1->0
;;;925        rafael_reset_phy_fsm();
000104  f7fffffe          BL       rafael_reset_phy_fsm
;;;926    
;;;927        // Tx_buffer start address = 0
;;;928        RF_TxFIFO_OriginAddr_set(0x0000);
000108  2000              MOVS     r0,#0
00010a  f7fffffe          BL       RF_TxFIFO_OriginAddr_set
;;;929    
;;;930        // PLL Calibration
;;;931    #if (ENABLE_VCO_CAL==1)
;;;932        //PLL linear mode & VCO calibration
;;;933        if(pll_cal_done_flag==0)
00010e  7a28              LDRB     r0,[r5,#8]  ; pll_cal_done_flag
000110  2701              MOVS     r7,#1                 ;882
000112  2800              CMP      r0,#0
000114  d102              BNE      |L17.284|
;;;934        {
;;;935    
;;;936            rafael_pll_calibration();
000116  f7fffffe          BL       rafael_pll_calibration
;;;937            pll_cal_done_flag=1;
00011a  722f              STRB     r7,[r5,#8]
                  |L17.284|
;;;938            /*
;;;939                 //if(Phy_pll_bank[0]==Phy_pll_bank[4])
;;;940                 if((Phy_pll_bank[1]<=Phy_pll_bank[0]) || (Phy_pll_bank[2]<=Phy_pll_bank[1]) || (Phy_pll_bank[3]<=Phy_pll_bank[2]) || (Phy_pll_bank[4]<=Phy_pll_bank[3]))
;;;941                 {
;;;942                   //Give a fixed value as a protection mechanism.
;;;943                   Phy_pll_bank[0] = 36;
;;;944                   Phy_pll_bank[1] = 38;
;;;945                   Phy_pll_bank[2] = 41;
;;;946                   Phy_pll_bank[3] = 43;
;;;947                   Phy_pll_bank[4] = 45;
;;;948    
;;;949                   pll_cal_done_flag=0;
;;;950                 }
;;;951                 else{
;;;952                   pll_cal_done_flag=1;
;;;953                 }
;;;954            */
;;;955        }
;;;956    
;;;957        //R36[2]=1, linear mode
;;;958        RFIP_reg_MEM[RFIP_REG_MEM_36] = RFIP_reg_MEM[RFIP_REG_MEM_36] | 0x04;  //linear mode
00011c  7860              LDRB     r0,[r4,#1]  ; RFIP_reg_MEM
00011e  4330              ORRS     r0,r0,r6
000120  7060              STRB     r0,[r4,#1]
;;;959        //RFIP_reg_MEM[RFIP_REG_MEM_36] = RFIP_reg_MEM[RFIP_REG_MEM_36] & 0xFB;  //binary mode
;;;960        SPI_1BYT_SetTx(RFIP_REG_36, RFIP_reg_MEM[RFIP_REG_MEM_36]);
000122  7861              LDRB     r1,[r4,#1]  ; RFIP_reg_MEM
000124  2024              MOVS     r0,#0x24
000126  f7fffffe          BL       SPI_1BYT_SetTx
;;;961    
;;;962    #else  //!ENABLE_VCO_CAL
;;;963        //PLL hybrid mode(binary->linear), (R88[4]=1,so set R88=0x11)
;;;964        //SPI_1BYT_SetTx(RFIP_REG_88, 0x11);
;;;965    
;;;966        //PLL binary mode
;;;967        RFIP_reg_MEM[RFIP_REG_MEM_36] = RFIP_reg_MEM[RFIP_REG_MEM_36] & 0xFB;  //binary mode
;;;968        SPI_1BYT_SetTx(RFIP_REG_36, RFIP_reg_MEM[RFIP_REG_MEM_36]);
;;;969        SPI_1BYT_SetTx(RFIP_REG_88, 0x01);    //PLL mode depend on R36[2]
;;;970    #endif  //(ENABLE_VCO_CAL==1)
;;;971    
;;;972        //no encryption at initialization
;;;973        SPI_1BYT_SetTx(RFIP_REG_155, REG_155_AES_MODE_BYPASS);
00012a  2100              MOVS     r1,#0
00012c  209b              MOVS     r0,#0x9b
00012e  f7fffffe          BL       SPI_1BYT_SetTx
;;;974    
;;;975        MCU_GpioIntEnable();
000132  f7fffffe          BL       MCU_GpioIntEnable
;;;976    
;;;977        Ble_SW_Init();
000136  f7fffffe          BL       Ble_SW_Init
;;;978    
;;;979    #if (ENABLE_RF_VOLT_DETECT==1)
;;;980    #ifndef _HCI_HW_
;;;981        volt = RF_Voltage_Det();
00013a  f7fffffe          BL       RF_Voltage_Det
00013e  4601              MOV      r1,r0
;;;982    #else
;;;983        RF_Voltage_Det();
;;;984    #endif
;;;985        //Init_flag = 1;
;;;986        /* set "rf_initial_flag" to enable,
;;;987           1. User can Not enable 16M CLK
;;;988           2. Control flow in RF_Voltage_Det
;;;989        */
;;;990        rf_initial_flag = ENABLE_;
000140  716f              STRB     r7,[r5,#5]
;;;991    
;;;992    
;;;993    
;;;994    #ifndef _HCI_HW_
;;;995        printf("volt=%d\n",volt); //removed in SDK
000142  a008              ADR      r0,|L17.356|
000144  f7fffffe          BL       __2printf
;;;996    #endif
;;;997    #endif  //(ENABLE_RF_VOLT_DETECT==1)  
;;;998    
;;;999    }
000148  bdf8              POP      {r3-r7,pc}
;;;1000   
                          ENDP

00014a  0000              DCW      0x0000
                  |L17.332|
                          DCD      ||area_number.73||
                  |L17.336|
                          DCD      ble_device_param
                  |L17.340|
                          DCD      ||.constdata||+0x95
                  |L17.344|
                          DCD      ||.bss||
                  |L17.348|
                          DCD      TAB_ZERO_128
                  |L17.352|
                          DCD      ram_Tab
                  |L17.356|
000164  766f6c74          DCB      "volt=%d\n",0
000168  3d25640a
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0

                          AREA ||i.RF_IntReset||, CODE, READONLY, ALIGN=1

                  RF_IntReset PROC
;;;1111   
;;;1112   void RF_IntReset(void)
000000  b510              PUSH     {r4,lr}
;;;1113   {
;;;1114       SPI_1BYT_SetTx(RFIP_REG_61, 0x00);
000002  2100              MOVS     r1,#0
000004  203d              MOVS     r0,#0x3d
000006  f7fffffe          BL       SPI_1BYT_SetTx
;;;1115       SPI_1BYT_SetTx(RFIP_REG_62, 0xFF);
00000a  21ff              MOVS     r1,#0xff
00000c  203e              MOVS     r0,#0x3e
00000e  f7fffffe          BL       SPI_1BYT_SetTx
;;;1116   }
000012  bd10              POP      {r4,pc}
;;;1117   
                          ENDP


                          AREA ||i.RF_LE_HeaderStsLen_Rx||, CODE, READONLY, ALIGN=1

                  RF_LE_HeaderStsLen_Rx PROC
;;;1635   
;;;1636   void RF_LE_HeaderStsLen_Rx(void)
000000  4770              BX       lr
;;;1637   {
;;;1638   }
;;;1639   
                          ENDP


                          AREA ||i.RF_LE_HeaderStsLen_Tx||, CODE, READONLY, ALIGN=2

                  RF_LE_HeaderStsLen_Tx PROC
;;;1240   
;;;1241   void RF_LE_HeaderStsLen_Tx(uint8_t *SrcAddr)
000000  b510              PUSH     {r4,lr}
;;;1242   {
;;;1243       addr_TxFIFO = 0;
000002  2200              MOVS     r2,#0
000004  4b03              LDR      r3,|L20.20|
;;;1244   
;;;1245       //SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)(SrcAddr), 2);
;;;1246       SPI_2BYT_SetTx_Isr(TX_BUFFER_WRITE_PORT, SrcAddr);  //write header into TX_buffer
000006  4601              MOV      r1,r0
000008  20fe              MOVS     r0,#0xfe
00000a  615a              STR      r2,[r3,#0x14]  ; addr_TxFIFO
00000c  f7fffffe          BL       SPI_2BYT_SetTx_Isr
;;;1247   }
000010  bd10              POP      {r4,pc}
;;;1248   
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      ||area_number.73||

                          AREA ||i.RF_PLL_VCO_Bank_set||, CODE, READONLY, ALIGN=1

                  RF_PLL_VCO_Bank_set PROC
;;;574    
;;;575    void RF_PLL_VCO_Bank_set(uint8_t valueVCO)                                    //Set PLL VCO Bank
000000  b510              PUSH     {r4,lr}
;;;576    {
;;;577    #if (ENABLE_VCO_CAL==1)
;;;578        SPI_1BYT_SetTx(RFIP_REG_12, (valueVCO|(RFIP_init_reg[RFIP_REG_12]&0xC0)));
000002  21c0              MOVS     r1,#0xc0
000004  4301              ORRS     r1,r1,r0
000006  200c              MOVS     r0,#0xc
000008  f7fffffe          BL       SPI_1BYT_SetTx
;;;579    #endif  //(ENABLE_VCO_CAL==1)
;;;580    }
00000c  bd10              POP      {r4,pc}
;;;581    
                          ENDP


                          AREA ||i.RF_PowerSaving_En_Isr||, CODE, READONLY, ALIGN=2

                  RF_PowerSaving_En_Isr PROC
;;;1601   
;;;1602   void RF_PowerSaving_En_Isr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1603   {
;;;1604       uint8_t temp41, temp42;
;;;1605   
;;;1606   #if (ENABLE_RF_VOLT_DETECT==1)
;;;1607       //Monitor RF Voltage here
;;;1608       RF_Voltage_Det();
000002  f7fffffe          BL       RF_Voltage_Det
;;;1609   #endif
;;;1610       if(g16MHzClkOut == DISABLE_)
000006  4d0d              LDR      r5,|L22.60|
000008  7928              LDRB     r0,[r5,#4]  ; g16MHzClkOut
00000a  2800              CMP      r0,#0
00000c  d113              BNE      |L22.54|
;;;1611       {
;;;1612           //R41[6:5]=11(N power smallest), {R41[7],R42[0]}=11 (P power smallest)
;;;1613           temp41 = (RFIP_reg_MEM[RFIP_REG_MEM_41] & 0x1F) | 0xE0;
00000e  4e0c              LDR      r6,|L22.64|
000010  78f1              LDRB     r1,[r6,#3]  ; RFIP_reg_MEM
000012  20e0              MOVS     r0,#0xe0
000014  4301              ORRS     r1,r1,r0
;;;1614           temp42 = (RFIP_reg_MEM[RFIP_REG_MEM_42] & 0x7E) | 0x81;   //set R41,R42 but do not update RFIP_reg_MEM[] before sleep
000016  7934              LDRB     r4,[r6,#4]  ; RFIP_reg_MEM
000018  2081              MOVS     r0,#0x81
00001a  4304              ORRS     r4,r4,r0
;;;1615           SPI_1BYT_SetTx_Isr(RFIP_REG_41, temp41);
00001c  2029              MOVS     r0,#0x29
00001e  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1616           SPI_1BYT_SetTx_Isr(RFIP_REG_42, temp42);
000022  4621              MOV      r1,r4
000024  202a              MOVS     r0,#0x2a
000026  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1617   
;;;1618           SPI_1BYT_SetTx_Isr(RFIP_REG_120, (RFIP_reg_MEM[RFIP_REG_MEM_120]|REG_120_UPD_WAKE_TMR));
00002a  7ab1              LDRB     r1,[r6,#0xa]  ; RFIP_reg_MEM
00002c  2080              MOVS     r0,#0x80
00002e  4301              ORRS     r1,r1,r0
000030  2078              MOVS     r0,#0x78
000032  f7fffffe          BL       SPI_1BYT_SetTx_Isr
                  |L22.54|
;;;1619       }
;;;1620   
;;;1621       gSleep = BLERFMODE_SLEEP;
000036  2001              MOVS     r0,#1
000038  71a8              STRB     r0,[r5,#6]
;;;1622   }
00003a  bd70              POP      {r4-r6,pc}
;;;1623   
                          ENDP

                  |L22.60|
                          DCD      ||area_number.73||
                  |L22.64|
                          DCD      ||.bss||

                          AREA ||i.RF_RTC_initVal_set||, CODE, READONLY, ALIGN=1

                  RF_RTC_initVal_set PROC
;;;1282   
;;;1283   void RF_RTC_initVal_set(uint64_t valueUpd)
000000  b500              PUSH     {lr}
;;;1284   {
000002  b083              SUB      sp,sp,#0xc
;;;1285       //__INT64
;;;1286       uint64_t i64;
;;;1287   
;;;1288       i64 = valueUpd;
;;;1289       //Little endian
;;;1290       //((uint32_t *) &i64)[1] &= 0x0000001F;      //bit[36:32]
;;;1291       //((uint32_t *) &i64)[1] |= 0x00000080;      //bit[39]
;;;1292   
;;;1293       //i = ((uint8_t *) &i64)[4] & 0x1F;
;;;1294       //((uint8_t *) &i64)[4] = i | 0x80;
;;;1295       SPI_PDMA_SetTx(RFIP_REG_98, (uint32_t)&i64, 5);
000004  2205              MOVS     r2,#5
000006  9101              STR      r1,[sp,#4]
000008  9000              STR      r0,[sp,#0]
00000a  4669              MOV      r1,sp
00000c  2062              MOVS     r0,#0x62
00000e  f7fffffe          BL       SPI_PDMA_SetTx
;;;1296       ((uint32_t *) &i64)[1] |= 0x00000080;                   //bit[39]
000012  2180              MOVS     r1,#0x80
000014  9801              LDR      r0,[sp,#4]
000016  4308              ORRS     r0,r0,r1
;;;1297       ((uint32_t *) &i64)[1] &= (0x0000001F|0x00000080);      //bit[39, 36:32]
000018  219f              MOVS     r1,#0x9f
00001a  4008              ANDS     r0,r0,r1
;;;1298       SPI_PDMA_waitFinish();
00001c  9001              STR      r0,[sp,#4]
00001e  f7fffffe          BL       SPI_PDMA_waitFinish
;;;1299   }
000022  b003              ADD      sp,sp,#0xc
000024  bd00              POP      {pc}
;;;1300   
                          ENDP


                          AREA ||i.RF_RTCvalue_get||, CODE, READONLY, ALIGN=1

                  RF_RTCvalue_get PROC
;;;1301   
;;;1302   uint64_t RF_RTCvalue_get(void)
000000  b500              PUSH     {lr}
;;;1303   {
000002  b083              SUB      sp,sp,#0xc
;;;1304       //__INT64
;;;1305       uint64_t i64;
;;;1306   
;;;1307       SPI_PDMA_SetRx_Isr(RFIP_REG_98, (uint32_t)&i64, 5);
000004  2205              MOVS     r2,#5
000006  4669              MOV      r1,sp
000008  2062              MOVS     r0,#0x62
00000a  f7fffffe          BL       SPI_PDMA_SetRx_Isr
;;;1308       SPI_PDMA_waitFinish();
00000e  f7fffffe          BL       SPI_PDMA_waitFinish
;;;1309       return i64;
000012  9901              LDR      r1,[sp,#4]
000014  9800              LDR      r0,[sp,#0]
;;;1310   }
000016  b003              ADD      sp,sp,#0xc
000018  bd00              POP      {pc}
;;;1311   
                          ENDP


                          AREA ||i.RF_RxLengthLimit||, CODE, READONLY, ALIGN=1

                  RF_RxLengthLimit PROC
;;;1256   
;;;1257   void RF_RxLengthLimit(uint8_t maxPDU)
000000  b510              PUSH     {r4,lr}
;;;1258   {
;;;1259       SPI_1BYT_SetTx_Isr(RFIP_REG_165, maxPDU);
000002  4601              MOV      r1,r0
000004  20a5              MOVS     r0,#0xa5
000006  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1260   }
00000a  bd10              POP      {r4,pc}
;;;1261   
                          ENDP


                          AREA ||i.RF_Set_TxPowerLevel_Isr||, CODE, READONLY, ALIGN=2

                  RF_Set_TxPowerLevel_Isr PROC
;;;1680   
;;;1681   uint8_t RF_Set_TxPowerLevel_Isr(int8_t power)
000000  b510              PUSH     {r4,lr}
;;;1682   {
;;;1683       // 2020/03/11 Neil 40pin
;;;1684       switch(power)
000002  2800              CMP      r0,#0
000004  d007              BEQ      |L26.22|
000006  2804              CMP      r0,#4
000008  d010              BEQ      |L26.44|
00000a  2808              CMP      r0,#8
00000c  d019              BEQ      |L26.66|
00000e  280a              CMP      r0,#0xa
000010  d022              BEQ      |L26.88|
;;;1685       {
;;;1686       case TX_POWER_0_DBM:
;;;1687           Knl_CodeCpy_Isr(ram_Tab,txpower_0dbm_reg,4);
;;;1688           SPI_PDMA_SetTx(RFIP_REG_23, (uint32_t)ram_Tab, 4); // R23-R26
;;;1689           break;
;;;1690   
;;;1691       case TX_POWER_4_DBM:
;;;1692           Knl_CodeCpy_Isr(ram_Tab,txpower_4dbm_reg,4);
;;;1693           SPI_PDMA_SetTx(RFIP_REG_23, (uint32_t)ram_Tab, 4); // R23-R26
;;;1694           break;
;;;1695   
;;;1696       case TX_POWER_8_DBM:
;;;1697           Knl_CodeCpy_Isr(ram_Tab,txpower_8dbm_reg,4);
;;;1698           SPI_PDMA_SetTx(RFIP_REG_23, (uint32_t)ram_Tab, 4); // R23-R26
;;;1699           break;
;;;1700   
;;;1701       case TX_POWER_10_DBM:
;;;1702           Knl_CodeCpy_Isr(ram_Tab,txpower_10dbm_reg,4);
;;;1703           SPI_PDMA_SetTx(RFIP_REG_23, (uint32_t)ram_Tab, 4); // R23-R26
;;;1704           break;
;;;1705   
;;;1706       default:
;;;1707           return FAIL_; // error tx power
000012  2001              MOVS     r0,#1
;;;1708       }
;;;1709   
;;;1710       return SUCCESS_;
;;;1711   }
000014  bd10              POP      {r4,pc}
                  |L26.22|
000016  2204              MOVS     r2,#4                 ;1687
000018  4915              LDR      r1,|L26.112|
00001a  4816              LDR      r0,|L26.116|
00001c  f7fffffe          BL       Knl_CodeCpy_Isr
000020  2204              MOVS     r2,#4                 ;1688
000022  4914              LDR      r1,|L26.116|
000024  2017              MOVS     r0,#0x17              ;1688
000026  f7fffffe          BL       SPI_PDMA_SetTx
00002a  e01f              B        |L26.108|
                  |L26.44|
00002c  2204              MOVS     r2,#4                 ;1692
00002e  4912              LDR      r1,|L26.120|
000030  4810              LDR      r0,|L26.116|
000032  f7fffffe          BL       Knl_CodeCpy_Isr
000036  2204              MOVS     r2,#4                 ;1693
000038  490e              LDR      r1,|L26.116|
00003a  2017              MOVS     r0,#0x17              ;1693
00003c  f7fffffe          BL       SPI_PDMA_SetTx
000040  e014              B        |L26.108|
                  |L26.66|
000042  2204              MOVS     r2,#4                 ;1697
000044  490d              LDR      r1,|L26.124|
000046  480b              LDR      r0,|L26.116|
000048  f7fffffe          BL       Knl_CodeCpy_Isr
00004c  2204              MOVS     r2,#4                 ;1698
00004e  4909              LDR      r1,|L26.116|
000050  2017              MOVS     r0,#0x17              ;1698
000052  f7fffffe          BL       SPI_PDMA_SetTx
000056  e009              B        |L26.108|
                  |L26.88|
000058  2204              MOVS     r2,#4                 ;1702
00005a  4909              LDR      r1,|L26.128|
00005c  4805              LDR      r0,|L26.116|
00005e  f7fffffe          BL       Knl_CodeCpy_Isr
000062  2204              MOVS     r2,#4                 ;1703
000064  4903              LDR      r1,|L26.116|
000066  2017              MOVS     r0,#0x17              ;1703
000068  f7fffffe          BL       SPI_PDMA_SetTx
                  |L26.108|
00006c  2000              MOVS     r0,#0                 ;1710
00006e  bd10              POP      {r4,pc}
;;;1712   
                          ENDP

                  |L26.112|
                          DCD      ||.constdata||
                  |L26.116|
                          DCD      ram_Tab
                  |L26.120|
                          DCD      ||.constdata||+0x4
                  |L26.124|
                          DCD      ||.constdata||+0x8
                  |L26.128|
                          DCD      ||.constdata||+0xc

                          AREA ||i.RF_SymbolRate_Patch_1M_2M||, CODE, READONLY, ALIGN=2

                  RF_SymbolRate_Patch_1M_2M PROC
;;;1189   
;;;1190   void RF_SymbolRate_Patch_1M_2M(uint8_t zSymbol_1M)    //0: 1M, not 0: 2M
000000  b510              PUSH     {r4,lr}
;;;1191   {
;;;1192       uint8_t i;
;;;1193   
;;;1194       if(zSymbol_1M)
;;;1195       {
;;;1196           i = (NEXT_TX_TIME+14);
;;;1197           RFIP_reg_MEM[RFIP_REG_MEM_120] |= REG_120_DATA_RATE;
000002  4c0a              LDR      r4,|L27.44|
000004  2800              CMP      r0,#0                 ;1194
000006  d004              BEQ      |L27.18|
000008  211f              MOVS     r1,#0x1f              ;1196
00000a  7aa0              LDRB     r0,[r4,#0xa]  ; RFIP_reg_MEM
00000c  2208              MOVS     r2,#8
00000e  4310              ORRS     r0,r0,r2
000010  e003              B        |L27.26|
                  |L27.18|
;;;1198       }
;;;1199       else
;;;1200       {
;;;1201           i = NEXT_TX_TIME;
000012  2111              MOVS     r1,#0x11
;;;1202           RFIP_reg_MEM[RFIP_REG_MEM_120] &= (~REG_120_DATA_RATE);
000014  7aa0              LDRB     r0,[r4,#0xa]  ; RFIP_reg_MEM
000016  22f7              MOVS     r2,#0xf7
000018  4010              ANDS     r0,r0,r2
                  |L27.26|
00001a  72a0              STRB     r0,[r4,#0xa]
;;;1203       }
;;;1204       SPI_1BYT_SetTx_Isr(RFIP_REG_94, i);
00001c  205e              MOVS     r0,#0x5e
00001e  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1205       SPI_1BYT_SetTx_Isr(RFIP_REG_120, RFIP_reg_MEM[RFIP_REG_MEM_120]);
000022  7aa1              LDRB     r1,[r4,#0xa]  ; RFIP_reg_MEM
000024  2078              MOVS     r0,#0x78
000026  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1206   }
00002a  bd10              POP      {r4,pc}
;;;1207   
                          ENDP

                  |L27.44|
                          DCD      ||.bss||

                          AREA ||i.RF_SymbolRate_set||, CODE, READONLY, ALIGN=2

                  RF_SymbolRate_set PROC
;;;1172   
;;;1173   void RF_SymbolRate_set(uint8_t zSymbol_1M)    //0: 1M, not 0: 2M
000000  b510              PUSH     {r4,lr}
;;;1174   {
;;;1175       uint8_t i;
;;;1176   
;;;1177       if(zSymbol_1M)
;;;1178       {
;;;1179           i = (RFIP_reg_MEM[RFIP_REG_MEM_120] | REG_120_DATA_RATE);
000002  4a07              LDR      r2,|L28.32|
000004  2800              CMP      r0,#0                 ;1177
;;;1180       }
;;;1181       else
;;;1182       {
;;;1183           i = (RFIP_reg_MEM[RFIP_REG_MEM_120] & (~REG_120_DATA_RATE));
000006  7a91              LDRB     r1,[r2,#0xa]  ; RFIP_reg_MEM
000008  d002              BEQ      |L28.16|
00000a  2008              MOVS     r0,#8                 ;1179
00000c  4301              ORRS     r1,r1,r0              ;1179
00000e  e001              B        |L28.20|
                  |L28.16|
000010  20f7              MOVS     r0,#0xf7
000012  4001              ANDS     r1,r1,r0
                  |L28.20|
;;;1184       }
;;;1185       RFIP_reg_MEM[RFIP_REG_MEM_120] = i;
000014  7291              STRB     r1,[r2,#0xa]
;;;1186       SPI_1BYT_SetTx_Isr(RFIP_REG_120, i);
000016  2078              MOVS     r0,#0x78
000018  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1187   }
00001c  bd10              POP      {r4,pc}
;;;1188   
                          ENDP

00001e  0000              DCW      0x0000
                  |L28.32|
                          DCD      ||.bss||

                          AREA ||i.RF_Sync_Chk||, CODE, READONLY, ALIGN=1

                  RF_Sync_Chk PROC
;;;1056   
;;;1057   uint8_t RF_Sync_Chk(void)
000000  2000              MOVS     r0,#0
;;;1058   {
;;;1059       return 0;
;;;1060   }
000002  4770              BX       lr
;;;1061   
                          ENDP


                          AREA ||i.RF_Tmr16_FlagChk||, CODE, READONLY, ALIGN=1

                  RF_Tmr16_FlagChk PROC
;;;1062   
;;;1063   uint8_t RF_Tmr16_FlagChk(void)
000000  2000              MOVS     r0,#0
;;;1064   {
;;;1065       return 0;
;;;1066   }
000002  4770              BX       lr
;;;1067   
                          ENDP


                          AREA ||i.RF_Tmr16_FlagClr_Isr||, CODE, READONLY, ALIGN=1

                  RF_Tmr16_FlagClr_Isr PROC
;;;1068   
;;;1069   void RF_Tmr16_FlagClr_Isr(void)
000000  bf00              NOP      
;;;1070   {
;;;1071       __NOP();
;;;1072   }
000002  4770              BX       lr
;;;1073   
                          ENDP


                          AREA ||i.RF_Tmr_Periodic_initial||, CODE, READONLY, ALIGN=2

                  RF_Tmr_Periodic_initial PROC
;;;1452   extern uint64_t Tmr37;
;;;1453   void RF_Tmr_Periodic_initial(uint32_t period_tick, uint8_t sleep_mode) //1st time enable periodic timer
000000  b5f0              PUSH     {r4-r7,lr}
;;;1454   {
000002  b083              SUB      sp,sp,#0xc
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
;;;1455       uint8_t temp;
;;;1456       uint8_t RTC_reg[5]= {0,0,0,0,0};
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1457       uint32_t periodUS_Set;
;;;1458   //    uint32_t RTC_timer_us_low, RTC_timer_us_high;
;;;1459   
;;;1460       //disable RT568 timer wakeup INT
;;;1461       temp = (RFIP_reg_MEM[RFIP_REG_MEM_61]&(~REG_61_WAKEUP));
00000c  4c2e              LDR      r4,|L32.200|
00000e  9001              STR      r0,[sp,#4]
000010  79e1              LDRB     r1,[r4,#7]  ; RFIP_reg_MEM
000012  20bf              MOVS     r0,#0xbf
000014  4001              ANDS     r1,r1,r0
;;;1462       RFIP_reg_MEM[RFIP_REG_MEM_61] = temp;
000016  71e1              STRB     r1,[r4,#7]
;;;1463       SPI_1BYT_SetTx(RFIP_REG_61, temp);
000018  203d              MOVS     r0,#0x3d
00001a  f7fffffe          BL       SPI_1BYT_SetTx
;;;1464   
;;;1465       //set one shot mode. R159[7]=0
;;;1466       SPI_1BYT_SetTx(RFIP_REG_159, 0);
00001e  2100              MOVS     r1,#0
000020  209f              MOVS     r0,#0x9f
000022  f7fffffe          BL       SPI_1BYT_SetTx
;;;1467   
;;;1468       //update RTC timer R98~R102 as 0
;;;1469       RTC_reg[4]=0x80;   //update RTC
000026  2580              MOVS     r5,#0x80
000028  4669              MOV      r1,sp
00002a  710d              STRB     r5,[r1,#4]
;;;1470       SPI_PDMA_SetTx(RFIP_REG_98, (uint32_t)(RTC_reg), 5);
00002c  2205              MOVS     r2,#5
00002e  2062              MOVS     r0,#0x62
000030  f7fffffe          BL       SPI_PDMA_SetTx
;;;1471       SPI_PDMA_waitFinish();      //need to wait SPI done. or RTC_reg will be updated later
000034  f7fffffe          BL       SPI_PDMA_waitFinish
;;;1472   
;;;1473       periodUS_Set = period_tick*125;
000038  4630              MOV      r0,r6
00003a  217d              MOVS     r1,#0x7d
00003c  4348              MULS     r0,r1,r0
00003e  2200              MOVS     r2,#0
;;;1474       /*
;;;1475           //Sleep or not. Set R120[7]
;;;1476           if(sleep_mode==RF_SLEEP_ENABLE){  //Sleep
;;;1477              temp = RFIP_reg_MEM[RFIP_REG_MEM_120] | REG_120_UPD_WAKE_TMR;    //R120[7]=1
;;;1478           }
;;;1479           else{               //Non-Sleep
;;;1480              temp = RFIP_reg_MEM[RFIP_REG_MEM_120] & (~REG_120_UPD_WAKE_TMR); //R120[7]=0
;;;1481           }
;;;1482           temp = temp & 0xFD;    //clear bit1, use internal RTC sleep mode. 32k on
;;;1483           RFIP_reg_MEM[RFIP_REG_MEM_120] = temp;
;;;1484           SPI_1BYT_SetTx(RFIP_REG_120, temp);
;;;1485       */
;;;1486       //Write RTC timer (R115~R119), periodUS timeup
;;;1487       //Tmr37 = periodUS_Set;               //initialization
;;;1488       Tmr37 = 0;               //initialization
000040  4922              LDR      r1,|L32.204|
000042  600a              STR      r2,[r1,#0]  ; Tmr37
;;;1489       RTC_reg[0] = periodUS_Set & 0xFF;
000044  604a              STR      r2,[r1,#4]  ; Tmr37
000046  4669              MOV      r1,sp
000048  7008              STRB     r0,[r1,#0]
;;;1490       RTC_reg[1] = (periodUS_Set>>8) & 0xFF;
00004a  0a02              LSRS     r2,r0,#8
00004c  704a              STRB     r2,[r1,#1]
;;;1491       RTC_reg[2] = (periodUS_Set>>16) & 0xFF;
00004e  0c02              LSRS     r2,r0,#16
000050  708a              STRB     r2,[r1,#2]
;;;1492       RTC_reg[3] = (periodUS_Set>>24) & 0xFF;
000052  0e00              LSRS     r0,r0,#24
000054  70c8              STRB     r0,[r1,#3]
;;;1493   
;;;1494       if(ble_device_param.ble_deviceChipId == MP_A1)
000056  481e              LDR      r0,|L32.208|
000058  7800              LDRB     r0,[r0,#0]  ; ble_device_param
00005a  2866              CMP      r0,#0x66
;;;1495       {
;;;1496           RTC_reg[4] = RFIP_reg_MEM[RFIP_REG_MEM_119] & 0xE0;
;;;1497           SPI_PDMA_SetTx(RFIP_REG_115, (uint32_t)(RTC_reg), 5);
;;;1498           SPI_PDMA_waitFinish();
;;;1499       }
;;;1500       else
;;;1501       {
;;;1502           RTC_reg[4] = (RFIP_reg_MEM[RFIP_REG_MEM_119] & 0xE0) | 0x20;   //R119[5] write 1 and write 0 to update RTC_compare
00005c  7a60              LDRB     r0,[r4,#9]  ; RFIP_reg_MEM
00005e  d026              BEQ      |L32.174|
000060  0940              LSRS     r0,r0,#5
000062  0140              LSLS     r0,r0,#5
000064  2120              MOVS     r1,#0x20
000066  4308              ORRS     r0,r0,r1
000068  4669              MOV      r1,sp
00006a  7108              STRB     r0,[r1,#4]
;;;1503           SPI_PDMA_SetTx(RFIP_REG_115, (uint32_t)(RTC_reg), 5);
00006c  2205              MOVS     r2,#5
00006e  2073              MOVS     r0,#0x73
000070  f7fffffe          BL       SPI_PDMA_SetTx
;;;1504           SPI_PDMA_waitFinish();
000074  f7fffffe          BL       SPI_PDMA_waitFinish
;;;1505   
;;;1506           SPI_1BYT_SetTx(RFIP_REG_119, RFIP_reg_MEM[RFIP_REG_MEM_119] & 0xDF);  //R119[5]=0
000078  7a61              LDRB     r1,[r4,#9]  ; RFIP_reg_MEM
00007a  20df              MOVS     r0,#0xdf
00007c  4001              ANDS     r1,r1,r0
00007e  2077              MOVS     r0,#0x77
000080  f7fffffe          BL       SPI_1BYT_SetTx
                  |L32.132|
;;;1507       }
;;;1508   
;;;1509       //enable RT568 timer wakeup INT
;;;1510       temp = (RFIP_reg_MEM[RFIP_REG_MEM_61]|REG_61_WAKEUP);
000084  79e1              LDRB     r1,[r4,#7]  ; RFIP_reg_MEM
000086  2040              MOVS     r0,#0x40
000088  4301              ORRS     r1,r1,r0
;;;1511       RFIP_reg_MEM[RFIP_REG_MEM_61] = temp;
00008a  71e1              STRB     r1,[r4,#7]
;;;1512       SPI_1BYT_SetTx(RFIP_REG_61, temp);
00008c  203d              MOVS     r0,#0x3d
00008e  f7fffffe          BL       SPI_1BYT_SetTx
;;;1513   
;;;1514       //Write period timer
;;;1515       RF_Tmr_Periodic_set_ISR(period_tick);  //time unit:125us. enable periodic timer, INT in bit[6]
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       RF_Tmr_Periodic_set_ISR
;;;1516   
;;;1517       //Sleep or not
;;;1518       if(sleep_mode==1)   //Sleep
000098  2f01              CMP      r7,#1
00009a  d012              BEQ      |L32.194|
;;;1519       {
;;;1520           temp = RFIP_reg_MEM[RFIP_REG_MEM_120] | REG_120_UPD_WAKE_TMR;    //R120[7]=1
;;;1521       }
;;;1522       else                //Non-Sleep
;;;1523       {
;;;1524           temp = RFIP_reg_MEM[RFIP_REG_MEM_120] & (~REG_120_UPD_WAKE_TMR); //R120[7]=0
00009c  7aa0              LDRB     r0,[r4,#0xa]  ; RFIP_reg_MEM
00009e  0641              LSLS     r1,r0,#25
0000a0  0e49              LSRS     r1,r1,#25
                  |L32.162|
;;;1525       }
;;;1526       RFIP_reg_MEM[RFIP_REG_MEM_120] = temp;
0000a2  72a1              STRB     r1,[r4,#0xa]
;;;1527       SPI_1BYT_SetTx(RFIP_REG_120, temp);
0000a4  2078              MOVS     r0,#0x78
0000a6  f7fffffe          BL       SPI_1BYT_SetTx
;;;1528   }
0000aa  b003              ADD      sp,sp,#0xc
0000ac  bdf0              POP      {r4-r7,pc}
                  |L32.174|
0000ae  0940              LSRS     r0,r0,#5              ;1496
0000b0  0140              LSLS     r0,r0,#5              ;1496
0000b2  7108              STRB     r0,[r1,#4]            ;1496
0000b4  2205              MOVS     r2,#5                 ;1497
0000b6  2073              MOVS     r0,#0x73              ;1497
0000b8  f7fffffe          BL       SPI_PDMA_SetTx
0000bc  f7fffffe          BL       SPI_PDMA_waitFinish
0000c0  e7e0              B        |L32.132|
                  |L32.194|
0000c2  7aa1              LDRB     r1,[r4,#0xa]          ;1520  ; RFIP_reg_MEM
0000c4  4329              ORRS     r1,r1,r5              ;1520
0000c6  e7ec              B        |L32.162|
;;;1529   
                          ENDP

                  |L32.200|
                          DCD      ||.bss||
                  |L32.204|
                          DCD      Tmr37
                  |L32.208|
                          DCD      ble_device_param

                          AREA ||i.RF_Tmr_Periodic_set_ISR||, CODE, READONLY, ALIGN=2

                  RF_Tmr_Periodic_set_ISR PROC
;;;1559   #pragma Otime
;;;1560   void RF_Tmr_Periodic_set_ISR(uint32_t period_tick)  //change periodic timer
000000  b538              PUSH     {r3-r5,lr}
;;;1561   {
000002  4604              MOV      r4,r0
;;;1562       extern uint32_t Timeline24;
;;;1563       uint32_t periodUS_Set;
;;;1564   
;;;1565       periodUS_Set = period_tick*125;
000004  4620              MOV      r0,r4
000006  217d              MOVS     r1,#0x7d
000008  4348              MULS     r0,r1,r0
00000a  4605              MOV      r5,r0
;;;1566       periodUS_Set |= 0x80000000;
00000c  07c9              LSLS     r1,r1,#31
00000e  4308              ORRS     r0,r0,r1
000010  9000              STR      r0,[sp,#0]
;;;1567       SPI_PDMA_SetTx(RFIP_REG_156, (uint32_t)&periodUS_Set, 4);
000012  2204              MOVS     r2,#4
000014  4669              MOV      r1,sp
000016  209c              MOVS     r0,#0x9c
000018  f7fffffe          BL       SPI_PDMA_SetTx
;;;1568   
;;;1569       Tmr37 += period_tick*125;
00001c  2200              MOVS     r2,#0
00001e  480c              LDR      r0,|L33.80|
000020  6843              LDR      r3,[r0,#4]  ; Tmr37
000022  6801              LDR      r1,[r0,#0]  ; Tmr37
000024  1869              ADDS     r1,r5,r1
000026  415a              ADCS     r2,r2,r3
000028  6042              STR      r2,[r0,#4]  ; Tmr37
00002a  6001              STR      r1,[r0,#0]  ; Tmr37
;;;1570       //((uint32_t *)&Tmr37)[1] &= 0xFFFFFF1F;
;;;1571       ((uint8_t *)&Tmr37)[4] &= 0x1F;
00002c  7901              LDRB     r1,[r0,#4]  ; Tmr37
00002e  06c9              LSLS     r1,r1,#27
000030  0ec9              LSRS     r1,r1,#27
000032  7101              STRB     r1,[r0,#4]
;;;1572   
;;;1573       Timeline24 += period_tick;
000034  4907              LDR      r1,|L33.84|
000036  68c8              LDR      r0,[r1,#0xc]  ; Timeline24
000038  1900              ADDS     r0,r0,r4
00003a  60c8              STR      r0,[r1,#0xc]  ; Timeline24
;;;1574       if(((uint8_t *)&Timeline24)[3] > 0xEF)
00003c  4a06              LDR      r2,|L33.88|
00003e  78d0              LDRB     r0,[r2,#3]  ; Timeline24
000040  28ef              CMP      r0,#0xef
000042  d902              BLS      |L33.74|
;;;1575       {
;;;1576           //Timeline24 &= 0x0FFFFFFF;
;;;1577           ((uint8_t *)&Timeline24)[3] &= 0x0F;
000044  0700              LSLS     r0,r0,#28
000046  0f00              LSRS     r0,r0,#28
000048  70d0              STRB     r0,[r2,#3]
                  |L33.74|
;;;1578       }
;;;1579   
;;;1580       Tmr16Interval = period_tick;
00004a  610c              STR      r4,[r1,#0x10]  ; Tmr16Interval
;;;1581   }
00004c  bd38              POP      {r3-r5,pc}
;;;1582   #pragma pop
                          ENDP

00004e  0000              DCW      0x0000
                  |L33.80|
                          DCD      Tmr37
                  |L33.84|
                          DCD      ||area_number.73||
                  |L33.88|
                          DCD      ||area_number.73||+0xc

                          AREA ||i.RF_TxAutoAckOff||, CODE, READONLY, ALIGN=2

                  RF_TxAutoAckOff PROC
;;;1162   
;;;1163   void RF_TxAutoAckOff(void)      //Not only for Tx
000000  b510              PUSH     {r4,lr}
;;;1164   {
;;;1165       uint8_t i;
;;;1166   
;;;1167       i = (RFIP_reg_MEM[RFIP_REG_MEM_120] & (~REG_120_AUTO_TRX));
000002  4804              LDR      r0,|L34.20|
000004  7a81              LDRB     r1,[r0,#0xa]  ; RFIP_reg_MEM
000006  22fb              MOVS     r2,#0xfb
000008  4011              ANDS     r1,r1,r2
;;;1168       RFIP_reg_MEM[RFIP_REG_MEM_120] = i;
00000a  7281              STRB     r1,[r0,#0xa]
;;;1169       SPI_1BYT_SetTx_Isr(RFIP_REG_120, i);
00000c  2078              MOVS     r0,#0x78
00000e  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1170   }
000012  bd10              POP      {r4,pc}
;;;1171   
                          ENDP

                  |L34.20|
                          DCD      ||.bss||

                          AREA ||i.RF_TxAutoAckOn||, CODE, READONLY, ALIGN=2

                  RF_TxAutoAckOn PROC
;;;1152   
;;;1153   void RF_TxAutoAckOn(void)       //Not only for Tx
000000  b510              PUSH     {r4,lr}
;;;1154   {
;;;1155       uint8_t i;
;;;1156   
;;;1157       i = (RFIP_reg_MEM[RFIP_REG_MEM_120] | REG_120_AUTO_TRX);
000002  4804              LDR      r0,|L35.20|
000004  7a81              LDRB     r1,[r0,#0xa]  ; RFIP_reg_MEM
000006  2204              MOVS     r2,#4
000008  4311              ORRS     r1,r1,r2
;;;1158       RFIP_reg_MEM[RFIP_REG_MEM_120] = i;
00000a  7281              STRB     r1,[r0,#0xa]
;;;1159       SPI_1BYT_SetTx_Isr(RFIP_REG_120, i);
00000c  2078              MOVS     r0,#0x78
00000e  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1160   }
000012  bd10              POP      {r4,pc}
;;;1161   
                          ENDP

                  |L35.20|
                          DCD      ||.bss||

                          AREA ||i.RF_TxFIFO_ADVData_set||, CODE, READONLY, ALIGN=2

                  RF_TxFIFO_ADVData_set PROC
;;;1223   
;;;1224   void RF_TxFIFO_ADVData_set(Uint8 *SrcAddr)
000000  b510              PUSH     {r4,lr}
;;;1225   {
;;;1226       addr_TxFIFO = 8;
000002  2208              MOVS     r2,#8
000004  4b03              LDR      r3,|L36.20|
;;;1227       SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)(SrcAddr), LEN_ADV_SCAN_DATA_MAX);
000006  615a              STR      r2,[r3,#0x14]  ; addr_TxFIFO
000008  221f              MOVS     r2,#0x1f
00000a  4601              MOV      r1,r0
00000c  20fe              MOVS     r0,#0xfe
00000e  f7fffffe          BL       SPI_PDMA_SetTx
;;;1228   
;;;1229       //Knl_MemCpy_Isr((TXDATA_REG+SIZE_BLE_ADDR), SrcAddr, LEN_ADV_SCAN_DATA_MAX);
;;;1230   }
000012  bd10              POP      {r4,pc}
;;;1231   
                          ENDP

                  |L36.20|
                          DCD      ||area_number.73||

                          AREA ||i.RF_TxFIFO_ADVaddr_set||, CODE, READONLY, ALIGN=2

                  RF_TxFIFO_ADVaddr_set PROC
;;;1214   
;;;1215   void RF_TxFIFO_ADVaddr_set(Uint8 *AdvAddr)
000000  b510              PUSH     {r4,lr}
;;;1216   {
;;;1217       addr_TxFIFO = 2;
000002  2202              MOVS     r2,#2
000004  4b03              LDR      r3,|L37.20|
;;;1218       SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)(AdvAddr), SIZE_BLE_ADDR);
000006  615a              STR      r2,[r3,#0x14]  ; addr_TxFIFO
000008  2206              MOVS     r2,#6
00000a  4601              MOV      r1,r0
00000c  20fe              MOVS     r0,#0xfe
00000e  f7fffffe          BL       SPI_PDMA_SetTx
;;;1219   
;;;1220       //Knl_MemCpy_Isr(TXDATA_REG, AdvAddr, SIZE_BLE_ADDR);
;;;1221   }
000012  bd10              POP      {r4,pc}
;;;1222   
                          ENDP

                  |L37.20|
                          DCD      ||area_number.73||

                          AREA ||i.RF_TxFIFO_LeData_set||, CODE, READONLY, ALIGN=2

                  RF_TxFIFO_LeData_set PROC
;;;1232   
;;;1233   void RF_TxFIFO_LeData_set(uint8_t *SrcAddr, uint8_t length)
000000  b570              PUSH     {r4-r6,lr}
;;;1234   {
000002  460d              MOV      r5,r1
;;;1235       addr_TxFIFO = 2;
000004  2102              MOVS     r1,#2
000006  4c05              LDR      r4,|L38.28|
;;;1236       SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)(SrcAddr), length);
000008  462a              MOV      r2,r5
00000a  6161              STR      r1,[r4,#0x14]  ; addr_TxFIFO
00000c  4601              MOV      r1,r0
00000e  20fe              MOVS     r0,#0xfe
000010  f7fffffe          BL       SPI_PDMA_SetTx
;;;1237       addr_TxFIFO += length;
000014  6960              LDR      r0,[r4,#0x14]  ; addr_TxFIFO
000016  1940              ADDS     r0,r0,r5
000018  6160              STR      r0,[r4,#0x14]  ; addr_TxFIFO
;;;1238   }
00001a  bd70              POP      {r4-r6,pc}
;;;1239   
                          ENDP

                  |L38.28|
                          DCD      ||area_number.73||

                          AREA ||i.RF_TxFIFO_LeData_wIdx_set||, CODE, READONLY, ALIGN=2

                  RF_TxFIFO_LeData_wIdx_set PROC
;;;1249   
;;;1250   void RF_TxFIFO_LeData_wIdx_set(uint8_t *SrcAddr, uint8_t length)
000000  b510              PUSH     {r4,lr}
;;;1251   {
000002  460c              MOV      r4,r1
;;;1252       SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)(SrcAddr), length);
000004  460a              MOV      r2,r1
000006  4601              MOV      r1,r0
000008  20fe              MOVS     r0,#0xfe
00000a  f7fffffe          BL       SPI_PDMA_SetTx
;;;1253       addr_TxFIFO += length;
00000e  4802              LDR      r0,|L39.24|
000010  6941              LDR      r1,[r0,#0x14]  ; addr_TxFIFO
000012  1909              ADDS     r1,r1,r4
000014  6141              STR      r1,[r0,#0x14]  ; addr_TxFIFO
;;;1254   }
000016  bd10              POP      {r4,pc}
;;;1255   
                          ENDP

                  |L39.24|
                          DCD      ||area_number.73||

                          AREA ||i.RF_TxFIFO_OriginAddr_set||, CODE, READONLY, ALIGN=1

                  RF_TxFIFO_OriginAddr_set PROC
;;;1312   
;;;1313   void RF_TxFIFO_OriginAddr_set(uint16_t OriginAddr)
000000  b501              PUSH     {r0,lr}
;;;1314   {
;;;1315       OriginAddr &= 0x01FF;
000002  4669              MOV      r1,sp
000004  8808              LDRH     r0,[r1,#0]
000006  05c0              LSLS     r0,r0,#23
000008  0dc0              LSRS     r0,r0,#23
;;;1316   #if (ENABLE_TX_PAYLOAD_CHECK==1)
;;;1317       OriginAddr |= 0x8000;
00000a  2101              MOVS     r1,#1
00000c  03c9              LSLS     r1,r1,#15
00000e  4308              ORRS     r0,r0,r1
000010  4669              MOV      r1,sp
000012  8008              STRH     r0,[r1,#0]
;;;1318   #endif
;;;1319       SPI_2BYT_SetTx_Isr(RFIP_REG_104, (uint8_t *)&OriginAddr);
000014  2068              MOVS     r0,#0x68
000016  f7fffffe          BL       SPI_2BYT_SetTx_Isr
;;;1320   }
00001a  bd08              POP      {r3,pc}
;;;1321   
                          ENDP


                          AREA ||i.RF_Voltage_Det||, CODE, READONLY, ALIGN=2

                  RF_Voltage_Det PROC
;;;1419   #if (ENABLE_RF_VOLT_DETECT==1)
;;;1420   uint8_t RF_Voltage_Det(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1421   {
;;;1422       uint8_t volt_read;
;;;1423   
;;;1424       volt_read = SPI_1BYT_SetRx(RFIP_REG_4);
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SPI_1BYT_SetRx
;;;1425   
;;;1426       volt_read = (volt_read & 0x20) >> 5; //R4[5]: VBAT volt
000008  0680              LSLS     r0,r0,#26
00000a  0fc4              LSRS     r4,r0,#31
;;;1427       if((RfVolt_new != volt_read) || (rf_initial_flag == DISABLE_))
00000c  4e13              LDR      r6,|L41.92|
00000e  7830              LDRB     r0,[r6,#0]  ; RfVolt_new
000010  42a0              CMP      r0,r4
000012  d102              BNE      |L41.26|
000014  7970              LDRB     r0,[r6,#5]  ; rf_initial_flag
000016  2800              CMP      r0,#0
000018  d11d              BNE      |L41.86|
                  |L41.26|
;;;1428       {
;;;1429   
;;;1430           //set both buck,ldo on
;;;1431           RFIP_reg_MEM[RFIP_REG_MEM_40] = (RFIP_reg_MEM[RFIP_REG_MEM_40] & 0xAF) | 0x50;         //R40[4]=1(buck on);R40[6]=1(ldo on)
00001a  4d11              LDR      r5,|L41.96|
00001c  78a8              LDRB     r0,[r5,#2]  ; RFIP_reg_MEM
00001e  2150              MOVS     r1,#0x50
000020  4308              ORRS     r0,r0,r1
000022  70a8              STRB     r0,[r5,#2]
;;;1432           SPI_1BYT_SetTx(RFIP_REG_40, RFIP_reg_MEM[RFIP_REG_MEM_40]);
000024  78a9              LDRB     r1,[r5,#2]  ; RFIP_reg_MEM
000026  2028              MOVS     r0,#0x28
000028  f7fffffe          BL       SPI_1BYT_SetTx
;;;1433           Tiny_Delay(10);
00002c  200a              MOVS     r0,#0xa
00002e  f7fffffe          BL       Tiny_Delay
;;;1434   
;;;1435           if(volt_read==1)    //VBAT>2.5V
000032  2c00              CMP      r4,#0
;;;1436           {
;;;1437               RFIP_reg_MEM[RFIP_REG_MEM_40] = (RFIP_reg_MEM[RFIP_REG_MEM_40] & 0xBF);                //R40[6]=0(ldo off)
;;;1438               SPI_1BYT_SetTx(RFIP_REG_40, RFIP_reg_MEM[RFIP_REG_MEM_40]);
;;;1439           }
;;;1440           else    //VBAT<2.5V
;;;1441           {
;;;1442               RFIP_reg_MEM[RFIP_REG_MEM_40] = (RFIP_reg_MEM[RFIP_REG_MEM_40] & 0xEF);                //R40[4]=0(buck off)
000034  78a8              LDRB     r0,[r5,#2]  ; RFIP_reg_MEM
000036  d007              BEQ      |L41.72|
000038  21bf              MOVS     r1,#0xbf              ;1437
00003a  4008              ANDS     r0,r0,r1              ;1437
00003c  70a8              STRB     r0,[r5,#2]            ;1437
00003e  78a9              LDRB     r1,[r5,#2]            ;1438  ; RFIP_reg_MEM
000040  2028              MOVS     r0,#0x28              ;1438
000042  f7fffffe          BL       SPI_1BYT_SetTx
000046  e006              B        |L41.86|
                  |L41.72|
000048  21ef              MOVS     r1,#0xef
00004a  4008              ANDS     r0,r0,r1
00004c  70a8              STRB     r0,[r5,#2]
;;;1443               SPI_1BYT_SetTx(RFIP_REG_40, RFIP_reg_MEM[RFIP_REG_MEM_40]);
00004e  78a9              LDRB     r1,[r5,#2]  ; RFIP_reg_MEM
000050  2028              MOVS     r0,#0x28
000052  f7fffffe          BL       SPI_1BYT_SetTx
                  |L41.86|
;;;1444           }
;;;1445       }
;;;1446       RfVolt_new = volt_read;
000056  7034              STRB     r4,[r6,#0]
;;;1447   
;;;1448       return volt_read;
000058  4620              MOV      r0,r4
;;;1449   }
00005a  bd70              POP      {r4-r6,pc}
;;;1450   #endif  //(ENABLE_RF_VOLT_DETECT==1)
                          ENDP

                  |L41.92|
                          DCD      ||area_number.73||
                  |L41.96|
                          DCD      ||.bss||

                          AREA ||i.RF_WTR_EnChk||, CODE, READONLY, ALIGN=2

                  RF_WTR_EnChk PROC
;;;1029   
;;;1030   uint8_t RF_WTR_EnChk(void)
000000  4803              LDR      r0,|L42.16|
;;;1031   {
;;;1032       extern uint8_t RF_Msg_RF0INT;
;;;1033   
;;;1034       if(RF_Msg_RF0INT&(RF_MSG_RF0INT_WTR|RF_MSG_RF0INT_WTR_T))
000002  7800              LDRB     r0,[r0,#0]  ; RF_Msg_RF0INT
000004  0780              LSLS     r0,r0,#30
000006  d001              BEQ      |L42.12|
;;;1035       {
;;;1036           return SUCCESS_;
000008  2000              MOVS     r0,#0
;;;1037       }
;;;1038       else
;;;1039       {
;;;1040           return FAIL_;
;;;1041       }
;;;1042   }
00000a  4770              BX       lr
                  |L42.12|
00000c  2001              MOVS     r0,#1                 ;1040
00000e  4770              BX       lr
;;;1043   
                          ENDP

                  |L42.16|
                          DCD      RF_Msg_RF0INT

                          AREA ||i.RF_WTR_EndChk||, CODE, READONLY, ALIGN=1

                  RF_WTR_EndChk PROC
;;;1050   
;;;1051   uint8_t RF_WTR_EndChk(void)
000000  2000              MOVS     r0,#0
;;;1052   {
;;;1053       return 0;
;;;1054   }
000002  4770              BX       lr
;;;1055   
                          ENDP


                          AREA ||i.RF_WTR_TRxChk||, CODE, READONLY, ALIGN=1

                  RF_WTR_TRxChk PROC
;;;1044   
;;;1045   uint8_t RF_WTR_TRxChk(void)     //0: Rx, Not 0: Tx
000000  2000              MOVS     r0,#0
;;;1046   {
;;;1047       return 0;
;;;1048   }
000002  4770              BX       lr
;;;1049   
                          ENDP


                          AREA ||i.RF_WTR_intOff||, CODE, READONLY, ALIGN=2

                  RF_WTR_intOff PROC
;;;1130   
;;;1131   void RF_WTR_intOff(void)
000000  b510              PUSH     {r4,lr}
;;;1132   {
;;;1133       uint8_t i;
;;;1134   
;;;1135       //RFIP_reg_MEM[RFIP_REG_MEM_61] = (RFIP_reg_MEM[RFIP_REG_MEM_61]&(~INT_SETTING_W));
;;;1136       //SPI_1BYT_SetTx_Isr(RFIP_REG_61, RFIP_reg_MEM[RFIP_REG_MEM_61]);
;;;1137       i = (RFIP_reg_MEM[RFIP_REG_MEM_61]&(~INT_SETTING_W_WTR));
000002  4804              LDR      r0,|L45.20|
000004  79c1              LDRB     r1,[r0,#7]  ; RFIP_reg_MEM
000006  22eb              MOVS     r2,#0xeb
000008  4011              ANDS     r1,r1,r2
;;;1138       RFIP_reg_MEM[RFIP_REG_MEM_61] = i;
00000a  71c1              STRB     r1,[r0,#7]
;;;1139       SPI_1BYT_SetTx_Isr(RFIP_REG_61, i);
00000c  203d              MOVS     r0,#0x3d
00000e  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1140   }
000012  bd10              POP      {r4,pc}
;;;1141   
                          ENDP

                  |L45.20|
                          DCD      ||.bss||

                          AREA ||i.RF_WTR_intOn||, CODE, READONLY, ALIGN=2

                  RF_WTR_intOn PROC
;;;1118   
;;;1119   void RF_WTR_intOn(void)
000000  b510              PUSH     {r4,lr}
;;;1120   {
;;;1121       uint8_t i;
;;;1122   
;;;1123       //RFIP_reg_MEM[RFIP_REG_MEM_61] = (RFIP_reg_MEM[RFIP_REG_MEM_61]|INT_SETTING_W);
;;;1124       //SPI_1BYT_SetTx_Isr(RFIP_REG_61, RFIP_reg_MEM[RFIP_REG_MEM_61]);
;;;1125       i = (RFIP_reg_MEM[RFIP_REG_MEM_61]|INT_SETTING_W_WTR);
000002  4804              LDR      r0,|L46.20|
000004  79c1              LDRB     r1,[r0,#7]  ; RFIP_reg_MEM
000006  2214              MOVS     r2,#0x14
000008  4311              ORRS     r1,r1,r2
;;;1126       RFIP_reg_MEM[RFIP_REG_MEM_61] = i;
00000a  71c1              STRB     r1,[r0,#7]
;;;1127       SPI_1BYT_SetTx_Isr(RFIP_REG_61, i);
00000c  203d              MOVS     r0,#0x3d
00000e  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1128   }
000012  bd10              POP      {r4,pc}
;;;1129   
                          ENDP

                  |L46.20|
                          DCD      ||.bss||

                          AREA ||i.SdkVersion_Get||, CODE, READONLY, ALIGN=2

                  SdkVersion_Get PROC
;;;1964   // internal function
;;;1965   uint8_t* SdkVersion_Get(void)
000000  a000              ADR      r0,|L47.4|
;;;1966   {
;;;1967       return (uint8_t *)BLE_SDK_Version;
;;;1968   }
000002  4770              BX       lr
;;;1969   
                          ENDP

                  |L47.4|
000004  312e312e          DCB      "1.1.0.326",0
000008  302e3332
00000c  3600    
00000e  00                DCB      0
00000f  00                DCB      0

                          AREA ||i.initInt||, CODE, READONLY, ALIGN=2

                  initInt PROC
;;;1001   
;;;1002   void initInt(void)          //initial interrupt
000000  2000              MOVS     r0,#0
;;;1003   {
;;;1004       extern uint8_t RF_Msg_RF0INT;
;;;1005       //EIP |= EIP_REG_RFINTF;  //higher the RFINT interrupt priority
;;;1006       //EIP |= RAFAEL_HW_MAP;  //higher the RFINT interrupt priority
;;;1007       RF_Msg_RF0INT = 0;      //initialization
000002  4903              LDR      r1,|L48.16|
000004  7008              STRB     r0,[r1,#0]
;;;1008       Content_ioInt = 0;      //initialization
000006  4903              LDR      r1,|L48.20|
000008  7048              STRB     r0,[r1,#1]
;;;1009       Content_ioInt_exceptTmr = 0;    //initialization
00000a  7088              STRB     r0,[r1,#2]
;;;1010   }
00000c  4770              BX       lr
;;;1011   
                          ENDP

00000e  0000              DCW      0x0000
                  |L48.16|
                          DCD      RF_Msg_RF0INT
                  |L48.20|
                          DCD      ||area_number.73||

                          AREA ||i.rafael_pll_bank_get||, CODE, READONLY, ALIGN=2

                  rafael_pll_bank_get PROC
;;;687    //---------------------------------//
;;;688    void rafael_pll_bank_get(uint16_t freq_mhz, uint8_t *p_bank_result)
000000  b5f8              PUSH     {r3-r7,lr}
;;;689    {
000002  460c              MOV      r4,r1
;;;690        //For example,  2403 < N < 2423,
;;;691        //VCO_Bank (N) = VCO_BANK(2403) + {[ VCO_BANK(2403)  - VCO_BANK(2423) ] * [(N-2403) / 20]};
;;;692    
;;;693        //static uint16_t pll_freq_mhz[5]={2402, 2422, 2442, 2462, 2480}; //0:2402MHz, 10:2422MHz, 20:2442MHz, 30:2462MHz, 39:2480MHz
;;;694        //static uint8_t pll_bank[5]={36, 39, 41, 43, 44};
;;;695    
;;;696        uint8_t pll_bank_cnt=0;
000004  2200              MOVS     r2,#0
;;;697        uint16_t pll_cal;
;;;698    
;;;699        while(pll_bank_cnt<NUM_PLL_BANK)
;;;700        {
;;;701            if(freq_mhz == pll_freq_mhz[pll_bank_cnt])
000006  4d16              LDR      r5,|L49.96|
;;;702            {
;;;703                *p_bank_result = Phy_pll_bank[pll_bank_cnt];
000008  1fae              SUBS     r6,r5,#6
                  |L49.10|
00000a  0051              LSLS     r1,r2,#1              ;701
00000c  5a6b              LDRH     r3,[r5,r1]            ;701
00000e  4283              CMP      r3,r0                 ;701
000010  d101              BNE      |L49.22|
000012  5cb0              LDRB     r0,[r6,r2]
;;;704                return;
000014  e01c              B        |L49.80|
                  |L49.22|
;;;705            }
;;;706            else if(freq_mhz>pll_freq_mhz[pll_bank_cnt] && freq_mhz<pll_freq_mhz[pll_bank_cnt+1])
000016  4283              CMP      r3,r0
000018  d21c              BCS      |L49.84|
00001a  194f              ADDS     r7,r1,r5
00001c  887f              LDRH     r7,[r7,#2]
00001e  4287              CMP      r7,r0
000020  d918              BLS      |L49.84|
;;;707            {
;;;708                //*p_bank_result = pll_bank[pll_bank_cnt] + (((pll_bank[pll_bank_cnt+1] - pll_bank[pll_bank_cnt]) * (freq_mhz-pll_freq_mhz[pll_bank_cnt])) / (pll_freq_mhz[pll_bank_cnt+1] - pll_freq_mhz[pll_bank_cnt]));
;;;709                pll_cal = (((Phy_pll_bank[pll_bank_cnt+1] - Phy_pll_bank[pll_bank_cnt]) * (freq_mhz-pll_freq_mhz[pll_bank_cnt]) * 10) / (pll_freq_mhz[pll_bank_cnt+1] - pll_freq_mhz[pll_bank_cnt]));
000022  0057              LSLS     r7,r2,#1
000024  197f              ADDS     r7,r7,r5
000026  887f              LDRH     r7,[r7,#2]
000028  b299              UXTH     r1,r3
00002a  1a79              SUBS     r1,r7,r1
00002c  18b5              ADDS     r5,r6,r2
00002e  786f              LDRB     r7,[r5,#1]
000030  5cb5              LDRB     r5,[r6,r2]
000032  1b7a              SUBS     r2,r7,r5
000034  1ac0              SUBS     r0,r0,r3
000036  4342              MULS     r2,r0,r2
000038  200a              MOVS     r0,#0xa
00003a  4350              MULS     r0,r2,r0
00003c  f7fffffe          BL       __aeabi_idivmod
000040  b280              UXTH     r0,r0
;;;710                if((pll_cal%10)>=5)
000042  210a              MOVS     r1,#0xa
000044  f7fffffe          BL       __aeabi_uidivmod
000048  2905              CMP      r1,#5
00004a  d300              BCC      |L49.78|
00004c  1c40              ADDS     r0,r0,#1
                  |L49.78|
;;;711                {
;;;712                    *p_bank_result = Phy_pll_bank[pll_bank_cnt] + (pll_cal/10) + 1;
;;;713                }
;;;714                else
;;;715                {
;;;716                    *p_bank_result = Phy_pll_bank[pll_bank_cnt] + (pll_cal/10);
00004e  1940              ADDS     r0,r0,r5
                  |L49.80|
000050  7020              STRB     r0,[r4,#0]
;;;717                }
;;;718                return;
;;;719            }
;;;720            else
;;;721            {
;;;722                pll_bank_cnt++;
;;;723            }
;;;724        } //while(pll_bank_cnt<5)
;;;725    }
000052  bdf8              POP      {r3-r7,pc}
                  |L49.84|
000054  1c52              ADDS     r2,r2,#1
000056  b2d2              UXTB     r2,r2                 ;722
000058  2a05              CMP      r2,#5                 ;699
00005a  d3d6              BCC      |L49.10|
00005c  bdf8              POP      {r3-r7,pc}
;;;726    
                          ENDP

00005e  0000              DCW      0x0000
                  |L49.96|
                          DCD      ||area_number.73||+0x1e

                          AREA ||i.rafael_pll_calibration||, CODE, READONLY, ALIGN=2

                  rafael_pll_calibration PROC
;;;585    //---------------------------------//
;;;586    void rafael_pll_calibration(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;587    {
;;;588    #if 1
;;;589        uint8_t pll_cal_cnt;
;;;590        uint8_t j=0;
000002  2600              MOVS     r6,#0
;;;591        uint16_t i16;
;;;592    
;;;593        //1.disable INT
;;;594        RF_IntReset();
000004  f7fffffe          BL       RF_IntReset
;;;595    
;;;596        //2.Set PLL lock Time (R91[7:0]) = 255, set maximum value first
;;;597        SPI_1BYT_SetTx(RFIP_REG_91, 0xFF);
000008  21ff              MOVS     r1,#0xff
00000a  205b              MOVS     r0,#0x5b
00000c  f7fffffe          BL       SPI_1BYT_SetTx
;;;598    
;;;599        //3.Set PLL linear mode(R36[2]==1)
;;;600        //R88[4]=0, manual mode by R36[2]
;;;601        SPI_1BYT_SetTx(RFIP_REG_88, 0x01);
000010  2101              MOVS     r1,#1
000012  2058              MOVS     r0,#0x58
000014  f7fffffe          BL       SPI_1BYT_SetTx
;;;602    
;;;603        RFIP_reg_MEM[RFIP_REG_MEM_36] = RFIP_reg_MEM[RFIP_REG_MEM_36] | 0x04;
000018  4d42              LDR      r5,|L50.292|
00001a  7868              LDRB     r0,[r5,#1]  ; RFIP_reg_MEM
00001c  2104              MOVS     r1,#4
00001e  4308              ORRS     r0,r0,r1
000020  7068              STRB     r0,[r5,#1]
;;;604        SPI_1BYT_SetTx(RFIP_REG_36, RFIP_reg_MEM[RFIP_REG_MEM_36]);
000022  7869              LDRB     r1,[r5,#1]  ; RFIP_reg_MEM
000024  2024              MOVS     r0,#0x24
000026  f7fffffe          BL       SPI_1BYT_SetTx
;;;605    
;;;606        //4.Set PLL VCO Bank = 32(R12[5:0]=32)
;;;607        RF_PLL_VCO_Bank_set(32);
00002a  2020              MOVS     r0,#0x20
00002c  f7fffffe          BL       RF_PLL_VCO_Bank_set
;;;608    
;;;609        //5.Set Symbol rate = 1MHz(R120 = 0x08)
;;;610        RF_SymbolRate_set(0);
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       RF_SymbolRate_set
;;;611    
;;;612        InterruptDisable();
000036  b672              CPSID    i
;;;613        for(pll_cal_cnt=0; pll_cal_cnt<NUM_PLL_BANK; pll_cal_cnt++)
000038  2400              MOVS     r4,#0
;;;614        {
;;;615            RFIP_reg_MEM[RFIP_REG_MEM_121] = RFIP_reg_MEM[RFIP_REG_MEM_121] | 0x40;     //Rx mode
;;;616            SPI_1BYT_SetTx(RFIP_REG_121, RFIP_reg_MEM[RFIP_REG_MEM_121]);
;;;617            //6.Set Channel Num R121[5:0]
;;;618            setChannel_BLE(Phy_pll_bank_freqIdx[pll_cal_cnt]);
;;;619    
;;;620            //7.Enable RX (R119 = 0x00, then R119 = 0x80)
;;;621            SPI_1BYT_SetTx(RFIP_REG_119, 0x00);
;;;622            SPI_1BYT_SetTx(RFIP_REG_119, REG_119_MANUAL_TRX_EN);
;;;623    
;;;624            //8.Wait 450us, then read R1[5:0], get VCO bank num for 2402 Mhz
;;;625            Tiny_Delay(1000);  //1ms
;;;626    
;;;627            //read VCO bank
;;;628            Phy_pll_bank[pll_cal_cnt] = (SPI_1BYT_SetRx(RFIP_REG_1) & 0x3F);
00003a  4f3b              LDR      r7,|L50.296|
                  |L50.60|
00003c  7ae8              LDRB     r0,[r5,#0xb]          ;615  ; RFIP_reg_MEM
00003e  2140              MOVS     r1,#0x40              ;615
000040  4308              ORRS     r0,r0,r1              ;615
000042  72e8              STRB     r0,[r5,#0xb]          ;615
000044  7ae9              LDRB     r1,[r5,#0xb]          ;616  ; RFIP_reg_MEM
000046  2079              MOVS     r0,#0x79              ;616
000048  f7fffffe          BL       SPI_1BYT_SetTx
00004c  4837              LDR      r0,|L50.300|
00004e  5d00              LDRB     r0,[r0,r4]            ;618
000050  f7fffffe          BL       setChannel_BLE
000054  2100              MOVS     r1,#0                 ;621
000056  2077              MOVS     r0,#0x77              ;621
000058  f7fffffe          BL       SPI_1BYT_SetTx
00005c  2180              MOVS     r1,#0x80              ;622
00005e  2077              MOVS     r0,#0x77              ;622
000060  f7fffffe          BL       SPI_1BYT_SetTx
000064  207d              MOVS     r0,#0x7d              ;625
000066  00c0              LSLS     r0,r0,#3              ;625
000068  f7fffffe          BL       Tiny_Delay
00006c  2001              MOVS     r0,#1
00006e  f7fffffe          BL       SPI_1BYT_SetRx
000072  0680              LSLS     r0,r0,#26
000074  0e80              LSRS     r0,r0,#26
000076  5538              STRB     r0,[r7,r4]
;;;629            //printf("Phy_pll_bank[%d]=%d\n", pll_cal_cnt, Phy_pll_bank[pll_cal_cnt]);
;;;630            //printf("%d\n", Phy_pll_bank[pll_cal_cnt]);
;;;631            /*
;;;632                    //This part is time consuming? => calculate all channel VCO bank, do once in initial, do not have to calculate when set channel!
;;;633                    if(pll_cal_cnt) {
;;;634                        i16 = pll_freq_mhz[(pll_cal_cnt-1)];  //get freq, i16
;;;635                        while(i16 < pll_freq_mhz[(pll_cal_cnt)]) {
;;;636                            rafael_pll_bank_get(i16, &CH_PLL_bank_Table[CH_SEL_TABLE_INV[j]]); // transfer i16 to PLL VCO Bank, store to CH_PLL_bank_Table[CH_SEL_TABLE_INV[j]]
;;;637                            i16 = i16+2;
;;;638                            j++;
;;;639                        };
;;;640                    };
;;;641            */
;;;642            //8.Disable Rx (R121[7] = 1)
;;;643            rafael_reset_phy_fsm();
000078  f7fffffe          BL       rafael_reset_phy_fsm
00007c  1c64              ADDS     r4,r4,#1
00007e  b2e4              UXTB     r4,r4                 ;613
000080  2c05              CMP      r4,#5                 ;613
000082  d3db              BCC      |L50.60|
;;;644        } //end for(pll_cal_cnt=0;pll_cal_cnt<5;pll_cal_cnt++)
;;;645    
;;;646        if((Phy_pll_bank[1]<=Phy_pll_bank[0]) || (Phy_pll_bank[2]<=Phy_pll_bank[1]) || (Phy_pll_bank[3]<=Phy_pll_bank[2]) || (Phy_pll_bank[4]<=Phy_pll_bank[3]))
000084  4928              LDR      r1,|L50.296|
000086  7848              LDRB     r0,[r1,#1]  ; Phy_pll_bank
000088  7809              LDRB     r1,[r1,#0]  ; Phy_pll_bank
00008a  4288              CMP      r0,r1
00008c  d909              BLS      |L50.162|
00008e  4a26              LDR      r2,|L50.296|
000090  7891              LDRB     r1,[r2,#2]  ; Phy_pll_bank
000092  4281              CMP      r1,r0
000094  d905              BLS      |L50.162|
000096  78d0              LDRB     r0,[r2,#3]  ; Phy_pll_bank
000098  4288              CMP      r0,r1
00009a  d902              BLS      |L50.162|
00009c  7911              LDRB     r1,[r2,#4]  ; Phy_pll_bank
00009e  4281              CMP      r1,r0
0000a0  d80a              BHI      |L50.184|
                  |L50.162|
;;;647        {
;;;648            //Give a fixed value as a protection mechanism.
;;;649            Phy_pll_bank[0] = 36;
0000a2  2124              MOVS     r1,#0x24
0000a4  4820              LDR      r0,|L50.296|
0000a6  7001              STRB     r1,[r0,#0]
;;;650            Phy_pll_bank[1] = 38;
0000a8  2126              MOVS     r1,#0x26
0000aa  7041              STRB     r1,[r0,#1]
;;;651            Phy_pll_bank[2] = 41;
0000ac  2129              MOVS     r1,#0x29
0000ae  7081              STRB     r1,[r0,#2]
;;;652            Phy_pll_bank[3] = 43;
0000b0  212b              MOVS     r1,#0x2b
0000b2  70c1              STRB     r1,[r0,#3]
;;;653            Phy_pll_bank[4] = 45;
0000b4  212d              MOVS     r1,#0x2d
0000b6  7101              STRB     r1,[r0,#4]
                  |L50.184|
;;;654        }
;;;655    
;;;656        for(pll_cal_cnt=0; pll_cal_cnt<NUM_PLL_BANK; pll_cal_cnt++)
0000b8  2400              MOVS     r4,#0
0000ba  e01a              B        |L50.242|
                  |L50.188|
;;;657        {
;;;658            //This part is time consuming? => calculate all channel VCO bank, do once in initial, do not have to calculate when set channel!
;;;659            if(pll_cal_cnt)
0000bc  2c00              CMP      r4,#0
0000be  d018              BEQ      |L50.242|
;;;660            {
;;;661                i16 = pll_freq_mhz[(pll_cal_cnt-1)];  //get freq, i16
0000c0  0067              LSLS     r7,r4,#1
0000c2  4819              LDR      r0,|L50.296|
0000c4  1d80              ADDS     r0,r0,#6
0000c6  1839              ADDS     r1,r7,r0
0000c8  3940              SUBS     r1,r1,#0x40
0000ca  8fcd              LDRH     r5,[r1,#0x3e]
;;;662                while(i16 < pll_freq_mhz[(pll_cal_cnt)])
0000cc  e00c              B        |L50.232|
                  |L50.206|
;;;663                {
;;;664                    rafael_pll_bank_get(i16, &CH_PLL_bank_Table[CH_SEL_TABLE_INV[j]]); // transfer i16 to PLL VCO Bank, store to CH_PLL_bank_Table[CH_SEL_TABLE_INV[j]]
0000ce  4817              LDR      r0,|L50.300|
0000d0  3092              ADDS     r0,r0,#0x92
0000d2  5d81              LDRB     r1,[r0,r6]
0000d4  4813              LDR      r0,|L50.292|
0000d6  300d              ADDS     r0,r0,#0xd
0000d8  1809              ADDS     r1,r1,r0
0000da  4628              MOV      r0,r5
0000dc  f7fffffe          BL       rafael_pll_bank_get
0000e0  1cad              ADDS     r5,r5,#2
;;;665                    i16 = i16+2;
0000e2  b2ad              UXTH     r5,r5
0000e4  1c76              ADDS     r6,r6,#1
;;;666                    j++;
0000e6  b2f6              UXTB     r6,r6
                  |L50.232|
0000e8  480f              LDR      r0,|L50.296|
0000ea  1d80              ADDS     r0,r0,#6              ;662
0000ec  5bc0              LDRH     r0,[r0,r7]            ;662
0000ee  42a8              CMP      r0,r5                 ;662
0000f0  d8ed              BHI      |L50.206|
                  |L50.242|
0000f2  1c64              ADDS     r4,r4,#1              ;662
0000f4  b2e4              UXTB     r4,r4                 ;656
0000f6  2c05              CMP      r4,#5                 ;656
0000f8  d3e0              BCC      |L50.188|
;;;667                };
;;;668            };
;;;669        }
;;;670        CH_PLL_bank_Table[39]=Phy_pll_bank[NUM_PLL_BANK-1];  //last channel
0000fa  480b              LDR      r0,|L50.296|
0000fc  7901              LDRB     r1,[r0,#4]  ; Phy_pll_bank
0000fe  4809              LDR      r0,|L50.292|
000100  302d              ADDS     r0,r0,#0x2d
000102  71c1              STRB     r1,[r0,#7]
;;;671    
;;;672        //enable INT
;;;673        SPI_1BYT_SetTx(RFIP_REG_62, 0xFF);
000104  21ff              MOVS     r1,#0xff
000106  203e              MOVS     r0,#0x3e
000108  f7fffffe          BL       SPI_1BYT_SetTx
;;;674        RF_WTR_intOn();
00010c  f7fffffe          BL       RF_WTR_intOn
;;;675        InterruptEnable();
000110  b662              CPSIE    i
;;;676    
;;;677        //Set PLL Lock Time(R91), PLL Fast Lock Time(R92)
;;;678        //SPI_PDMA_SetTx(RFIP_REG_91, ((uint32_t)(RFIP_init_reg+91)), 2);
;;;679        SPI_1BYT_SetTx(RFIP_REG_91,RFIP_init_reg[91]);
000112  2150              MOVS     r1,#0x50
000114  205b              MOVS     r0,#0x5b
000116  f7fffffe          BL       SPI_1BYT_SetTx
;;;680        SPI_1BYT_SetTx(RFIP_REG_91+1,RFIP_init_reg[92]);
00011a  2150              MOVS     r1,#0x50
00011c  205c              MOVS     r0,#0x5c
00011e  f7fffffe          BL       SPI_1BYT_SetTx
;;;681    #endif //(1)
;;;682    }
000122  bdf8              POP      {r3-r7,pc}
;;;683    
                          ENDP

                  |L50.292|
                          DCD      ||.bss||
                  |L50.296|
                          DCD      ||area_number.73||+0x18
                  |L50.300|
                          DCD      ||.constdata||+0x10

                          AREA ||i.rafael_reset_phy_fsm||, CODE, READONLY, ALIGN=2

                  rafael_reset_phy_fsm PROC
;;;534    extern uint8_t ram_Tab[48];
;;;535    void rafael_reset_phy_fsm(void)
000000  b570              PUSH     {r4-r6,lr}
;;;536    {
;;;537        uint8_t i;
;;;538    
;;;539        //RFIP_reg_MEM[RFIP_REG_MEM_121] |= 0x80;      //1: reset MAC state to READY
;;;540        //rafael_spi_write(spi_instance, 121, RFIP_init_reg+121, 1);
;;;541        while(1)
;;;542        {
;;;543            InterruptDisable();
;;;544            i = RFIP_reg_MEM[RFIP_REG_MEM_121];
000002  4d08              LDR      r5,|L51.36|
;;;545            InterruptEnable();
;;;546            SPI_1BYT_SetTx(RFIP_REG_121, (i|REG_121_RST_STATE));
000004  2680              MOVS     r6,#0x80
                  |L51.6|
000006  b672              CPSID    i                     ;543
000008  7aec              LDRB     r4,[r5,#0xb]          ;544  ; RFIP_reg_MEM
00000a  b662              CPSIE    i                     ;545
00000c  4621              MOV      r1,r4                 ;545
00000e  4331              ORRS     r1,r1,r6
000010  2079              MOVS     r0,#0x79
000012  f7fffffe          BL       SPI_1BYT_SetTx
;;;547            //Write 1 to end all TX & RX events and reset the MAC state to READY STATE, user must write 0 to this bit, so PMU state machine would go normally.
;;;548            //rafael_spi_write(spi_instance, 121, RFIP_init_reg+121, 1);
;;;549            InterruptDisable();
000016  b672              CPSID    i
;;;550            if(i == RFIP_reg_MEM[RFIP_REG_MEM_121])
000018  7ae8              LDRB     r0,[r5,#0xb]  ; RFIP_reg_MEM
00001a  42a0              CMP      r0,r4
;;;551            {
;;;552                InterruptEnable();
;;;553                break;
;;;554            }
;;;555            InterruptEnable();
00001c  b662              CPSIE    i
00001e  d1f2              BNE      |L51.6|
;;;556        }
;;;557    }
000020  bd70              POP      {r4-r6,pc}
;;;558    
                          ENDP

000022  0000              DCW      0x0000
                  |L51.36|
                          DCD      ||.bss||

                          AREA ||i.rafael_reset_phy_fsm_Isr||, CODE, READONLY, ALIGN=2

                  rafael_reset_phy_fsm_Isr PROC
;;;1080   //#pragma Ospace
;;;1081   void rafael_reset_phy_fsm_Isr(void)
000000  b510              PUSH     {r4,lr}
;;;1082   {
;;;1083       uint8_t i;
;;;1084       extern uint8_t RF_Msg_RF0INT;
;;;1085   
;;;1086       i = RFIP_reg_MEM[RFIP_REG_MEM_121];    //1: reset MAC state to READY
000002  4806              LDR      r0,|L52.28|
000004  7ac1              LDRB     r1,[r0,#0xb]  ; RFIP_reg_MEM
;;;1087       //RFIP_reg_MEM[RFIP_REG_MEM_121] |= 0x80;
;;;1088       //rafael_spi_write(spi_instance, 121, RFIP_init_reg+121, 1);
;;;1089       SPI_1BYT_SetTx_Isr(RFIP_REG_121, (i|REG_121_RST_STATE));
000006  2080              MOVS     r0,#0x80
000008  4301              ORRS     r1,r1,r0
00000a  2079              MOVS     r0,#0x79
00000c  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1090       RF_Msg_RF0INT &= (~(RF_MSG_RF0INT_WTR|RF_MSG_RF0INT_WTR_T));
000010  4803              LDR      r0,|L52.32|
000012  7801              LDRB     r1,[r0,#0]  ; RF_Msg_RF0INT
000014  0889              LSRS     r1,r1,#2
000016  0089              LSLS     r1,r1,#2
000018  7001              STRB     r1,[r0,#0]
;;;1091   
;;;1092       //Write 1 to end all TX & RX events and reset the MAC state to READY STATE, user must write 0 to this bit, so PMU state machine would go normally.
;;;1093       //rafael_spi_write(spi_instance, 121, RFIP_init_reg+121, 1);
;;;1094   #if 0
;;;1095       SPI_1BYT_SetTx_Isr(RFIP_REG_121, i);
;;;1096   #endif  //(0)
;;;1097   }
00001a  bd10              POP      {r4,pc}
;;;1098   
                          ENDP

                  |L52.28|
                          DCD      ||.bss||
                  |L52.32|
                          DCD      RF_Msg_RF0INT

                          AREA ||i.setChannel_BLE||, CODE, READONLY, ALIGN=2

                  setChannel_BLE PROC
;;;1099   
;;;1100   void setChannel_BLE(uint8_t ch)     //used in Isr
000000  b570              PUSH     {r4-r6,lr}
;;;1101   {
;;;1102       uint8_t i;
;;;1103   
;;;1104       i = RFIP_reg_MEM[RFIP_REG_MEM_121];
000002  4d06              LDR      r5,|L53.28|
000004  7ae9              LDRB     r1,[r5,#0xb]  ; RFIP_reg_MEM
;;;1105       //i = (i & 0xC0)|CH_SEL_TABLE[ch];
;;;1106       i = ((i & (~REG_121_MSK_CHN_IDX)) | (ch & REG_121_MSK_CHN_IDX));
000006  098c              LSRS     r4,r1,#6
000008  01a4              LSLS     r4,r4,#6
00000a  0680              LSLS     r0,r0,#26
00000c  0e80              LSRS     r0,r0,#26
00000e  4304              ORRS     r4,r4,r0
;;;1107       SPI_1BYT_SetTx_Isr(RFIP_REG_121, i);
000010  4621              MOV      r1,r4
000012  2079              MOVS     r0,#0x79
000014  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1108       RFIP_reg_MEM[RFIP_REG_MEM_121] = i;
000018  72ec              STRB     r4,[r5,#0xb]
;;;1109   }
00001a  bd70              POP      {r4-r6,pc}
;;;1110   
                          ENDP

                  |L53.28|
                          DCD      ||.bss||

                          AREA ||i.setMCU_WakeupRetentionTime||, CODE, READONLY, ALIGN=2

                  setMCU_WakeupRetentionTime PROC
;;;1945    */
;;;1946   BleStackStatus setMCU_WakeupRetentionTime(uint8_t retentionTime)
000000  4601              MOV      r1,r0
;;;1947   {
;;;1948       if(rf_initial_flag == ENABLE_)
000002  4807              LDR      r0,|L54.32|
000004  7800              LDRB     r0,[r0,#0]  ; rf_initial_flag
000006  2801              CMP      r0,#1
000008  d101              BNE      |L54.14|
;;;1949       {
;;;1950           return BLESTACK_STATUS_ERR_INVALID_STATE;
00000a  2004              MOVS     r0,#4
                  |L54.12|
;;;1951       }
;;;1952   
;;;1953       if((retentionTime < MCU_WAKEUP_RETENSIONTIME_MIN) ||
;;;1954               (MCU_WAKEUP_RETENSIONTIME_MIN > MCU_WAKEUP_RETENSIONTIME_MAX))
;;;1955       {
;;;1956           return BLESTACK_STATUS_ERR_INVALID_PARAM;
;;;1957       }
;;;1958   
;;;1959       LL_Tmr_Ticks_RSV_Wakeup = retentionTime; //value = 125us*(LL_Tmr_Ticks_RSV_Wakeup)
;;;1960   
;;;1961       return BLESTACK_STATUS_SUCCESS;
;;;1962   }
00000c  4770              BX       lr
                  |L54.14|
00000e  2901              CMP      r1,#1                 ;1953
000010  db00              BLT      |L54.20|
000012  e001              B        |L54.24|
                  |L54.20|
000014  2003              MOVS     r0,#3                 ;1956
000016  e7f9              B        |L54.12|
                  |L54.24|
000018  4802              LDR      r0,|L54.36|
00001a  7001              STRB     r1,[r0,#0]            ;1959
00001c  2000              MOVS     r0,#0                 ;1961
00001e  e7f5              B        |L54.12|
;;;1963   
                          ENDP

                  |L54.32|
                          DCD      rf_initial_flag
                  |L54.36|
                          DCD      LL_Tmr_Ticks_RSV_Wakeup

                          AREA ||i.setRF_Enable16MHzOutput||, CODE, READONLY, ALIGN=2

                  setRF_Enable16MHzOutput PROC
;;;796     */
;;;797    BleStackStatus setRF_Enable16MHzOutput(void)
000000  4804              LDR      r0,|L55.20|
;;;798    {
;;;799        if(rf_initial_flag == ENABLE_)
000002  7941              LDRB     r1,[r0,#5]  ; rf_initial_flag
000004  2901              CMP      r1,#1
000006  d003              BEQ      |L55.16|
;;;800        {
;;;801            return BLESTACK_STATUS_ERR_INVALID_STATE;
;;;802        }
;;;803    
;;;804        g16MHzClkOut = ENABLE_;
000008  2101              MOVS     r1,#1
00000a  7101              STRB     r1,[r0,#4]
;;;805        return BLESTACK_STATUS_SUCCESS;
00000c  2000              MOVS     r0,#0
;;;806    }
00000e  4770              BX       lr
                  |L55.16|
000010  2004              MOVS     r0,#4                 ;801
000012  4770              BX       lr
;;;807    
                          ENDP

                  |L55.20|
                          DCD      ||area_number.73||

                          AREA ||i.setRF_EnterDeepSleep||, CODE, READONLY, ALIGN=2

                  setRF_EnterDeepSleep PROC
;;;1794    */
;;;1795   BleStackStatus setRF_EnterDeepSleep(void)
000000  4815              LDR      r0,|L56.88|
;;;1796   {
;;;1797       extern void RF_External_Wakeup(void);
;;;1798       extern void RF_IntReset(void);
;;;1799       extern void RF_Enter_DeepSleep(void);
;;;1800       extern void rafael_reset_phy_fsm(void);
;;;1801   
;;;1802       if(g16MHzClkOut == ENABLE_)
000002  7900              LDRB     r0,[r0,#4]  ; g16MHzClkOut
000004  2801              CMP      r0,#1
000006  d101              BNE      |L56.12|
;;;1803       {
;;;1804           return BLESTACK_STATUS_ERR_INVALID_STATE;
000008  2004              MOVS     r0,#4
;;;1805       }
;;;1806   
;;;1807       InterruptDisable();
;;;1808       RF_External_Wakeup();
;;;1809       RF_IntReset();
;;;1810       rafael_reset_phy_fsm();
;;;1811       RF_Enter_DeepSleep();
;;;1812       InterruptEnable();
;;;1813   
;;;1814       return BLESTACK_STATUS_SUCCESS;
;;;1815   }
00000a  4770              BX       lr
                  |L56.12|
00000c  b570              PUSH     {r4-r6,lr}            ;1796
00000e  b672              CPSID    i                     ;1807
000010  f7fffffe          BL       RF_External_Wakeup
000014  2100              MOVS     r1,#0                 ;1808
000016  203d              MOVS     r0,#0x3d              ;1808
000018  f7fffffe          BL       SPI_1BYT_SetTx
00001c  21ff              MOVS     r1,#0xff              ;1808
00001e  203e              MOVS     r0,#0x3e              ;1808
000020  f7fffffe          BL       SPI_1BYT_SetTx
000024  f7fffffe          BL       rafael_reset_phy_fsm
000028  4d0c              LDR      r5,|L56.92|
00002a  78e9              LDRB     r1,[r5,#3]            ;1810  ; RFIP_reg_MEM
00002c  20e0              MOVS     r0,#0xe0              ;1810
00002e  4301              ORRS     r1,r1,r0              ;1810
000030  792c              LDRB     r4,[r5,#4]            ;1810  ; RFIP_reg_MEM
000032  2081              MOVS     r0,#0x81              ;1810
000034  4304              ORRS     r4,r4,r0              ;1810
000036  2029              MOVS     r0,#0x29              ;1810
000038  f7fffffe          BL       SPI_1BYT_SetTx
00003c  4621              MOV      r1,r4                 ;1810
00003e  202a              MOVS     r0,#0x2a              ;1810
000040  f7fffffe          BL       SPI_1BYT_SetTx
000044  7aa9              LDRB     r1,[r5,#0xa]          ;1810  ; RFIP_reg_MEM
000046  2082              MOVS     r0,#0x82              ;1810
000048  4301              ORRS     r1,r1,r0              ;1810
00004a  2078              MOVS     r0,#0x78              ;1810
00004c  f7fffffe          BL       SPI_1BYT_SetTx
000050  b662              CPSIE    i                     ;1812
000052  2000              MOVS     r0,#0                 ;1814
000054  bd70              POP      {r4-r6,pc}
;;;1816   
                          ENDP

000056  0000              DCW      0x0000
                  |L56.88|
                          DCD      ||area_number.73||
                  |L56.92|
                          DCD      ||.bss||

                          AREA ||i.setRF_WakeUpFromDeepSleep||, CODE, READONLY, ALIGN=2

                  setRF_WakeUpFromDeepSleep PROC
;;;1826    */
;;;1827   BleStackStatus setRF_WakeUpFromDeepSleep(void)
000000  4806              LDR      r0,|L57.28|
;;;1828   {
;;;1829       extern void RF_External_Wakeup(void);
;;;1830   
;;;1831       if(g16MHzClkOut == ENABLE_)
000002  7900              LDRB     r0,[r0,#4]  ; g16MHzClkOut
000004  2801              CMP      r0,#1
000006  d101              BNE      |L57.12|
;;;1832       {
;;;1833           return BLESTACK_STATUS_ERR_INVALID_STATE;
000008  2004              MOVS     r0,#4
;;;1834       }
;;;1835   
;;;1836       RF_External_Wakeup();
;;;1837       RF_Init();                   //EnableGpioInterrupt in the end of this function
;;;1838   
;;;1839       return BLESTACK_STATUS_SUCCESS;
;;;1840   }
00000a  4770              BX       lr
                  |L57.12|
00000c  b510              PUSH     {r4,lr}               ;1828
00000e  f7fffffe          BL       RF_External_Wakeup
000012  f7fffffe          BL       RF_Init
000016  2000              MOVS     r0,#0                 ;1839
000018  bd10              POP      {r4,pc}
;;;1841   
                          ENDP

00001a  0000              DCW      0x0000
                  |L57.28|
                          DCD      ||area_number.73||

                          AREA ||i.smpAES_En||, CODE, READONLY, ALIGN=1

                  smpAES_En PROC
;;;1377   
;;;1378   void smpAES_En(void)
000000  b510              PUSH     {r4,lr}
;;;1379   {
;;;1380       SPI_1BYT_SetTx_Isr(RFIP_REG_155, REG_155_AES128_ENABLE|REG_155_AES_MODE_LOCAL_AES_ECB);
000002  210e              MOVS     r1,#0xe
000004  209b              MOVS     r0,#0x9b
000006  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1381   }
00000a  bd10              POP      {r4,pc}
;;;1382   
                          ENDP


                          AREA ||i.smpAES_inInv||, CODE, READONLY, ALIGN=2

                  smpAES_inInv PROC
;;;1383   
;;;1384   void smpAES_inInv(Uint8 * key, Uint8 * plaintextData)
000000  b510              PUSH     {r4,lr}
;;;1385   {
000002  b084              SUB      sp,sp,#0x10
000004  460c              MOV      r4,r1
;;;1386       Uint8 i[LEN_AES_KEY];
;;;1387   
;;;1388       Knl_MemCpyInv_Isr(i, key, LEN_AES_KEY);
000006  2210              MOVS     r2,#0x10
000008  4601              MOV      r1,r0
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       Knl_MemCpyInv_Isr
;;;1389       smpAES_in_key(i);
000010  4669              MOV      r1,sp
000012  2210              MOVS     r2,#0x10
000014  208b              MOVS     r0,#0x8b
000016  f7fffffe          BL       SPI_PDMA_SetTx
;;;1390   
;;;1391       SPI_PDMA_waitFinish();
00001a  f7fffffe          BL       SPI_PDMA_waitFinish
;;;1392       Knl_MemCpyInv_Isr(i, plaintextData, LEN_AES_KEY);
00001e  2210              MOVS     r2,#0x10
000020  4621              MOV      r1,r4
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       Knl_MemCpyInv_Isr
;;;1393       smpAES_in_PlainText(i);
000028  4669              MOV      r1,sp
00002a  2000              MOVS     r0,#0
00002c  4a05              LDR      r2,|L59.68|
00002e  6150              STR      r0,[r2,#0x14]  ; addr_TxFIFO
000030  2210              MOVS     r2,#0x10
000032  20fe              MOVS     r0,#0xfe
000034  f7fffffe          BL       SPI_PDMA_SetTx
000038  210e              MOVS     r1,#0xe
00003a  209b              MOVS     r0,#0x9b
00003c  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1394       smpAES_En();
;;;1395   }
000040  b004              ADD      sp,sp,#0x10
000042  bd10              POP      {r4,pc}
;;;1396   
                          ENDP

                  |L59.68|
                          DCD      ||area_number.73||

                          AREA ||i.smpAES_in_PlainText||, CODE, READONLY, ALIGN=2

                  smpAES_in_PlainText PROC
;;;1370   
;;;1371   void smpAES_in_PlainText(Uint8 * plaintextData)
000000  b510              PUSH     {r4,lr}
;;;1372   {
;;;1373       addr_TxFIFO = 0;
000002  2200              MOVS     r2,#0
000004  4b03              LDR      r3,|L60.20|
;;;1374       SPI_PDMA_SetTx(TX_BUFFER_WRITE_PORT, (uint32_t)plaintextData, LEN_AES_KEY);
000006  615a              STR      r2,[r3,#0x14]  ; addr_TxFIFO
000008  2210              MOVS     r2,#0x10
00000a  4601              MOV      r1,r0
00000c  20fe              MOVS     r0,#0xfe
00000e  f7fffffe          BL       SPI_PDMA_SetTx
;;;1375   }
000012  bd10              POP      {r4,pc}
;;;1376   
                          ENDP

                  |L60.20|
                          DCD      ||area_number.73||

                          AREA ||i.smpAES_in_key||, CODE, READONLY, ALIGN=1

                  smpAES_in_key PROC
;;;1364   
;;;1365   void smpAES_in_key(Uint8 * key)
000000  b510              PUSH     {r4,lr}
;;;1366   {
;;;1367       SPI_PDMA_SetTx(RFIP_REG_139, (uint32_t)key, LEN_AES_KEY);
000002  2210              MOVS     r2,#0x10
000004  4601              MOV      r1,r0
000006  208b              MOVS     r0,#0x8b
000008  f7fffffe          BL       SPI_PDMA_SetTx
;;;1368   }
00000c  bd10              POP      {r4,pc}
;;;1369   
                          ENDP


                          AREA ||i.smpAES_out||, CODE, READONLY, ALIGN=1

                  smpAES_out PROC
;;;1397   
;;;1398   void smpAES_out(Uint8 * encDataOut)
000000  b510              PUSH     {r4,lr}
;;;1399   {
000002  4604              MOV      r4,r0
                  |L62.4|
;;;1400       //__NOP();
;;;1401       while((SPI_1BYT_SetRx_Isr(RFIP_REG_155)&REG_155_AES_BUSY));
000004  209b              MOVS     r0,#0x9b
000006  f7fffffe          BL       SPI_1BYT_SetRx_Isr
00000a  0640              LSLS     r0,r0,#25
00000c  d4fa              BMI      |L62.4|
;;;1402       SPI_PDMA_SetRx_Isr(RX_BUFFER_READ_PORT, (uint32_t)encDataOut, LEN_AES_KEY);
00000e  2210              MOVS     r2,#0x10
000010  4621              MOV      r1,r4
000012  20ff              MOVS     r0,#0xff
000014  f7fffffe          BL       SPI_PDMA_SetRx_Isr
;;;1403       SPI_1BYT_SetTx_Isr(RFIP_REG_155, REG_155_AES_MODE_BYPASS);
000018  2100              MOVS     r1,#0
00001a  209b              MOVS     r0,#0x9b
00001c  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1404   }
000020  bd10              POP      {r4,pc}
;;;1405   
                          ENDP


                          AREA ||i.smpAES_outInv||, CODE, READONLY, ALIGN=1

                  smpAES_outInv PROC
;;;1406   
;;;1407   void smpAES_outInv(Uint8 * encDataOut)
000000  b510              PUSH     {r4,lr}
;;;1408   {
000002  b084              SUB      sp,sp,#0x10
000004  4604              MOV      r4,r0
                  |L63.6|
;;;1409       //__NOP();
;;;1410       Uint8 i[LEN_AES_KEY];
;;;1411   
;;;1412       while((SPI_1BYT_SetRx_Isr(RFIP_REG_155)&REG_155_AES_BUSY));
000006  209b              MOVS     r0,#0x9b
000008  f7fffffe          BL       SPI_1BYT_SetRx_Isr
00000c  0640              LSLS     r0,r0,#25
00000e  d4fa              BMI      |L63.6|
;;;1413       SPI_PDMA_SetRx_Isr(RX_BUFFER_READ_PORT, (uint32_t)i, LEN_AES_KEY);
000010  2210              MOVS     r2,#0x10
000012  4669              MOV      r1,sp
000014  20ff              MOVS     r0,#0xff
000016  f7fffffe          BL       SPI_PDMA_SetRx_Isr
;;;1414       SPI_1BYT_SetTx_Isr(RFIP_REG_155, REG_155_AES_MODE_BYPASS);
00001a  2100              MOVS     r1,#0
00001c  209b              MOVS     r0,#0x9b
00001e  f7fffffe          BL       SPI_1BYT_SetTx_Isr
;;;1415       Knl_MemCpyInv_Isr(encDataOut, i, LEN_AES_KEY);
000022  2210              MOVS     r2,#0x10
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       Knl_MemCpyInv_Isr
;;;1416   }
00002c  b004              ADD      sp,sp,#0x10
00002e  bd10              POP      {r4,pc}
;;;1417   
                          ENDP


                          AREA ||i.testFunc||, CODE, READONLY, ALIGN=1

                  testFunc PROC
;;;1867   //#pragma Ospace
;;;1868   void testFunc(Uint8 id_testFunc)
000000  2803              CMP      r0,#3
;;;1869   {
;;;1870       extern LL_Conn         LL_Conn_Para[MAX_NUM_CONN_HDL];
;;;1871       //uint8_t i;
;;;1872       //uint8_t *pi;
;;;1873       /*
;;;1874       const uint8_t testA[] = {0x11, 0x22, 0x33, 0x05};
;;;1875       uint32_t u32i;
;;;1876       uint8_t test[4];
;;;1877       */
;;;1878       //MBLK *mblk;
;;;1879   
;;;1880       extern LL_Adv          LL_Adv_Para;
;;;1881       extern LL_Scan         LL_Scan_Para;
;;;1882       extern LL_Conn         LL_Conn_Para[MAX_NUM_CONN_HDL];
;;;1883       extern MQUEUE          LL_ConnDataQ[MAX_NUM_CONN_HDL];
;;;1884       extern LL_Init         LL_Init_Para;
;;;1885       extern LL_WhiteList    LL_WhiteList_Para[SIZE_WHITE_LIST_ENTRIES];
;;;1886       extern LL_Para_Itrvl   LL_Para_Interval;
;;;1887       //struct Conn_Req_Para connReqRx;
;;;1888       //struct Conn_Req_Para_Alt connReqTx;
;;;1889   
;;;1890       switch(id_testFunc)
000002  d100              BNE      |L64.6|
;;;1891       {
;;;1892       case ID_TESTFUNC_RAFAEL:
;;;1893           break;
000004  e000              B        |L64.8|
                  |L64.6|
;;;1894   
;;;1895       default:
;;;1896           break;
000006  bf00              NOP      
                  |L64.8|
000008  bf00              NOP                            ;1893
;;;1897       }
;;;1898   }
00000a  4770              BX       lr
;;;1899   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  RFIP_reg_MEM
                          %        13
                  CH_PLL_bank_Table
                          %        40

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  txpower_0dbm_reg
000000  4281402a          DCB      0x42,0x81,0x40,0x2a
                  txpower_4dbm_reg
000004  82a45a05          DCB      0x82,0xa4,0x5a,0x05
                  txpower_8dbm_reg
000008  d28e7a05          DCB      0xd2,0x8e,0x7a,0x05
                  txpower_10dbm_reg
00000c  c28f7a05          DCB      0xc2,0x8f,0x7a,0x05
                  Phy_pll_bank_freqIdx
000010  2509121c          DCB      0x25,0x09,0x12,0x1c
000014  27                DCB      0x27
                  RFIP_init_reg
000015  000000            DCB      0x00,0x00,0x00
000018  00000000          DCB      0x00,0x00,0x00,0x00
00001c  001c80df          DCB      0x00,0x1c,0x80,0xdf
000020  a4e0f37f          DCB      0xa4,0xe0,0xf3,0x7f
000024  052110f0          DCB      0x05,0x21,0x10,0xf0
000028  a03fbbef          DCB      0xa0,0x3f,0xbb,0xef
00002c  d28e7a05          DCB      0xd2,0x8e,0x7a,0x05
000030  80ffffff          DCB      0x80,0xff,0xff,0xff
000034  27620070          DCB      0x27,0x62,0x00,0x70
000038  d288ac91          DCB      0xd2,0x88,0xac,0x91
00003c  dec01460          DCB      0xde,0xc0,0x14,0x60
000040  62fc3f6a          DCB      0x62,0xfc,0x3f,0x6a
000044  01000000          DCB      0x01,0x00,0x00,0x00
000048  000000f0          DCB      0x00,0x00,0x00,0xf0
00004c  000006a2          DCB      0x00,0x00,0x06,0xa2
000050  6a0000ff          DCB      0x6a,0x00,0x00,0xff
000054  7970d2ea          DCB      0x79,0x70,0xd2,0xea
000058  0a1e0a23          DCB      0x0a,0x1e,0x0a,0x23
00005c  00a01f55          DCB      0x00,0xa0,0x1f,0x55
000060  a1004400          DCB      0xa1,0x00,0x44,0x00
000064  5200061e          DCB      0x52,0x00,0x06,0x1e
000068  1e00068e          DCB      0x1e,0x00,0x06,0x8e
00006c  24014400          DCB      0x24,0x01,0x44,0x00
000070  50500111          DCB      0x50,0x50,0x01,0x11
000074  fff86000          DCB      0xff,0xf8,0x60,0x00
000078  00000000          DCB      0x00,0x00,0x00,0x00
00007c  00008000          DCB      0x00,0x00,0x80,0x00
000080  00000000          DCB      0x00,0x00,0x00,0x00
000084  00555555          DCB      0x00,0x55,0x55,0x55
000088  ffff4f00          DCB      0xff,0xff,0x4f,0x00
00008c  00040029          DCB      0x00,0x04,0x00,0x29
000090  41767100          DCB      0x41,0x76,0x71,0x00
000094  00                DCB      0x00
                  RFIP_REG_IDX
000095  172428            DCB      0x17,0x24,0x28
000098  292a2b39          DCB      0x29,0x2a,0x2b,0x39
00009c  3d6b7778          DCB      0x3d,0x6b,0x77,0x78
0000a0  79a6              DCB      0x79,0xa6
                  CH_SEL_TABLE_INV
0000a2  2500              DCB      0x25,0x00
0000a4  01020304          DCB      0x01,0x02,0x03,0x04
0000a8  05060708          DCB      0x05,0x06,0x07,0x08
0000ac  090a260b          DCB      0x09,0x0a,0x26,0x0b
0000b0  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f
0000b4  10111213          DCB      0x10,0x11,0x12,0x13
0000b8  14151617          DCB      0x14,0x15,0x16,0x17
0000bc  18191a1b          DCB      0x18,0x19,0x1a,0x1b
0000c0  1c1d1e1f          DCB      0x1c,0x1d,0x1e,0x1f
0000c4  20212223          DCB      0x20,0x21,0x22,0x23
0000c8  2427              DCB      0x24,0x27
                  R568_lna_agc
0000ca  0000              DCW      0x0000
0000cc  00db01ce          DCW      0x00db,0x01ce
0000d0  02cd03b0          DCW      0x02cd,0x03b0
0000d4  04a705e0          DCW      0x04a7,0x05e0
0000d8  06f907c2          DCW      0x06f9,0x07c2
0000dc  08b70971          DCW      0x08b7,0x0971
0000e0  0ae80c6e          DCW      0x0ae8,0x0c6e
0000e4  0d720e23          DCW      0x0d72,0x0e23
0000e8  0e8c              DCW      0x0e8c
                  R568_tia_agc
0000ea  0000              DCW      0x0000
0000ec  018102f6          DCW      0x0181,0x02f6
0000f0  048905f6          DCW      0x0489,0x05f6
0000f4  077a0779          DCW      0x077a,0x0779
0000f8  09000a97          DCW      0x0900,0x0a97
0000fc  0c2c0db9          DCW      0x0c2c,0x0db9
000100  0f4a10df          DCW      0x0f4a,0x10df
000104  128c128d          DCW      0x128c,0x128d
000108  128d              DCW      0x128d
                  R568_vga_agc
00010a  0000              DCW      0x0000
00010c  017b02f5          DCW      0x017b,0x02f5
000110  047b05e7          DCW      0x047b,0x05e7
000114  075c09f7          DCW      0x075c,0x09f7
000118  0a380ba0          DCW      0x0a38,0x0ba0
00011c  0cf80e45          DCW      0x0cf8,0x0e45
000120  0f771091          DCW      0x0f77,0x1091
000124  11881189          DCW      0x1188,0x1189
000128  118b              DCW      0x118b

                          AREA ||area_number.69||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.69||, ||.constdata||
                  TIMELINE24_3750US_IDX
000000  0f1e2d3c          DCB      0x0f,0x1e,0x2d,0x3c
000004  4b5a6978          DCB      0x4b,0x5a,0x69,0x78
000008  8796a5b4          DCB      0x87,0x96,0xa5,0xb4
00000c  c3d2e1f0          DCB      0xc3,0xd2,0xe1,0xf0
000010  ff                DCB      0xff

                          AREA ||area_number.70||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.70||, ||.constdata||
                  TAB_4_FIFO_CLR
000000  00800080          DCB      0x00,0x80,0x00,0x80

                          AREA ||area_number.71||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.71||, ||.constdata||
                  CH_SEL_TABLE
000000  01020304          DCB      0x01,0x02,0x03,0x04
000004  05060708          DCB      0x05,0x06,0x07,0x08
000008  090a0b0d          DCB      0x09,0x0a,0x0b,0x0d
00000c  0e0f1011          DCB      0x0e,0x0f,0x10,0x11
000010  12131415          DCB      0x12,0x13,0x14,0x15
000014  16171819          DCB      0x16,0x17,0x18,0x19
000018  1a1b1c1d          DCB      0x1a,0x1b,0x1c,0x1d
00001c  1e1f2021          DCB      0x1e,0x1f,0x20,0x21
000020  22232425          DCB      0x22,0x23,0x24,0x25
000024  26000c27          DCB      0x26,0x00,0x0c,0x27

                          AREA ||.data||, DATA, ALIGN=0

                  ChipVer
000000  66                DCB      0x66

                          AREA ||area_number.73||, DATA, ALIGN=2

                          EXPORTAS ||area_number.73||, ||.data||
                  RfVolt_new
000000  01                DCB      0x01
                  Content_ioInt
000001  00                DCB      0x00
                  Content_ioInt_exceptTmr
000002  00                DCB      0x00
                  rssiOffsetValue
000003  1a                DCB      0x1a
                  g16MHzClkOut
000004  00                DCB      0x00
                  rf_initial_flag
000005  00                DCB      0x00
                  gSleep
000006  00                DCB      0x00
                  LL_Tmr_Ticks_RSV_Wakeup
000007  05                DCB      0x05
                  pll_cal_done_flag
000008  00                DCB      0x00
                  rssi_read_data
000009  000000            DCB      0x00,0x00,0x00
                  Timeline24
                          DCD      0x00000000
                  Tmr16Interval
                          DCD      0x00000000
                  addr_TxFIFO
                          DCD      0x00000000
                  Phy_pll_bank
000018  20202020          DCB      0x20,0x20,0x20,0x20
00001c  2000              DCB      0x20,0x00
                  pll_freq_mhz
00001e  0962              DCW      0x0962
000020  0976098a          DCW      0x0976,0x098a
000024  099e09b0          DCW      0x099e,0x09b0

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\rf_phy.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_rf_phy_c_ChipVer____REV16|
#line 388 "..\\..\\..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_rf_phy_c_ChipVer____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_rf_phy_c_ChipVer____REVSH|
#line 402
|__asm___8_rf_phy_c_ChipVer____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
