; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\porting_spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\porting_spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\include -I..\..\..\porting -I..\..\..\include\rf_include -I..\..\..\porting\rf_porting -I..\..\SLT_Demo -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\porting_spi.crf ..\..\..\porting\porting_spi.c]
                          THUMB

                          AREA ||i.MCU_SpiInit||, CODE, READONLY, ALIGN=2

                  MCU_SpiInit PROC
;;;23     //Initial SPI clock and pin
;;;24     void MCU_SpiInit(void)
000000  b538              PUSH     {r3-r5,lr}
;;;25     {
;;;26         /* Select PCLK1 as the clock source of SPI0*/
;;;27         CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
000002  4c11              LDR      r4,|L1.72|
000004  2200              MOVS     r2,#0
000006  2120              MOVS     r1,#0x20
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       CLK_SetModuleClock
;;;28         /* Enable SPI0 peripheral clock */
;;;29         CLK_EnableModuleClock(SPI0_MODULE);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       CLK_EnableModuleClock
;;;30         /* Enable PDMA clock source */
;;;31         CLK_EnableModuleClock(PDMA_MODULE);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       CLK_EnableModuleClock
;;;32     
;;;33         /* MCU SPI pin initialization */
;;;34     #if ((_BOARD_SELECTION_ == _BOARD_NUVOTON_M031SE_) || (_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_) || (_BOARD_SELECTION_ == _BOARD_NUVOTON_M487JIDAE_B3_) || (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031TD2AE_QFN33_))
;;;35         // Setup SPI0 multi-function pins //
;;;36         // PA.3 is SPI0_SS,   PA.2 is SPI0_CLK,
;;;37         // PA.1 is SPI0_MISO, PA.0 is SPI0_MOSI
;;;38         SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA3MFP_Msk |
00001a  07a0              LSLS     r0,r4,#30
00001c  6b01              LDR      r1,[r0,#0x30]
00001e  4a0b              LDR      r2,|L1.76|
000020  0c09              LSRS     r1,r1,#16
000022  0409              LSLS     r1,r1,#16
000024  1889              ADDS     r1,r1,r2
000026  6301              STR      r1,[r0,#0x30]
;;;39                                            SYS_GPA_MFPL_PA2MFP_Msk |
;;;40                                            SYS_GPA_MFPL_PA1MFP_Msk |
;;;41                                            SYS_GPA_MFPL_PA0MFP_Msk)) |
;;;42                         (SYS_GPA_MFPL_PA3MFP_SPI0_SS |
;;;43                          SYS_GPA_MFPL_PA2MFP_SPI0_CLK |
;;;44                          SYS_GPA_MFPL_PA1MFP_SPI0_MISO |
;;;45                          SYS_GPA_MFPL_PA0MFP_SPI0_MOSI);
;;;46     #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031_SIP_)    //SIP
;;;47     
;;;48         SYS->GPD_MFPL = (SYS->GPD_MFPL & ~(SYS_GPD_MFPL_PD3MFP_Msk |
;;;49                                            SYS_GPD_MFPL_PD2MFP_Msk |
;;;50                                            SYS_GPD_MFPL_PD1MFP_Msk |
;;;51                                            SYS_GPD_MFPL_PD0MFP_Msk)) |
;;;52                         (SYS_GPD_MFPL_PD3MFP_SPI0_SS   |
;;;53                          SYS_GPD_MFPL_PD2MFP_SPI0_CLK  |
;;;54                          SYS_GPD_MFPL_PD1MFP_SPI0_MISO |
;;;55                          SYS_GPD_MFPL_PD0MFP_SPI0_MOSI);
;;;56     
;;;57     #endif  //_BOARD_SELECTION_
;;;58     
;;;59         /* SPI master, clk=8M, mode 0, 8-bit, MSB first */
;;;60         SPI_Open(SPI0, SPI_MASTER, SPI_MODE_0, 8, SPI_CLK_FREQ);
000028  4809              LDR      r0,|L1.80|
00002a  4c0a              LDR      r4,|L1.84|
00002c  9000              STR      r0,[sp,#0]
00002e  2308              MOVS     r3,#8
000030  2204              MOVS     r2,#4
000032  2100              MOVS     r1,#0
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       SPI_Open
;;;61     
;;;62         /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active */
;;;63         SPI_EnableAutoSS(SPI0, SPI_SS, SPI_SS_ACTIVE_LOW);
00003a  2200              MOVS     r2,#0
00003c  2101              MOVS     r1,#1
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       SPI_EnableAutoSS
;;;64     }
000044  bd38              POP      {r3-r5,pc}
;;;65     
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      0x6640000d
                  |L1.76|
                          DCD      0x00004444
                  |L1.80|
                          DCD      0x00b71b00
                  |L1.84|
                          DCD      0x40061000

                          AREA ||i.SPI_1BYT_SetRx||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetRx PROC
;;;72     // Read RF 1 byte register
;;;73     uint8_t SPI_1BYT_SetRx(uint8_t regAddr)
000000  b410              PUSH     {r4}
;;;74     {
;;;75         uint32_t u32i;
;;;76     
;;;77         while(1)
;;;78         {
;;;79             InterruptDisable();
;;;80             if(SPI_IS_BUSY(SPI0)==0)      //if(SPI is free)
000002  491b              LDR      r1,|L2.112|
                  |L2.4|
000004  b672              CPSID    i                     ;79
000006  694a              LDR      r2,[r1,#0x14]
000008  07d2              LSLS     r2,r2,#31
00000a  d001              BEQ      |L2.16|
;;;81             {
;;;82                 SPI0_ClearRxFIFO();
;;;83                 SPI_WRITE_TX(SPI0, (regAddr|0x80));            //write 1st byte: (regAddr & 0x7F) | 0x80
;;;84                 SPI_DISABLE_RX_PDMA(SPI0);
;;;85                 if((regAddr&0x80))
;;;86                 {
;;;87                     SPI_WRITE_TX(SPI0, 0x01);                  //write 2nd byte: (regAddr & 0x80)>>7
;;;88                 }
;;;89                 else
;;;90                 {
;;;91                     SPI_WRITE_TX(SPI0, 0x00);
;;;92                 }
;;;93                 if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
;;;94                 {
;;;95                     u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
;;;96                     if(u32i)                                   //Check the PDMA transfer done flags
;;;97                     {
;;;98                         PDMA_CLR_TD_FLAG(PDMA, u32i);          //Clear the PDMA transfer done flags
;;;99                     }
;;;100                }
;;;101                break;
;;;102            }
;;;103            else
;;;104            {
;;;105                // printf("assert!");
;;;106            }
;;;107            InterruptEnable();
00000c  b662              CPSIE    i
00000e  e7f9              B        |L2.4|
                  |L2.16|
000010  690b              LDR      r3,[r1,#0x10]         ;82
000012  22ff              MOVS     r2,#0xff              ;82
000014  3201              ADDS     r2,#1                 ;82
000016  4313              ORRS     r3,r3,r2              ;82
000018  610b              STR      r3,[r1,#0x10]         ;82
00001a  2380              MOVS     r3,#0x80              ;83
00001c  4303              ORRS     r3,r3,r0              ;83
00001e  620b              STR      r3,[r1,#0x20]         ;83
000020  68cb              LDR      r3,[r1,#0xc]          ;84
000022  2402              MOVS     r4,#2                 ;84
000024  43a3              BICS     r3,r3,r4              ;84
000026  60cb              STR      r3,[r1,#0xc]          ;84
000028  0600              LSLS     r0,r0,#24             ;85
00002a  d501              BPL      |L2.48|
00002c  2001              MOVS     r0,#1                 ;87
00002e  e000              B        |L2.50|
                  |L2.48|
000030  2000              MOVS     r0,#0                 ;91
                  |L2.50|
000032  6208              STR      r0,[r1,#0x20]         ;91
000034  4b0f              LDR      r3,|L2.116|
000036  69d8              LDR      r0,[r3,#0x1c]         ;93
000038  4c0f              LDR      r4,|L2.120|
00003a  4220              TST      r0,r4                 ;93
00003c  d004              BEQ      |L2.72|
00003e  6a58              LDR      r0,[r3,#0x24]         ;95
000040  2418              MOVS     r4,#0x18              ;95
000042  4020              ANDS     r0,r0,r4              ;95
000044  d000              BEQ      |L2.72|
000046  6258              STR      r0,[r3,#0x24]         ;98
                  |L2.72|
;;;108        }
;;;109    
;;;110        SPI_WRITE_TX(SPI0, 0xFF);        //1 more dummy byte
000048  20ff              MOVS     r0,#0xff
00004a  6208              STR      r0,[r1,#0x20]
;;;111        SPI_WRITE_TX(SPI0, 0xF5);        //write 1 dummy byte to read 1 byte data
00004c  20f5              MOVS     r0,#0xf5
00004e  6208              STR      r0,[r1,#0x20]
                  |L2.80|
;;;112    
;;;113        while(SPI_GET_RX_FIFO_COUNT(SPI0)!=4);
000050  6948              LDR      r0,[r1,#0x14]
;;;114        SPI_READ_RX(SPI0);
;;;115        SPI_READ_RX(SPI0);
;;;116        SPI_READ_RX(SPI0);
;;;117        u32i = SPI_READ_RX(SPI0);
;;;118    
;;;119        SPI0_ClearRxFIFO();
;;;120        InterruptEnable();
;;;121        return (uint8_t)u32i;
;;;122    }
000052  0100              LSLS     r0,r0,#4
000054  0f00              LSRS     r0,r0,#28
000056  2804              CMP      r0,#4                 ;113
000058  d1fa              BNE      |L2.80|
00005a  6b08              LDR      r0,[r1,#0x30]         ;114
00005c  6b08              LDR      r0,[r1,#0x30]         ;115
00005e  6b08              LDR      r0,[r1,#0x30]         ;116
000060  6b08              LDR      r0,[r1,#0x30]         ;117
000062  690b              LDR      r3,[r1,#0x10]         ;119
000064  4313              ORRS     r3,r3,r2              ;119
000066  610b              STR      r3,[r1,#0x10]         ;119
000068  b662              CPSIE    i                     ;120
00006a  b2c0              UXTB     r0,r0                 ;121
00006c  bc10              POP      {r4}
00006e  4770              BX       lr
;;;123    
                          ENDP

                  |L2.112|
                          DCD      0x40061000
                  |L2.116|
                          DCD      0x40008400
                  |L2.120|
                          DCD      0x00000303

                          AREA ||i.SPI_1BYT_SetRx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetRx_Isr PROC
;;;124    // Read RF 1 byte register or RX_FIFO in ISR
;;;125    uint8_t SPI_1BYT_SetRx_Isr(uint8_t regAddr)
000000  b430              PUSH     {r4,r5}
;;;126    {
;;;127        uint32_t u32i;
;;;128    
;;;129        while(1)
;;;130        {
;;;131            if(SPI_IS_BUSY(SPI0)==0)
000002  491f              LDR      r1,|L3.128|
                  |L3.4|
000004  694a              LDR      r2,[r1,#0x14]
000006  07d2              LSLS     r2,r2,#31
000008  d1fc              BNE      |L3.4|
;;;132            {
;;;133                SPI0_ClearRxFIFO();
00000a  690b              LDR      r3,[r1,#0x10]
00000c  22ff              MOVS     r2,#0xff
00000e  3201              ADDS     r2,#1
000010  4313              ORRS     r3,r3,r2
000012  610b              STR      r3,[r1,#0x10]
;;;134                SPI_WRITE_TX(SPI0, (regAddr|0x80));        //write 1st byte: (regAddr & 0x7F) | 0x80
000014  2380              MOVS     r3,#0x80
000016  4303              ORRS     r3,r3,r0
000018  620b              STR      r3,[r1,#0x20]
;;;135                SPI_DISABLE_RX_PDMA(SPI0);
00001a  68cb              LDR      r3,[r1,#0xc]
00001c  2402              MOVS     r4,#2
00001e  43a3              BICS     r3,r3,r4
000020  60cb              STR      r3,[r1,#0xc]
;;;136                if((regAddr&0x80))
000022  0603              LSLS     r3,r0,#24
000024  d501              BPL      |L3.42|
;;;137                {
;;;138                    SPI_WRITE_TX(SPI0, 0x01);              //write 2nd byte: (regAddr & 0x80)>>7
000026  2301              MOVS     r3,#1
000028  e000              B        |L3.44|
                  |L3.42|
;;;139                }
;;;140                else
;;;141                {
;;;142                    SPI_WRITE_TX(SPI0, 0x00);
00002a  2300              MOVS     r3,#0
                  |L3.44|
00002c  620b              STR      r3,[r1,#0x20]
;;;143                }
;;;144                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00002e  4c15              LDR      r4,|L3.132|
000030  69e3              LDR      r3,[r4,#0x1c]
000032  4d15              LDR      r5,|L3.136|
000034  422b              TST      r3,r5
000036  d004              BEQ      |L3.66|
;;;145                {
;;;146                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000038  6a63              LDR      r3,[r4,#0x24]
00003a  2518              MOVS     r5,#0x18
00003c  402b              ANDS     r3,r3,r5
;;;147                    if(u32i)                                //Check the PDMA transfer done flags
00003e  d000              BEQ      |L3.66|
;;;148                    {
;;;149                        PDMA_CLR_TD_FLAG(PDMA, u32i);       //Clear the PDMA transfer done flags
000040  6263              STR      r3,[r4,#0x24]
                  |L3.66|
000042  23ff              MOVS     r3,#0xff              ;126
;;;150                    }
;;;151                }
;;;152                break;
;;;153            }
;;;154            else
;;;155            {
;;;156                //printf("assert!");
;;;157            }
;;;158        }
;;;159    
;;;160        if(regAddr==RX_BUFFER_READ_PORT)   //read RX_FIFO
;;;161        {
;;;162            SPI_WRITE_TX(SPI0, 0xFF);                 //1 more dummy byte for MP read RX_FIFO
;;;163            SPI_WRITE_TX(SPI0, 0xFF);                 //1 more dummy byte for MP read RX_FIFO
;;;164    
;;;165            SPI_WRITE_TX(SPI0, 0xF5);                 //write 1 dummy byte to read 1 byte data
000044  24f5              MOVS     r4,#0xf5
000046  28ff              CMP      r0,#0xff              ;160
;;;166    
;;;167            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=5);
;;;168            SPI_READ_RX(SPI0);
;;;169            SPI_READ_RX(SPI0);
;;;170            SPI_READ_RX(SPI0);
;;;171            SPI_READ_RX(SPI0);
;;;172        }
;;;173        else            //read register
;;;174        {
;;;175            SPI_WRITE_TX(SPI0, 0xFF);                 //1 more dummy byte for MP read register
000048  620b              STR      r3,[r1,#0x20]
00004a  d00f              BEQ      |L3.108|
;;;176    
;;;177            SPI_WRITE_TX(SPI0, 0xF5);                 //write 1 dummy byte to read 1 byte data
00004c  620c              STR      r4,[r1,#0x20]
                  |L3.78|
;;;178    
;;;179            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=4);
00004e  6948              LDR      r0,[r1,#0x14]
;;;180            SPI_READ_RX(SPI0);
;;;181            SPI_READ_RX(SPI0);
;;;182            SPI_READ_RX(SPI0);
;;;183        }
;;;184    
;;;185        u32i = SPI_READ_RX(SPI0);
;;;186        SPI0_ClearRxFIFO();
;;;187    
;;;188        return (uint8_t)u32i;
;;;189    }
000050  0100              LSLS     r0,r0,#4
000052  0f00              LSRS     r0,r0,#28
000054  2804              CMP      r0,#4                 ;179
000056  d1fa              BNE      |L3.78|
                  |L3.88|
000058  6b08              LDR      r0,[r1,#0x30]         ;180
00005a  6b08              LDR      r0,[r1,#0x30]         ;181
00005c  6b08              LDR      r0,[r1,#0x30]         ;182
00005e  6b08              LDR      r0,[r1,#0x30]         ;185
000060  690b              LDR      r3,[r1,#0x10]         ;186
000062  4313              ORRS     r3,r3,r2              ;186
000064  610b              STR      r3,[r1,#0x10]         ;186
000066  bc30              POP      {r4,r5}
000068  b2c0              UXTB     r0,r0                 ;188
00006a  4770              BX       lr
                  |L3.108|
00006c  620b              STR      r3,[r1,#0x20]         ;163
00006e  620c              STR      r4,[r1,#0x20]         ;165
                  |L3.112|
000070  6948              LDR      r0,[r1,#0x14]         ;167
000072  0100              LSLS     r0,r0,#4
000074  0f00              LSRS     r0,r0,#28
000076  2805              CMP      r0,#5                 ;167
000078  d1fa              BNE      |L3.112|
00007a  6b08              LDR      r0,[r1,#0x30]         ;168
00007c  e7ec              B        |L3.88|
;;;190    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
                          DCD      0x40061000
                  |L3.132|
                          DCD      0x40008400
                  |L3.136|
                          DCD      0x00000303

                          AREA ||i.SPI_1BYT_SetTx||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetTx PROC
;;;191    // Write RF 1 byte register (not use for writing TX buffer)
;;;192    void SPI_1BYT_SetTx(uint8_t regAddr, uint8_t u8SrcData)
000000  b430              PUSH     {r4,r5}
;;;193    {
;;;194        uint32_t u32i;
;;;195    
;;;196        while(1)
;;;197        {
;;;198            InterruptDisable();
;;;199            if(SPI_IS_BUSY(SPI0)==0)
000002  4a0f              LDR      r2,|L4.64|
                  |L4.4|
000004  b672              CPSID    i                     ;198
000006  6953              LDR      r3,[r2,#0x14]
000008  07db              LSLS     r3,r3,#31
00000a  d001              BEQ      |L4.16|
;;;200            {
;;;201                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
;;;202                {
;;;203                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
;;;204                    if(u32i)                             //Check the PDMA transfer done flags
;;;205                    {
;;;206                        PDMA_CLR_TD_FLAG(PDMA, u32i);    //Clear the PDMA transfer done flags
;;;207                    }
;;;208                }
;;;209                break;
;;;210            }
;;;211            else
;;;212            {
;;;213                //printf("assert!");
;;;214            }
;;;215            InterruptEnable();
00000c  b662              CPSIE    i
00000e  e7f9              B        |L4.4|
                  |L4.16|
000010  4c0c              LDR      r4,|L4.68|
000012  69e3              LDR      r3,[r4,#0x1c]         ;201
000014  4d0c              LDR      r5,|L4.72|
000016  422b              TST      r3,r5                 ;201
000018  d004              BEQ      |L4.36|
00001a  6a63              LDR      r3,[r4,#0x24]         ;203
00001c  2518              MOVS     r5,#0x18              ;203
00001e  402b              ANDS     r3,r3,r5              ;203
000020  d000              BEQ      |L4.36|
000022  6263              STR      r3,[r4,#0x24]         ;206
                  |L4.36|
;;;216        }
;;;217        SPI_WRITE_TX(SPI0, (regAddr&0x7F));  //write 1st byte: regAddr & 0x7F
000024  0643              LSLS     r3,r0,#25
000026  0e5b              LSRS     r3,r3,#25
000028  6213              STR      r3,[r2,#0x20]
;;;218    
;;;219        if((regAddr&0x80))
00002a  0600              LSLS     r0,r0,#24
00002c  d501              BPL      |L4.50|
;;;220        {
;;;221            SPI_WRITE_TX(SPI0, 0x01);        //write 2nd byte: (regAddr & 0x80) >> 7
00002e  2001              MOVS     r0,#1
000030  e000              B        |L4.52|
                  |L4.50|
;;;222        }
;;;223        else
;;;224        {
;;;225            SPI_WRITE_TX(SPI0, 0x00);
000032  2000              MOVS     r0,#0
                  |L4.52|
000034  6210              STR      r0,[r2,#0x20]
;;;226        }
;;;227    
;;;228        SPI_WRITE_TX(SPI0, u8SrcData);
000036  6211              STR      r1,[r2,#0x20]
;;;229    
;;;230        InterruptEnable();
000038  b662              CPSIE    i
;;;231    }
00003a  bc30              POP      {r4,r5}
00003c  4770              BX       lr
;;;232    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      0x40061000
                  |L4.68|
                          DCD      0x40008400
                  |L4.72|
                          DCD      0x00000303

                          AREA ||i.SPI_1BYT_SetTx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetTx_Isr PROC
;;;234    // Write RF 1 byte register in ISR (not use for writing TX buffer)
;;;235    void SPI_1BYT_SetTx_Isr(uint8_t regAddr, uint8_t u8SrcData)
000000  b430              PUSH     {r4,r5}
;;;236    {
;;;237        uint32_t u32i;
;;;238        while(1)
;;;239        {
;;;240            if(SPI_IS_BUSY(SPI0)==0)
000002  4a0d              LDR      r2,|L5.56|
                  |L5.4|
000004  6953              LDR      r3,[r2,#0x14]
000006  07db              LSLS     r3,r3,#31
000008  d1fc              BNE      |L5.4|
;;;241            {
;;;242                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000a  4c0c              LDR      r4,|L5.60|
00000c  69e3              LDR      r3,[r4,#0x1c]
00000e  4d0c              LDR      r5,|L5.64|
000010  422b              TST      r3,r5
000012  d004              BEQ      |L5.30|
;;;243                {
;;;244                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000014  6a63              LDR      r3,[r4,#0x24]
000016  2518              MOVS     r5,#0x18
000018  402b              ANDS     r3,r3,r5
;;;245                    if(u32i)                             //Check the PDMA transfer done flags
00001a  d000              BEQ      |L5.30|
;;;246                    {
;;;247                        PDMA_CLR_TD_FLAG(PDMA, u32i);    //Clear the PDMA transfer done flags
00001c  6263              STR      r3,[r4,#0x24]
                  |L5.30|
;;;248                    }
;;;249                }
;;;250                break;
;;;251            }
;;;252            else
;;;253            {
;;;254                // printf("assert!");
;;;255            }
;;;256        }
;;;257        SPI_WRITE_TX(SPI0, (regAddr&0x7F));     //write 1st byte: regAddr & 0x7F
00001e  0643              LSLS     r3,r0,#25
000020  0e5b              LSRS     r3,r3,#25
000022  6213              STR      r3,[r2,#0x20]
;;;258        if((regAddr&0x80))
000024  0600              LSLS     r0,r0,#24
000026  d501              BPL      |L5.44|
;;;259        {
;;;260            SPI_WRITE_TX(SPI0, 0x01);           //write 2nd byte: (regAddr & 0x80) >> 7
000028  2001              MOVS     r0,#1
00002a  e000              B        |L5.46|
                  |L5.44|
;;;261        }
;;;262        else
;;;263        {
;;;264            SPI_WRITE_TX(SPI0, 0x00);
00002c  2000              MOVS     r0,#0
                  |L5.46|
00002e  6210              STR      r0,[r2,#0x20]
;;;265        }
;;;266    
;;;267        SPI_WRITE_TX(SPI0, u8SrcData);
000030  6211              STR      r1,[r2,#0x20]
;;;268    
;;;269    }
000032  bc30              POP      {r4,r5}
000034  4770              BX       lr
;;;270    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40061000
                  |L5.60|
                          DCD      0x40008400
                  |L5.64|
                          DCD      0x00000303

                          AREA ||i.SPI_2BYT_SetTx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_2BYT_SetTx_Isr PROC
;;;271    // Write RF 2 byte registers in ISR
;;;272    void SPI_2BYT_SetTx_Isr(uint8_t regAddr, uint8_t *u8SrcAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;273    {
;;;274        uint32_t u32i;
;;;275    
;;;276        while(1)
;;;277        {
;;;278            if(SPI_IS_BUSY(SPI0)==0)
000002  4c13              LDR      r4,|L6.80|
000004  460d              MOV      r5,r1                 ;273
                  |L6.6|
000006  6962              LDR      r2,[r4,#0x14]
000008  07d2              LSLS     r2,r2,#31
00000a  d1fc              BNE      |L6.6|
;;;279            {
;;;280                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4a11              LDR      r2,|L6.84|
00000e  69d1              LDR      r1,[r2,#0x1c]
000010  4b11              LDR      r3,|L6.88|
000012  4219              TST      r1,r3
000014  d004              BEQ      |L6.32|
;;;281                {
;;;282                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a51              LDR      r1,[r2,#0x24]
000018  2318              MOVS     r3,#0x18
00001a  4019              ANDS     r1,r1,r3
;;;283                    if(u32i)                             //Check the PDMA transfer done flags
00001c  d000              BEQ      |L6.32|
;;;284                    {
;;;285                        PDMA_CLR_TD_FLAG(PDMA, u32i);    //Clear the PDMA transfer done flags
00001e  6251              STR      r1,[r2,#0x24]
                  |L6.32|
;;;286                    }
;;;287                }
;;;288                break;
;;;289            }
;;;290            else
;;;291            {
;;;292                //printf("assert!");
;;;293            }
;;;294        }
;;;295        SPI_WRITE_TX(SPI0, (regAddr&0x7F));    //write 1st byte: regAddr & 0x7F
000020  0641              LSLS     r1,r0,#25
000022  0e49              LSRS     r1,r1,#25
000024  6221              STR      r1,[r4,#0x20]
;;;296    
;;;297        if((regAddr&0x80))
000026  0601              LSLS     r1,r0,#24
000028  d501              BPL      |L6.46|
;;;298        {
;;;299            SPI_WRITE_TX(SPI0, 0x01);          //write 2nd byte: (regAddr & 0x80) >> 7
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L6.48|
                  |L6.46|
;;;300        }
;;;301        else
;;;302        {
;;;303            SPI_WRITE_TX(SPI0, 0x00);
00002e  2100              MOVS     r1,#0
                  |L6.48|
000030  6221              STR      r1,[r4,#0x20]
;;;304        }
;;;305    
;;;306        if(regAddr==TX_BUFFER_WRITE_PORT)                   //if (writing to TX_buffer)
000032  28fe              CMP      r0,#0xfe
000034  d106              BNE      |L6.68|
;;;307        {
;;;308            uint32_t ram_start_addr;
;;;309    
;;;310            ram_start_addr = BleTxFIFOAddr_Get();
000036  f7fffffe          BL       BleTxFIFOAddr_Get
;;;311            SPI_WRITE_TX(SPI0, (ram_start_addr & 0xFF));       //write 3rd byte: ram_start_addr & 0xFF
00003a  b2c1              UXTB     r1,r0
00003c  6221              STR      r1,[r4,#0x20]
;;;312            SPI_WRITE_TX(SPI0, (ram_start_addr & 0x0100)>>8);  //write 4th byte: (ram_start_addr & 0x0100)>>8 | (b7<<7),  b7=1/0 means fill payload/header
00003e  05c0              LSLS     r0,r0,#23
000040  0fc0              LSRS     r0,r0,#31
000042  6220              STR      r0,[r4,#0x20]
                  |L6.68|
;;;313        }
;;;314        SPI_WRITE_TX(SPI0, *(u8SrcAddr));
000044  7828              LDRB     r0,[r5,#0]
000046  6220              STR      r0,[r4,#0x20]
;;;315        SPI_WRITE_TX(SPI0, *(u8SrcAddr+1));
000048  7868              LDRB     r0,[r5,#1]
00004a  6220              STR      r0,[r4,#0x20]
;;;316    }
00004c  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
                          DCD      0x40061000
                  |L6.84|
                          DCD      0x40008400
                  |L6.88|
                          DCD      0x00000303

                          AREA ||i.SPI_PDMA_Init||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_Init PROC
;;;319    //SPI PDMA init
;;;320    void SPI_PDMA_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;321    {
000002  b083              SUB      sp,sp,#0xc
;;;322    
;;;323        //Reset PDMA module
;;;324        SYS_ResetModule(PDMA_RST);
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       SYS_ResetModule
;;;325    
;;;326        //Enable PDMA channels
;;;327        PDMA_Open(PDMA, SPI_OPENED_CH);
00000a  4d1f              LDR      r5,|L7.136|
00000c  2118              MOVS     r1,#0x18
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       PDMA_Open
;;;328    
;;;329        //Single request type. SPI only support PDMA single request type.
;;;330        PDMA_SetBurstType(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000014  2300              MOVS     r3,#0
000016  2204              MOVS     r2,#4
000018  2103              MOVS     r1,#3
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       PDMA_SetBurstType
;;;331        PDMA_SetBurstType(PDMA, SPI_MASTER_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000020  2204              MOVS     r2,#4
000022  2300              MOVS     r3,#0
000024  4611              MOV      r1,r2
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       PDMA_SetBurstType
;;;332    
;;;333        //Set source/destination attributes
;;;334        PDMA_SetTransferAddr(PDMA, SPI_MASTER_TX_DMA_CH, (uint32_t)NULL, PDMA_SAR_INC, (uint32_t)&SPI0->TX, PDMA_DAR_FIX);
00002c  2103              MOVS     r1,#3
00002e  0289              LSLS     r1,r1,#10
000030  4816              LDR      r0,|L7.140|
000032  2300              MOVS     r3,#0
000034  9101              STR      r1,[sp,#4]
000036  9000              STR      r0,[sp,#0]
000038  461a              MOV      r2,r3
00003a  2103              MOVS     r1,#3
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       PDMA_SetTransferAddr
;;;335        PDMA_SetTransferAddr(PDMA, SPI_MASTER_RX_DMA_CH, (uint32_t)&SPI0->RX, PDMA_SAR_FIX, (uint32_t)NULL, PDMA_DAR_INC);
000042  2400              MOVS     r4,#0
000044  2303              MOVS     r3,#3
000046  9400              STR      r4,[sp,#0]
000048  021b              LSLS     r3,r3,#8
00004a  4a11              LDR      r2,|L7.144|
00004c  2104              MOVS     r1,#4
00004e  4628              MOV      r0,r5
000050  9401              STR      r4,[sp,#4]
000052  f7fffffe          BL       PDMA_SetTransferAddr
;;;336    
;;;337        //Set request source; set basic mode.
;;;338        PDMA_SetTransferMode(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_SPI0_TX, FALSE, 0);
000056  2300              MOVS     r3,#0
000058  2212              MOVS     r2,#0x12
00005a  2103              MOVS     r1,#3
00005c  4628              MOV      r0,r5
00005e  9400              STR      r4,[sp,#0]
000060  f7fffffe          BL       PDMA_SetTransferMode
;;;339        PDMA_SetTransferMode(PDMA, SPI_MASTER_RX_DMA_CH, PDMA_SPI0_RX, FALSE, 0);
000064  2300              MOVS     r3,#0
000066  2213              MOVS     r2,#0x13
000068  2104              MOVS     r1,#4
00006a  4628              MOV      r0,r5
00006c  9400              STR      r4,[sp,#0]
00006e  f7fffffe          BL       PDMA_SetTransferMode
;;;340    
;;;341        //Disable table interrupt
;;;342        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000072  6b28              LDR      r0,[r5,#0x30]
000074  2180              MOVS     r1,#0x80
000076  4308              ORRS     r0,r0,r1
000078  6328              STR      r0,[r5,#0x30]
;;;343        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00007a  4806              LDR      r0,|L7.148|
00007c  6802              LDR      r2,[r0,#0]
00007e  430a              ORRS     r2,r2,r1
000080  6002              STR      r2,[r0,#0]
;;;344    
;;;345    }
000082  b003              ADD      sp,sp,#0xc
000084  bd30              POP      {r4,r5,pc}
;;;346    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x40008000
                  |L7.140|
                          DCD      0x40061020
                  |L7.144|
                          DCD      0x40061030
                  |L7.148|
                          DCD      0x40008040

                          AREA ||i.SPI_PDMA_SetRx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_SetRx_Isr PROC
;;;388    //SPI PDMA read RF in ISR
;;;389    void SPI_PDMA_SetRx_Isr(uint8_t regAddr, uint32_t u32DstAddr, uint32_t u32TransCount)
000000  b4f0              PUSH     {r4-r7}
;;;390    {
;;;391        uint32_t u32i;
;;;392    
;;;393        while(1)
;;;394        {
;;;395            if(SPI_IS_BUSY(SPI0)==0)
000002  4c2b              LDR      r4,|L8.176|
000004  468c              MOV      r12,r1                ;390
                  |L8.6|
000006  6961              LDR      r1,[r4,#0x14]
000008  07c9              LSLS     r1,r1,#31
00000a  d1fc              BNE      |L8.6|
;;;396            {
;;;397                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4b29              LDR      r3,|L8.180|
00000e  69d9              LDR      r1,[r3,#0x1c]
000010  4d29              LDR      r5,|L8.184|
000012  4229              TST      r1,r5
000014  d004              BEQ      |L8.32|
;;;398                {
;;;399                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a59              LDR      r1,[r3,#0x24]
000018  2518              MOVS     r5,#0x18
00001a  4029              ANDS     r1,r1,r5
;;;400                    if(u32i)                           //Check the PDMA transfer done flags
00001c  d000              BEQ      |L8.32|
;;;401                    {
;;;402                        PDMA_CLR_TD_FLAG(PDMA, u32i);  //Clear the PDMA transfer done flags
00001e  6259              STR      r1,[r3,#0x24]
                  |L8.32|
;;;403                    }
;;;404                }
;;;405                break;
;;;406            }
;;;407        }
;;;408        SPI0_ClearRxFIFO();
000020  6921              LDR      r1,[r4,#0x10]
000022  23ff              MOVS     r3,#0xff
000024  3301              ADDS     r3,#1
000026  4319              ORRS     r1,r1,r3
000028  6121              STR      r1,[r4,#0x10]
;;;409        SPI_WRITE_TX(SPI0, ((regAddr & 0x7F)|0x80));  //1st byte (regAddr & 0x7F) | 0x80
00002a  2180              MOVS     r1,#0x80
00002c  4301              ORRS     r1,r1,r0
00002e  6221              STR      r1,[r4,#0x20]
;;;410        if((regAddr&0x80))
000030  0601              LSLS     r1,r0,#24
000032  2500              MOVS     r5,#0
000034  2900              CMP      r1,#0
000036  da02              BGE      |L8.62|
;;;411        {
;;;412            SPI_WRITE_TX(SPI0, 0x01);                 //2nd byte (regAddr & 0x80)>>7
000038  2101              MOVS     r1,#1
00003a  6221              STR      r1,[r4,#0x20]
00003c  e000              B        |L8.64|
                  |L8.62|
;;;413        }
;;;414        else
;;;415        {
;;;416            SPI_WRITE_TX(SPI0, 0x00);
00003e  6225              STR      r5,[r4,#0x20]
                  |L8.64|
000040  21ff              MOVS     r1,#0xff              ;390
;;;417        }
;;;418    
;;;419        if(regAddr==RX_BUFFER_READ_PORT)   //read RX_FIFO
000042  28ff              CMP      r0,#0xff
;;;420        {
;;;421            SPI_WRITE_TX(SPI0, 0xFF);                   //1 more dummy byte for MP read RX_FIFO
;;;422            SPI_WRITE_TX(SPI0, 0xFF);                   //1 more dummy byte for MP read RX_FIFO
;;;423        }
;;;424        else            //read register
;;;425        {
;;;426            SPI_WRITE_TX(SPI0, 0xFF);                   //1 more dummy byte for MP read register
000044  6221              STR      r1,[r4,#0x20]
000046  d100              BNE      |L8.74|
000048  6221              STR      r1,[r4,#0x20]         ;422
                  |L8.74|
;;;427        }
;;;428    
;;;429        SPI_DISABLE_RX_PDMA(SPI0);
00004a  68e3              LDR      r3,[r4,#0xc]
00004c  2602              MOVS     r6,#2
00004e  43b3              BICS     r3,r3,r6
000050  60e3              STR      r3,[r4,#0xc]
;;;430        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].SA = 0; //In SPI read, Master write dummy data to generate SPI clock
000052  4b1a              LDR      r3,|L8.188|
000054  635d              STR      r5,[r3,#0x34]
;;;431    
;;;432        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL &= ~(PDMA_DSCT_CTL_TXCNT_Msk | PDMA_DSCT_CTL_TXWIDTH_Msk | PDMA_DSCT_CTL_OPMODE_Msk);
000056  6b1d              LDR      r5,[r3,#0x30]
000058  4919              LDR      r1,|L8.192|
00005a  400d              ANDS     r5,r5,r1
00005c  631d              STR      r5,[r3,#0x30]
;;;433        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= ((PDMA_WIDTH_8|PDMA_OP_BASIC) | ((u32TransCount - 1UL) << PDMA_DSCT_CTL_TXCNT_Pos));
00005e  6b1d              LDR      r5,[r3,#0x30]
000060  0417              LSLS     r7,r2,#16
000062  4a18              LDR      r2,|L8.196|
000064  18ba              ADDS     r2,r7,r2
000066  4315              ORRS     r5,r5,r2
000068  631d              STR      r5,[r3,#0x30]
;;;434        SPI_TRIGGER_TX_PDMA(SPI0);
00006a  68e3              LDR      r3,[r4,#0xc]
00006c  2501              MOVS     r5,#1
00006e  432b              ORRS     r3,r3,r5
000070  60e3              STR      r3,[r4,#0xc]
;;;435        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].DA = u32DstAddr;
000072  4b15              LDR      r3,|L8.200|
000074  4665              MOV      r5,r12
000076  609d              STR      r5,[r3,#8]
;;;436        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL &= ~(PDMA_DSCT_CTL_TXCNT_Msk | PDMA_DSCT_CTL_TXWIDTH_Msk | PDMA_DSCT_CTL_OPMODE_Msk);
000078  681d              LDR      r5,[r3,#0]
00007a  400d              ANDS     r5,r5,r1
00007c  601d              STR      r5,[r3,#0]
;;;437        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL |= ((PDMA_WIDTH_8|PDMA_OP_BASIC) | ((u32TransCount - 1UL) << PDMA_DSCT_CTL_TXCNT_Pos));
00007e  6819              LDR      r1,[r3,#0]
000080  4311              ORRS     r1,r1,r2
000082  6019              STR      r1,[r3,#0]
;;;438    
;;;439        if(regAddr==RX_BUFFER_READ_PORT)   //read RX_FIFO
000084  28ff              CMP      r0,#0xff
000086  d00c              BEQ      |L8.162|
                  |L8.136|
;;;440        {
;;;441            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=4);
;;;442            SPI_READ_RX(SPI0);
;;;443            SPI_READ_RX(SPI0);
;;;444            SPI_READ_RX(SPI0);
;;;445            SPI_READ_RX(SPI0);
;;;446        }
;;;447        else   //read register
;;;448        {
;;;449            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=3);
000088  6960              LDR      r0,[r4,#0x14]
;;;450            SPI_READ_RX(SPI0);
;;;451            SPI_READ_RX(SPI0);
;;;452            SPI_READ_RX(SPI0);
;;;453        }
;;;454    
;;;455        SPI_TRIGGER_RX_PDMA(SPI0);
;;;456    }
00008a  0100              LSLS     r0,r0,#4
00008c  0f00              LSRS     r0,r0,#28
00008e  2803              CMP      r0,#3                 ;449
000090  d1fa              BNE      |L8.136|
                  |L8.146|
000092  6b20              LDR      r0,[r4,#0x30]         ;450
000094  6b20              LDR      r0,[r4,#0x30]         ;451
000096  6b20              LDR      r0,[r4,#0x30]         ;452
000098  68e0              LDR      r0,[r4,#0xc]          ;455
00009a  4330              ORRS     r0,r0,r6              ;455
00009c  60e0              STR      r0,[r4,#0xc]          ;455
00009e  bcf0              POP      {r4-r7}
0000a0  4770              BX       lr
                  |L8.162|
0000a2  6960              LDR      r0,[r4,#0x14]         ;441
0000a4  0100              LSLS     r0,r0,#4
0000a6  0f00              LSRS     r0,r0,#28
0000a8  2804              CMP      r0,#4                 ;441
0000aa  d1fa              BNE      |L8.162|
0000ac  6b20              LDR      r0,[r4,#0x30]         ;442
0000ae  e7f0              B        |L8.146|
;;;457    
                          ENDP

                  |L8.176|
                          DCD      0x40061000
                  |L8.180|
                          DCD      0x40008400
                  |L8.184|
                          DCD      0x00000303
                  |L8.188|
                          DCD      0x40008000
                  |L8.192|
                          DCD      0x0000cffc
                  |L8.196|
                          DCD      0xffff0001
                  |L8.200|
                          DCD      0x40008040

                          AREA ||i.SPI_PDMA_SetTx||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_SetTx PROC
;;;460    //SPI PDMA write RF
;;;461    void SPI_PDMA_SetTx(uint8_t regAddr, uint32_t u32SrcAddr, uint32_t u32TransCount)
000000  b5f8              PUSH     {r3-r7,lr}
;;;462    {
;;;463        uint32_t u32i;
;;;464    
;;;465        while(1)
;;;466        {
;;;467            if(SPI_IS_BUSY(SPI0)==0)
000002  4c1a              LDR      r4,|L9.108|
000004  4615              MOV      r5,r2                 ;462
                  |L9.6|
000006  6963              LDR      r3,[r4,#0x14]
000008  07da              LSLS     r2,r3,#31
00000a  d1fc              BNE      |L9.6|
;;;468            {
;;;469                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4b18              LDR      r3,|L9.112|
00000e  69da              LDR      r2,[r3,#0x1c]
000010  4e18              LDR      r6,|L9.116|
000012  4232              TST      r2,r6
000014  d004              BEQ      |L9.32|
;;;470                {
;;;471                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a5a              LDR      r2,[r3,#0x24]
000018  2618              MOVS     r6,#0x18
00001a  4032              ANDS     r2,r2,r6
;;;472                    if(u32i)                               //Check the PDMA transfer done flags
00001c  d000              BEQ      |L9.32|
;;;473                    {
;;;474                        PDMA_CLR_TD_FLAG(PDMA, u32i);      //Clear the PDMA transfer done flags
00001e  625a              STR      r2,[r3,#0x24]
                  |L9.32|
;;;475                    }
;;;476                }
;;;477                break;
;;;478            }
;;;479        }
;;;480        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].SA = u32SrcAddr;
000020  4e15              LDR      r6,|L9.120|
000022  6371              STR      r1,[r6,#0x34]
;;;481        SPI_WRITE_TX(SPI0, (regAddr&0x7F));       //write 1st byte: regAddr & 0x7F
000024  0641              LSLS     r1,r0,#25
000026  0e49              LSRS     r1,r1,#25
000028  6221              STR      r1,[r4,#0x20]
;;;482    
;;;483        if((regAddr&0x80))
00002a  0601              LSLS     r1,r0,#24
;;;484        {
;;;485            SPI_WRITE_TX(SPI0, 0x01);             //write 2nd byte: (regAddr & 0x80) >> 7
00002c  2701              MOVS     r7,#1
00002e  2900              CMP      r1,#0                 ;483
000030  da01              BGE      |L9.54|
000032  6227              STR      r7,[r4,#0x20]
000034  e001              B        |L9.58|
                  |L9.54|
;;;486        }
;;;487        else
;;;488        {
;;;489            SPI_WRITE_TX(SPI0, 0x00);
000036  2100              MOVS     r1,#0
000038  6221              STR      r1,[r4,#0x20]
                  |L9.58|
;;;490        }
;;;491    
;;;492        if(regAddr==TX_BUFFER_WRITE_PORT)                             //if (writing to TX_buffer)
00003a  28fe              CMP      r0,#0xfe
00003c  d107              BNE      |L9.78|
;;;493        {
;;;494            uint32_t ram_start_addr;
;;;495    
;;;496            ram_start_addr = BleTxFIFOAddr_Get();
00003e  f7fffffe          BL       BleTxFIFOAddr_Get
;;;497            SPI_WRITE_TX(SPI0, (ram_start_addr & 0xFF));                 //write 3rd byte: ram_start_addr & 0xFF
000042  b2c1              UXTB     r1,r0
000044  6221              STR      r1,[r4,#0x20]
;;;498            SPI_WRITE_TX(SPI0, ((ram_start_addr & 0x0100)>>8) | 0x80);   //write 4th byte: (ram_start_addr & 0x0100)>>8 | (b7<<7),  b7=1/0 means fill payload/header
000046  05c0              LSLS     r0,r0,#23
000048  0fc0              LSRS     r0,r0,#31
00004a  3080              ADDS     r0,r0,#0x80
00004c  6220              STR      r0,[r4,#0x20]
                  |L9.78|
;;;499        }
;;;500    
;;;501        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL &= ~(PDMA_DSCT_CTL_TXCNT_Msk | PDMA_DSCT_CTL_TXWIDTH_Msk | PDMA_DSCT_CTL_OPMODE_Msk);
00004e  6b30              LDR      r0,[r6,#0x30]
000050  490a              LDR      r1,|L9.124|
000052  4008              ANDS     r0,r0,r1
000054  6330              STR      r0,[r6,#0x30]
;;;502        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= ((PDMA_WIDTH_8|PDMA_OP_BASIC) | ((u32TransCount - 1UL) << PDMA_DSCT_CTL_TXCNT_Pos));
000056  6b30              LDR      r0,[r6,#0x30]
000058  4a09              LDR      r2,|L9.128|
00005a  0429              LSLS     r1,r5,#16
00005c  1889              ADDS     r1,r1,r2
00005e  4308              ORRS     r0,r0,r1
000060  6330              STR      r0,[r6,#0x30]
;;;503    
;;;504        SPI_TRIGGER_TX_PDMA(SPI0);  //Enable SPI master DMA function
000062  68e0              LDR      r0,[r4,#0xc]
000064  4338              ORRS     r0,r0,r7
000066  60e0              STR      r0,[r4,#0xc]
;;;505    }
000068  bdf8              POP      {r3-r7,pc}
;;;506    
                          ENDP

00006a  0000              DCW      0x0000
                  |L9.108|
                          DCD      0x40061000
                  |L9.112|
                          DCD      0x40008400
                  |L9.116|
                          DCD      0x00000303
                  |L9.120|
                          DCD      0x40008000
                  |L9.124|
                          DCD      0x0000cffc
                  |L9.128|
                          DCD      0xffff0001

                          AREA ||i.SPI_PDMA_waitFinish||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_waitFinish PROC
;;;349    //wait PDMA finish operation
;;;350    uint32_t SPI_PDMA_waitFinish(void)
000000  480e              LDR      r0,|L10.60|
                  |L10.2|
;;;351    {
;;;352        uint32_t u32i;
;;;353    
;;;354        while(SPI_IS_BUSY(SPI0));
000002  6941              LDR      r1,[r0,#0x14]
000004  07c9              LSLS     r1,r1,#31
000006  d1fc              BNE      |L10.2|
;;;355        u32i = PDMA_GET_INT_STATUS(PDMA);               //Get interrupt status
000008  490d              LDR      r1,|L10.64|
00000a  69c8              LDR      r0,[r1,#0x1c]
;;;356        if((u32i&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4a0d              LDR      r2,|L10.68|
00000e  4210              TST      r0,r2
000010  d006              BEQ      |L10.32|
;;;357        {
;;;358            if(u32i & PDMA_INTSTS_TDIF_Msk)             //Check the PDMA transfer done interrupt flag
000012  0782              LSLS     r2,r0,#30
000014  d506              BPL      |L10.36|
;;;359            {
;;;360                u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a48              LDR      r0,[r1,#0x24]
000018  2218              MOVS     r2,#0x18
00001a  4010              ANDS     r0,r0,r2
;;;361                if(u32i)                                //Check the PDMA transfer done flags
00001c  d000              BEQ      |L10.32|
;;;362                {
;;;363                    PDMA_CLR_TD_FLAG(PDMA, u32i);       //Clear the PDMA transfer done flags
00001e  6248              STR      r0,[r1,#0x24]
                  |L10.32|
;;;364                }
;;;365                u32i = SUCCESS_;
;;;366            }
;;;367            else if(u32i & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))             //Check the DMA time-out interrupt flag
;;;368            {
;;;369                PDMA->INTSTS = u32i & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk);  //Clear the time-out flag
;;;370                u32i = FAIL_;
;;;371            }
;;;372            else                                        //Check the DMA transfer abort interrupt flag, (ui32 & PDMA_INTSTS_ABTIF_Msk)
;;;373            {
;;;374                u32i = PDMA_GET_ABORT_STS(PDMA);        //Get the target abort flag
;;;375                PDMA_CLR_ABORT_FLAG(PDMA, u32i);        //Clear the target abort flag
;;;376                u32i = FAIL_;
;;;377            }
;;;378        }
;;;379        else
;;;380        {
;;;381            u32i = SUCCESS_;
000020  2000              MOVS     r0,#0
;;;382        }
;;;383        return u32i;
;;;384    }
000022  4770              BX       lr
                  |L10.36|
000024  0582              LSLS     r2,r0,#22             ;367
000026  0f92              LSRS     r2,r2,#30             ;367
000028  d004              BEQ      |L10.52|
00002a  2203              MOVS     r2,#3                 ;369
00002c  0212              LSLS     r2,r2,#8              ;369
00002e  4010              ANDS     r0,r0,r2              ;369
000030  61c8              STR      r0,[r1,#0x1c]         ;369
000032  e001              B        |L10.56|
                  |L10.52|
000034  6a08              LDR      r0,[r1,#0x20]         ;374
000036  6208              STR      r0,[r1,#0x20]         ;375
                  |L10.56|
000038  2001              MOVS     r0,#1                 ;376
00003a  4770              BX       lr
;;;385    
                          ENDP

                  |L10.60|
                          DCD      0x40061000
                  |L10.64|
                          DCD      0x40008400
                  |L10.68|
                          DCD      0x00000303

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\porting\\porting_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_porting_spi_c_7d2ac375____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_porting_spi_c_7d2ac375____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_porting_spi_c_7d2ac375____REVSH|
#line 402
|__asm___13_porting_spi_c_7d2ac375____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
