; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\porting_misc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\porting_misc.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\include -I..\..\..\porting -I..\..\..\include\rf_include -I..\..\..\porting\rf_porting -I..\..\SLT_Demo -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\porting_misc.crf ..\..\..\porting\porting_misc.c]
                          THUMB

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;503      */
;;;504    __STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L1.28|
;;;505    {
;;;506        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L1.32|
000008  6148              STR      r0,[r1,#0x14]
;;;507        SysTick->VAL  = (0x00);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;508        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L1.18|
;;;509    
;;;510        /* Waiting for down-count to zero */
;;;511        while ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L1.18|
;;;512    
;;;513        /* Disable SysTick counter */
;;;514        SysTick->CTRL = 0;
000018  610a              STR      r2,[r1,#0x10]
;;;515    }
00001a  4770              BX       lr
;;;516    
                          ENDP

                  |L1.28|
                          DCD      CyclesPerUs
                  |L1.32|
                          DCD      0xe000e000

                          AREA ||i.GPCDEF_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPCDEF_IRQHandler PROC
;;;199    #elif ((_BOARD_SELECTION_ == _BOARD_NUVOTON_M031TD2AE_QFN33_)||(_BOARD_SELECTION_ == _BOARD_NUVOTON_M031_SIP_))
;;;200    void GPCDEF_IRQHandler(void)
000000  b508              PUSH     {r3,lr}
;;;201    #endif
;;;202    {
;;;203        volatile uint32_t temp;
;;;204        extern void LL_GPIO_Isr(void);
;;;205    #ifdef BLE_DEMO
;;;206    #if ((BLE_DEMO==DEMO_DTM) ||(BLE_DEMO==DEMO_HRS_DTM))
;;;207        extern void DTM_Isr(void);
;;;208    #endif //#if (BLE_DEMO==DEMO_DTM)
;;;209    #endif //#ifdef BLE_DEMO
;;;210        //Clear MCU GPIO Int status
;;;211    #if ((_BOARD_SELECTION_ == _BOARD_NUVOTON_M031SE_)||(_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_))
;;;212        if(GPIO_GET_INT_FLAG(PA, BIT5))
;;;213        {
;;;214            GPIO_CLR_INT_FLAG(PA, BIT5);
;;;215        }
;;;216        else
;;;217        {
;;;218            // Un-expected interrupt. Just clear all PA interrupts
;;;219            temp = PA->INTSRC;
;;;220            PA->INTSRC = temp;
;;;221        }
;;;222    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M487JIDAE_B3_)
;;;223        if(GPIO_GET_INT_FLAG(PC, BIT9))
;;;224        {
;;;225            GPIO_CLR_INT_FLAG(PC, BIT9);
;;;226        }
;;;227        else
;;;228        {
;;;229            // Un-expected interrupt. Just clear all PC interrupts
;;;230            temp = PC->INTSRC;
;;;231            PC->INTSRC = temp;
;;;232        }
;;;233    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031TD2AE_QFN33_)
;;;234        if(GPIO_GET_INT_FLAG(PF, BIT15))
000002  4806              LDR      r0,|L2.28|
000004  6a01              LDR      r1,[r0,#0x20]
000006  0409              LSLS     r1,r1,#16
000008  d501              BPL      |L2.14|
;;;235        {
;;;236            GPIO_CLR_INT_FLAG(PF, BIT15);
00000a  13c1              ASRS     r1,r0,#15
00000c  e001              B        |L2.18|
                  |L2.14|
;;;237        }
;;;238        else
;;;239        {
;;;240            // Un-expected interrupt. Just clear all PF interrupts
;;;241            temp = PF->INTSRC;
00000e  6a01              LDR      r1,[r0,#0x20]
000010  9100              STR      r1,[sp,#0]
                  |L2.18|
;;;242            PF->INTSRC = temp;
000012  6201              STR      r1,[r0,#0x20]
;;;243        }
;;;244    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031_SIP_)
;;;245        if(GPIO_GET_INT_FLAG(PC, BIT2))
;;;246        {
;;;247            GPIO_CLR_INT_FLAG(PC, BIT2);
;;;248        }
;;;249        else
;;;250        {
;;;251            /* Un-expected interrupt. Just clear all PC interrupts */
;;;252            temp = PC->INTSRC;
;;;253            PC->INTSRC = temp;
;;;254        }
;;;255    #endif // (_BOARD_SELECTION_ == _BOARD_NUVOTON_xxxx)
;;;256    
;;;257    #ifdef BLE_DEMO
;;;258    #if (BLE_DEMO==DEMO_DTM)
;;;259        DTM_Isr();
;;;260    #elif (BLE_DEMO==DEMO_HRS_DTM)
;;;261        if(DEMO_GPI_SEL_PIN==1)//DTM mode
;;;262        {
;;;263            DTM_Isr();
;;;264        }
;;;265        else
;;;266        {
;;;267            LL_GPIO_Isr();      // Put this on the top following the clearing MCU GPIO Int status process.
;;;268        }
;;;269    #else
;;;270        LL_GPIO_Isr();      // Put this on the top following the clearing MCU GPIO Int status process.
;;;271    #endif
;;;272    #else
;;;273        LL_GPIO_Isr();      // Put this on the top following the clearing MCU GPIO Int status process.
000014  f7fffffe          BL       LL_GPIO_Isr
;;;274    #endif
;;;275    
;;;276    }
000018  bd08              POP      {r3,pc}
;;;277    #pragma pop
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40004140

                          AREA ||i.MCU_GpioIntDisable||, CODE, READONLY, ALIGN=2

                  MCU_GpioIntDisable PROC
;;;170    
;;;171    void MCU_GpioIntDisable(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173    #if (_BOARD_SELECTION_   == _BOARD_NUVOTON_M031SE_)
;;;174        GPIO_DisableInt(PA, 5);
;;;175        NVIC_DisableIRQ(GPIO_PAPB_IRQn);    //disable irq in nvic
;;;176    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_)
;;;177        GPIO_DisableInt(PA, 5);
;;;178        NVIC_DisableIRQ(GPIO_PAPB_IRQn);    //disable irq in nvic
;;;179    #elif (_BOARD_SELECTION_ ==  _BOARD_NUVOTON_M487JIDAE_B3_)
;;;180        GPIO_DisableInt(PC, 9);
;;;181        NVIC_DisableIRQ(GPC_IRQn);          //disable irq in nvic
;;;182    #elif (_BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031TD2AE_QFN33_)
;;;183        GPIO_DisableInt(PF, 15);
000002  210f              MOVS     r1,#0xf
000004  4803              LDR      r0,|L3.20|
000006  f7fffffe          BL       GPIO_DisableInt
00000a  4903              LDR      r1,|L3.24|
00000c  2020              MOVS     r0,#0x20
00000e  6008              STR      r0,[r1,#0]
;;;184        NVIC_DisableIRQ(GPIO_PCPDPEPF_IRQn);          //disable irq in nvic
;;;185    #elif (_BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031_SIP_)
;;;186        GPIO_DisableInt(PC, 2);
;;;187        NVIC_DisableIRQ(GPIO_PCPDPEPF_IRQn);          //disable irq in nvic
;;;188    #endif  //(_BOARD_SELECTION_)
;;;189    }
000010  bd10              POP      {r4,pc}
;;;190    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40004140
                  |L3.24|
                          DCD      0xe000e180

                          AREA ||i.MCU_GpioIntEnable||, CODE, READONLY, ALIGN=2

                  MCU_GpioIntEnable PROC
;;;103    
;;;104    void MCU_GpioIntEnable(void)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106    #if ((_BOARD_SELECTION_ == _BOARD_NUVOTON_M031SE_)||(_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_))
;;;107        // Configure PA.5 as Input mode and enable interrupt by rising edge trigger
;;;108        GPIO_SetMode(PA, BIT5, GPIO_MODE_INPUT);
;;;109    
;;;110        if(ChipId_Get()==MP_A1)
;;;111        {
;;;112            GPIO_EnableInt(PA, 5, GPIO_INT_RISING);
;;;113        }
;;;114        else
;;;115        {
;;;116    #if 1
;;;117            GPIO_EnableInt(PA, 5, GPIO_INT_HIGH);
;;;118    #else   //(0)
;;;119            GPIO_EnableInt(PA, 5, GPIO_INT_RISING);
;;;120    #endif  //(0)
;;;121        }
;;;122        NVIC_EnableIRQ(GPIO_PAPB_IRQn);
;;;123    
;;;124    #elif (_BOARD_SELECTION_ ==  _BOARD_NUVOTON_M487JIDAE_B3_)
;;;125        // Configure PC.9 as Input mode and enable interrupt by rising edge trigger
;;;126        GPIO_SetMode(PC, BIT9, GPIO_MODE_INPUT);
;;;127    
;;;128        if(ChipId_Get()==MP_A1)
;;;129        {
;;;130            GPIO_EnableInt(PC, 9, GPIO_INT_RISING);
;;;131        }
;;;132        else
;;;133        {
;;;134            GPIO_EnableInt(PC, 9, GPIO_INT_HIGH);
;;;135        }
;;;136        NVIC_EnableIRQ(GPC_IRQn);
;;;137    
;;;138    #elif (_BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031TD2AE_QFN33_)
;;;139        // Configure PF.15 as Input mode and enable interrupt by rising edge trigger
;;;140        GPIO_SetMode(PF, BIT15, GPIO_MODE_INPUT);
000002  4c0b              LDR      r4,|L4.48|
000004  2101              MOVS     r1,#1
000006  2200              MOVS     r2,#0
000008  03c9              LSLS     r1,r1,#15
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       GPIO_SetMode
;;;141    
;;;142        if(ChipId_Get()==MP_A1)
000010  f7fffffe          BL       ChipId_Get
000014  2866              CMP      r0,#0x66
000016  d008              BEQ      |L4.42|
;;;143        {
;;;144            GPIO_EnableInt(PF, 15, GPIO_INT_RISING);
;;;145        }
;;;146        else
;;;147        {
;;;148            GPIO_EnableInt(PF, 15, GPIO_INT_HIGH);
000018  4a06              LDR      r2,|L4.52|
                  |L4.26|
00001a  210f              MOVS     r1,#0xf
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_EnableInt
000022  4905              LDR      r1,|L4.56|
000024  2020              MOVS     r0,#0x20
000026  6008              STR      r0,[r1,#0]
;;;149        }
;;;150        NVIC_EnableIRQ(GPIO_PCPDPEPF_IRQn);
;;;151    
;;;152    #elif (_BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031_SIP_)
;;;153        // Configure PC.2 as Input mode and enable interrupt by rising edge trigger
;;;154        GPIO_SetMode(PC, BIT2, GPIO_MODE_INPUT);
;;;155    
;;;156        if(ChipId_Get()== MP_A1)
;;;157        {
;;;158            GPIO_EnableInt(PC, 2, GPIO_INT_RISING);
;;;159        }
;;;160        else
;;;161        {
;;;162            GPIO_EnableInt(PC, 2, GPIO_INT_HIGH);
;;;163        }
;;;164        NVIC_EnableIRQ(GPIO_PCPDPEPF_IRQn);
;;;165    
;;;166    #endif //(_BOARD_SELECTION_==_BOARD_NUVOTON_M031SE_)
;;;167    
;;;168    }
000028  bd10              POP      {r4,pc}
                  |L4.42|
00002a  2201              MOVS     r2,#1                 ;144
00002c  0412              LSLS     r2,r2,#16             ;144
00002e  e7f4              B        |L4.26|
;;;169    
                          ENDP

                  |L4.48|
                          DCD      0x40004140
                  |L4.52|
                          DCD      0x01010000
                  |L4.56|
                          DCD      0xe000e100

                          AREA ||i.MCU_GpioPinInit||, CODE, READONLY, ALIGN=2

                  MCU_GpioPinInit PROC
;;;65     //Assign GPIO INT pin, LED pin
;;;66     void MCU_GpioPinInit(void)
000000  b510              PUSH     {r4,lr}
;;;67     {
;;;68         //Configure Interrupt pin as Input mode
;;;69     #if ((_BOARD_SELECTION_ == _BOARD_NUVOTON_M031SE_)||(_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_))
;;;70         GPIO_SetMode(PA, BIT5, GPIO_MODE_INPUT);
;;;71     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M487JIDAE_B3_
;;;72         GPIO_SetMode(PC, BIT9, GPIO_MODE_INPUT);
;;;73     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031TD2AE_QFN33_
;;;74         GPIO_SetMode(PF, BIT15, GPIO_MODE_INPUT);
000002  2101              MOVS     r1,#1
000004  2200              MOVS     r2,#0
000006  03c9              LSLS     r1,r1,#15
000008  4805              LDR      r0,|L5.32|
00000a  f7fffffe          BL       GPIO_SetMode
;;;75     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031_SIP_
;;;76         GPIO_SetMode(PC, BIT2, GPIO_MODE_INPUT);
;;;77     #endif
;;;78     
;;;79         //LED pin assign
;;;80     #if (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031_SIP_)
;;;81         GPIO_SetMode(PF, BIT15, GPIO_MODE_OUTPUT); //LED
;;;82         PF15 = 1;                                  //initial off
;;;83     #else
;;;84         GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT); //LED
00000e  2201              MOVS     r2,#1
000010  0391              LSLS     r1,r2,#14
000012  4804              LDR      r0,|L5.36|
000014  f7fffffe          BL       GPIO_SetMode
;;;85         PB14 = 1;                                  //initial off
000018  4903              LDR      r1,|L5.40|
00001a  2001              MOVS     r0,#1
00001c  6388              STR      r0,[r1,#0x38]
;;;86     #endif
;;;87     
;;;88     //    //Debug Pin
;;;89     //    GPIO_SetMode(PA, BIT10, GPIO_MODE_OUTPUT);
;;;90     //    PA10 = 0;
;;;91     
;;;92     // detector DTM or HRS pin as Input mode
;;;93     #ifdef BLE_DEMO
;;;94     #if (BLE_DEMO==DEMO_HRS_DTM)
;;;95     #if _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031TD2AE_QFN33_
;;;96         GPIO_SetMode(PC, BIT0, GPIO_MODE_INPUT);
;;;97     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031_SIP_
;;;98         GPIO_SetMode(PC, BIT0, GPIO_MODE_INPUT);
;;;99     #endif
;;;100    #endif
;;;101    #endif
;;;102    }
00001e  bd10              POP      {r4,pc}
;;;103    
                          ENDP

                  |L5.32|
                          DCD      0x40004140
                  |L5.36|
                          DCD      0x40004040
                  |L5.40|
                          DCD      0x40004840

                          AREA ||i.MCU_GpioReset||, CODE, READONLY, ALIGN=2

                  MCU_GpioReset PROC
;;;52     
;;;53     void MCU_GpioReset(void)
000000  b570              PUSH     {r4-r6,lr}
;;;54     {
;;;55         //Do Reset: pulse low
;;;56         RESET_RF = 1;
000002  4c07              LDR      r4,|L6.32|
000004  2501              MOVS     r5,#1
000006  6065              STR      r5,[r4,#4]
;;;57         CLK_SysTickDelay(1000);       //1ms
000008  267d              MOVS     r6,#0x7d
00000a  00f6              LSLS     r6,r6,#3
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       CLK_SysTickDelay
;;;58     
;;;59         RESET_RF = 0;
000012  2000              MOVS     r0,#0
000014  6060              STR      r0,[r4,#4]
;;;60         CLK_SysTickDelay(1000);       //1ms
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       CLK_SysTickDelay
;;;61     
;;;62         RESET_RF = 1;
00001c  6065              STR      r5,[r4,#4]
;;;63     }
00001e  bd70              POP      {r4-r6,pc}
;;;64     
                          ENDP

                  |L6.32|
                          DCD      0x40004880

                          AREA ||i.MCU_GpioResetInit||, CODE, READONLY, ALIGN=2

                  MCU_GpioResetInit PROC
;;;21     /*-------------------- GPIO peripheral ---------------------*/
;;;22     void MCU_GpioResetInit(void)
000000  b510              PUSH     {r4,lr}
;;;23     {
;;;24         //Assign RF Reset pin
;;;25     #if ((_BOARD_SELECTION_ == _BOARD_NUVOTON_M031SE_)||(_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_))
;;;26         GPIO_SetMode(PA, BIT4, GPIO_MODE_OUTPUT);
;;;27     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M487JIDAE_B3_
;;;28         GPIO_SetMode(PC, BIT10, GPIO_MODE_OUTPUT);
;;;29     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031TD2AE_QFN33_
;;;30         GPIO_SetMode(PC, BIT1, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  2102              MOVS     r1,#2
000006  4803              LDR      r0,|L7.20|
000008  f7fffffe          BL       GPIO_SetMode
;;;31     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031_SIP_
;;;32         GPIO_SetMode(PA, BIT12, GPIO_MODE_OUTPUT);
;;;33     #endif
;;;34     
;;;35         RESET_RF = 1;  //RESET_RF defined in porting_misc.h
00000c  4902              LDR      r1,|L7.24|
00000e  2001              MOVS     r0,#1
000010  6048              STR      r0,[r1,#4]
;;;36     }
000012  bd10              POP      {r4,pc}
;;;37     
                          ENDP

                  |L7.20|
                          DCD      0x40004080
                  |L7.24|
                          DCD      0x40004880

                          AREA ||i.MCU_SetGpioResetIdle||, CODE, READONLY, ALIGN=2

                  MCU_SetGpioResetIdle PROC
;;;38     
;;;39     void MCU_SetGpioResetIdle(void)
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41         //Assign RF Reset pin
;;;42     #if ((_BOARD_SELECTION_ == _BOARD_NUVOTON_M031SE_)||(_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_))
;;;43         GPIO_SetMode(PA, BIT4, GPIO_MODE_INPUT);
;;;44     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M487JIDAE_B3_
;;;45         GPIO_SetMode(PC, BIT10, GPIO_MODE_INPUT);
;;;46     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031TD2AE_QFN33_
;;;47         GPIO_SetMode(PC, BIT1, GPIO_MODE_INPUT);
000002  2200              MOVS     r2,#0
000004  2102              MOVS     r1,#2
000006  4802              LDR      r0,|L8.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;48     #elif _BOARD_SELECTION_ ==  _BOARD_NUVOTON_M031_SIP_
;;;49         GPIO_SetMode(PA, BIT12, GPIO_MODE_INPUT);
;;;50     #endif
;;;51     }
00000c  bd10              POP      {r4,pc}
;;;52     
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40004080

                          AREA ||i.MCU_WDTmr_En||, CODE, READONLY, ALIGN=2

                  MCU_WDTmr_En PROC
;;;620    #ifdef _HW_PRG_RESET_
;;;621    void MCU_WDTmr_En(void)
000000  b510              PUSH     {r4,lr}
;;;622    {
;;;623        extern void WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);
;;;624    
;;;625        InterruptDisable();
000002  b672              CPSID    i
;;;626        SYS_UnlockReg();
000004  f7fffffe          BL       SYS_UnlockReg
;;;627    
;;;628        CLK_SetModuleClock(WDT_MODULE, CLK_CLKSEL1_WDTSEL_LIRC, 0);
000008  242b              MOVS     r4,#0x2b
00000a  0664              LSLS     r4,r4,#25
00000c  2200              MOVS     r2,#0
00000e  2103              MOVS     r1,#3
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CLK_SetModuleClock
;;;629        CLK_EnableModuleClock(WDT_MODULE);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       CLK_EnableModuleClock
;;;630        SystemCoreClockUpdate();
00001c  f7fffffe          BL       SystemCoreClockUpdate
;;;631    
;;;632        WDT_Open(WDT_TIMEOUT_2POW4, WDT_RESET_DELAY_18CLK, TRUE, FALSE);
000020  2300              MOVS     r3,#0
000022  2201              MOVS     r2,#1
000024  2102              MOVS     r1,#2
000026  4618              MOV      r0,r3
000028  f7fffffe          BL       WDT_Open
00002c  4907              LDR      r1,|L9.76|
00002e  2002              MOVS     r0,#2
000030  6008              STR      r0,[r1,#0]
000032  4807              LDR      r0,|L9.80|
000034  6801              LDR      r1,[r0,#0]
000036  2240              MOVS     r2,#0x40
000038  4311              ORRS     r1,r1,r2
00003a  6001              STR      r1,[r0,#0]
                  |L9.60|
00003c  6801              LDR      r1,[r0,#0]
00003e  0049              LSLS     r1,r1,#1
000040  d4fc              BMI      |L9.60|
000042  4904              LDR      r1,|L9.84|
000044  2000              MOVS     r0,#0
000046  6008              STR      r0,[r1,#0]
;;;633        NVIC_EnableIRQ(WDT_IRQn);
;;;634        WDT_EnableInt();
;;;635    
;;;636        SYS_LockReg();
;;;637        InterruptEnable();
000048  b662              CPSIE    i
;;;638    }
00004a  bd10              POP      {r4,pc}
;;;639    #endif  //(#ifdef _HW_PRG_RESET_)
                          ENDP

                  |L9.76|
                          DCD      0xe000e100
                  |L9.80|
                          DCD      0x40040000
                  |L9.84|
                          DCD      0x40000100

                          AREA ||i.RF_SpiIoMapping||, CODE, READONLY, ALIGN=2

                  RF_SpiIoMapping PROC
;;;397    //SPI IO mapping. Must do this after Power ON
;;;398    void RF_SpiIoMapping(void)
000000  b570              PUSH     {r4-r6,lr}
;;;399    {
;;;400        //(1) Set all SPI GPIO pin as output. Be careful not to set 5 pins as HIGH, it will trigger HW mapping SPI pin
;;;401        SPI_GPIO_Init();         //Here set all CLK,CS,MOSI,NISO,INT as output
000002  f7fffffe          BL       SPI_GPIO_Init
;;;402        SPI_CS=1;
000006  4c20              LDR      r4,|L10.136|
000008  2501              MOVS     r5,#1
00000a  60e5              STR      r5,[r4,#0xc]
;;;403        SPI_CK=0;
00000c  2000              MOVS     r0,#0
00000e  60a0              STR      r0,[r4,#8]
;;;404        SPI_MOSI=0;
000010  6020              STR      r0,[r4,#0]
;;;405        SPI_MISO=0;
000012  6060              STR      r0,[r4,#4]
;;;406        DEFAULT_INT=0;
000014  4e1d              LDR      r6,|L10.140|
000016  63f0              STR      r0,[r6,#0x3c]
;;;407    
;;;408        //(2) Write R248, R249 GPIO select
;;;409    #if (SPI_IO_ORDER==1)
;;;410        //Write R248=8'b10,001,000, R249=8'b0,100,011,0
;;;411        //GPIO0[2:0]=0 - CS
;;;412        //GPIO1[2:0]=1 - CLK
;;;413        //GPIO2[2:0]=2 - MOSI
;;;414        //GPIO3[2:0]=3 - MISO
;;;415        //GPIO4[2:0]=4 - INT
;;;416        CLK_SysTickDelay(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       CLK_SysTickDelay
;;;417        spiGpioWriteReg(248, 0x88);
00001e  2188              MOVS     r1,#0x88
000020  20f8              MOVS     r0,#0xf8
000022  f7fffffe          BL       spiGpioWriteReg
;;;418        CLK_SysTickDelay(50);
000026  2032              MOVS     r0,#0x32
000028  f7fffffe          BL       CLK_SysTickDelay
;;;419        spiGpioWriteReg(249, 0x46);
00002c  2146              MOVS     r1,#0x46
00002e  20f9              MOVS     r0,#0xf9
000030  f7fffffe          BL       spiGpioWriteReg
;;;420        CLK_SysTickDelay(50);
000034  2032              MOVS     r0,#0x32
000036  f7fffffe          BL       CLK_SysTickDelay
;;;421    #elif (SPI_IO_ORDER==2)
;;;422        //Write R248=8'b01,000,100, R249=8'b0,011,010,0
;;;423        //GPIO0[2:0]=4 - INT
;;;424        //GPIO1[2:0]=0 - CS
;;;425        //GPIO2[2:0]=1 - CK
;;;426        //GPIO3[2:0]=2 - MOSI
;;;427        //GPIO4[2:0]=3 - MISO
;;;428        CLK_SysTickDelay(50);
;;;429        spiGpioWriteReg(248, 4 | (0<<3) | ((1&0x03)<<6));
;;;430        CLK_SysTickDelay(50);
;;;431        spiGpioWriteReg(249, ((1&0x04)>>2) | (2<<1) | (3<<4));
;;;432        CLK_SysTickDelay(50);
;;;433    #elif (SPI_IO_ORDER==3)
;;;434        //Write R248=8'b00,100,011, R249=8'b0,010,001,0
;;;435        //GPIO0[2:0]=3 - MISO
;;;436        //GPIO1[2:0]=4 - INT
;;;437        //GPIO2[2:0]=0 - CS
;;;438        //GPIO3[2:0]=1 - CK
;;;439        //GPIO4[2:0]=2 - MOSI
;;;440        CLK_SysTickDelay(50);
;;;441        spiGpioWriteReg(248, 3 | (4<<3) | ((0&0x03)<<6));
;;;442        CLK_SysTickDelay(50);
;;;443        spiGpioWriteReg(249, ((0&0x04)>>2) | (1<<1) | (2<<4));
;;;444        CLK_SysTickDelay(50);
;;;445    #elif (SPI_IO_ORDER==4)
;;;446        //Write R248=8'b00,100,011, R249=8'b0,010,001,0
;;;447        //GPIO0[2:0]=2 - MOSI
;;;448        //GPIO1[2:0]=3 - MISO
;;;449        //GPIO2[2:0]=4 - INT
;;;450        //GPIO3[2:0]=0 - CS
;;;451        //GPIO4[2:0]=1 - CK
;;;452        CLK_SysTickDelay(50);
;;;453        spiGpioWriteReg(248, 2 | (3<<3) | ((4&0x03)<<6));
;;;454        CLK_SysTickDelay(50);
;;;455        spiGpioWriteReg(249, ((4&0x04)>>2) | (0<<1) | (1<<4));
;;;456        CLK_SysTickDelay(50);
;;;457    #elif (SPI_IO_ORDER==5)
;;;458        //Write R248=8'b00,100,011, R249=8'b0,010,001,0
;;;459        //GPIO0[2:0]=1 - CK
;;;460        //GPIO1[2:0]=2 - MOSI
;;;461        //GPIO2[2:0]=3 - MISO
;;;462        //GPIO3[2:0]=4 - INT
;;;463        //GPIO4[2:0]=0 - CS
;;;464        CLK_SysTickDelay(50);
;;;465        spiGpioWriteReg(248, 1 | (2<<3) | ((3&0x03)<<6));
;;;466        CLK_SysTickDelay(50);
;;;467        spiGpioWriteReg(249, ((3&0x04)>>2) | (4<<1) | (0<<4));
;;;468        CLK_SysTickDelay(50);
;;;469    #elif (SPI_IO_ORDER==6)   //for SIP 
;;;470        //Write R248=8'b01,000,100, R249=8'b0,010,011,0
;;;471        //GPIO0[2:0]=4 - INT
;;;472        //GPIO1[2:0]=0 - CS
;;;473        //GPIO2[2:0]=1 - CK
;;;474        //GPIO3[2:0]=3 - MISO
;;;475        //GPIO4[2:0]=2 - MOSI
;;;476        CLK_SysTickDelay(50);
;;;477        spiGpioWriteReg(248, 4 | (0<<3) | ((1&0x03)<<6));
;;;478        CLK_SysTickDelay(50);
;;;479        spiGpioWriteReg(249, ((1&0x04)>>2) | (3<<1) | (2<<4));
;;;480        CLK_SysTickDelay(50);
;;;481    #elif (SPI_IO_ORDER==7)   //for daughter board
;;;482        //Write R248=8'b10,001,000, R249=8'b0,100,011,0
;;;483        //GPIO0[2:0]=0 - CS
;;;484        //GPIO1[2:0]=1 - CLK
;;;485        //GPIO2[2:0]=3 - MISO
;;;486        //GPIO3[2:0]=2 - MOSI
;;;487        //GPIO4[2:0]=4 - INT
;;;488        CLK_SysTickDelay(50);
;;;489        spiGpioWriteReg(248, 0 | (1<<3) | ((3&0x03)<<6));
;;;490        CLK_SysTickDelay(50);
;;;491        spiGpioWriteReg(249, ((3&0x04)>>2) | (2<<1) | (4<<4));
;;;492        CLK_SysTickDelay(50);
;;;493    #endif
;;;494        //(3) Output all pin as HIGH, last 10ms(>1ms). trigger HW take effect
;;;495        SPI_GPIO_Init();          //Set all as output
00003a  f7fffffe          BL       SPI_GPIO_Init
;;;496        SPI_CS=1;
00003e  60e5              STR      r5,[r4,#0xc]
;;;497        SPI_CK=1;
000040  60a5              STR      r5,[r4,#8]
;;;498        SPI_MOSI=1;
000042  6025              STR      r5,[r4,#0]
;;;499        SPI_MISO=1;
000044  6065              STR      r5,[r4,#4]
;;;500        DEFAULT_INT=1;
000046  63f5              STR      r5,[r6,#0x3c]
;;;501        CLK_SysTickDelay(10000);        //Delay 10ms
000048  4c11              LDR      r4,|L10.144|
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       CLK_SysTickDelay
;;;502        //CLK_SysTickDelay(25000); //RF POR_Reset, delay 25ms, wait for 16M stable, then start RF_Init. Add the line when using HIRC
;;;503    
;;;504        //(4) Init GPIO & SPI
;;;505        //MCU_GpioIntEnable(); //configure ext_int GPIO pin. Not enable INT!
;;;506        MCU_GpioPinInit();        //Set GPIO interrupt pin as input
000050  f7fffffe          BL       MCU_GpioPinInit
;;;507        MCU_SpiInit();            //Intial SPI pin, change MISO direction as INPUT
000054  f7fffffe          BL       MCU_SpiInit
;;;508        //CLK_SysTickDelay(100);
;;;509        //SPI_Open(SPI0, SPI_MASTER, SPI_MODE_0, 8, 1000000); //1M clk
;;;510    
;;;511    #if (SPI_IO_ORDER==1)
;;;512        SPI_1BYT_SetTx(249, (0x46 | 0x80));  //set RF MISO, INT as output
000058  21c6              MOVS     r1,#0xc6
00005a  20f9              MOVS     r0,#0xf9
00005c  f7fffffe          BL       SPI_1BYT_SetTx
;;;513    #elif (SPI_IO_ORDER==2)
;;;514        SPI_1BYT_SetTx(249, ((1&0x04)>>2) | (2<<1) | (3<<4) | (1<<7));  //set RF MISO, INT as output
;;;515    #elif (SPI_IO_ORDER==3)
;;;516        SPI_1BYT_SetTx(249, ((0&0x04)>>2) | (1<<1) | (2<<4) | (1<<7));  //set RF MISO, INT as output
;;;517    #elif (SPI_IO_ORDER==4)
;;;518        SPI_1BYT_SetTx(249, ((4&0x04)>>2) | (0<<1) | (1<<4) | (1<<7));  //set RF MISO, INT as output
;;;519    #elif (SPI_IO_ORDER==5)
;;;520        SPI_1BYT_SetTx(249, ((3&0x04)>>2) | (4<<1) | (0<<4) | (1<<7));  //set RF MISO, INT as output
;;;521    #elif (SPI_IO_ORDER==6)  //for SIP
;;;522        SPI_1BYT_SetTx(249, ((1&0x04)>>2) | (3<<1) | (2<<4) | (1<<7));  //set RF MISO, INT as output
;;;523    #elif (SPI_IO_ORDER==7)  //for daughter board
;;;524        SPI_1BYT_SetTx(249, ((3&0x04)>>2) | (2<<1) | (4<<4) | (1<<7));  //set RF MISO, INT as output
;;;525    #endif
;;;526    
;;;527        //manual control
;;;528        SPI_1BYT_SetTx(53, 0xC0); //To gurantee DC/DC power on when set R40=0x90
000060  21c0              MOVS     r1,#0xc0
000062  2035              MOVS     r0,#0x35
000064  f7fffffe          BL       SPI_1BYT_SetTx
;;;529    
;;;530        //enable LDO
;;;531        SPI_1BYT_SetTx(40, 0xC0);
000068  21c0              MOVS     r1,#0xc0
00006a  2028              MOVS     r0,#0x28
00006c  f7fffffe          BL       SPI_1BYT_SetTx
;;;532        CLK_SysTickDelay(25000);        //Put delay after LDO_enable, or set register may have strange behavior!
000070  4808              LDR      r0,|L10.148|
000072  f7fffffe          BL       CLK_SysTickDelay
;;;533    
;;;534        //enable chip
;;;535        SPI_1BYT_SetTx(53, 0x80); //Enable chip
000076  2180              MOVS     r1,#0x80
000078  2035              MOVS     r0,#0x35
00007a  f7fffffe          BL       SPI_1BYT_SetTx
;;;536        CLK_SysTickDelay(10000);        //Put delay after chip_enable, or set register may have strange behavior!
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       CLK_SysTickDelay
;;;537    }
000084  bd70              POP      {r4-r6,pc}
;;;538    
                          ENDP

000086  0000              DCW      0x0000
                  |L10.136|
                          DCD      0x40004800
                  |L10.140|
                          DCD      0x40004940
                  |L10.144|
                          DCD      0x00002710
                  |L10.148|
                          DCD      0x000061a8

                          AREA ||i.SPI_GPIO_Init||, CODE, READONLY, ALIGN=2

                  SPI_GPIO_Init PROC
;;;360    
;;;361    void SPI_GPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;362    {
;;;363        //For SPI I/O remapping, set all GPIO pin as output
;;;364    #if (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031SE_)
;;;365        GPIO_SetMode(PA, BIT2, GPIO_MODE_OUTPUT);
;;;366        GPIO_SetMode(PA, BIT0, GPIO_MODE_OUTPUT);
;;;367        GPIO_SetMode(PA, BIT1, GPIO_MODE_OUTPUT);
;;;368        GPIO_SetMode(PA, BIT3, GPIO_MODE_OUTPUT);
;;;369        GPIO_SetMode(PA, BIT5, GPIO_MODE_OUTPUT);  //PA5
;;;370    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M032SE3AE_)
;;;371        GPIO_SetMode(PA, BIT2, GPIO_MODE_OUTPUT);
;;;372        GPIO_SetMode(PA, BIT0, GPIO_MODE_OUTPUT);
;;;373        GPIO_SetMode(PA, BIT1, GPIO_MODE_OUTPUT);
;;;374        GPIO_SetMode(PA, BIT3, GPIO_MODE_OUTPUT);
;;;375        GPIO_SetMode(PA, BIT5, GPIO_MODE_OUTPUT); //PA5
;;;376    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M487JIDAE_B3_)
;;;377        GPIO_SetMode(PA, BIT2, GPIO_MODE_OUTPUT);
;;;378        GPIO_SetMode(PA, BIT0, GPIO_MODE_OUTPUT);
;;;379        GPIO_SetMode(PA, BIT1, GPIO_MODE_OUTPUT);
;;;380        GPIO_SetMode(PA, BIT3, GPIO_MODE_OUTPUT);
;;;381        GPIO_SetMode(PC, BIT9, GPIO_MODE_OUTPUT); //PC9, EVK3
;;;382    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031TD2AE_QFN33_)
;;;383        GPIO_SetMode(PA, BIT2, GPIO_MODE_OUTPUT);
000002  4c0d              LDR      r4,|L11.56|
000004  2201              MOVS     r2,#1
000006  2104              MOVS     r1,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;384        GPIO_SetMode(PA, BIT0, GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;385        GPIO_SetMode(PA, BIT1, GPIO_MODE_OUTPUT);
000018  2201              MOVS     r2,#1
00001a  2102              MOVS     r1,#2
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;386        GPIO_SetMode(PA, BIT3, GPIO_MODE_OUTPUT);
000022  2201              MOVS     r2,#1
000024  2108              MOVS     r1,#8
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_SetMode
;;;387        GPIO_SetMode(PF, BIT15, GPIO_MODE_OUTPUT);  //PF15
00002c  2201              MOVS     r2,#1
00002e  03d1              LSLS     r1,r2,#15
000030  4802              LDR      r0,|L11.60|
000032  f7fffffe          BL       GPIO_SetMode
;;;388    #elif (_BOARD_SELECTION_ == _BOARD_NUVOTON_M031_SIP_)
;;;389        GPIO_SetMode(PD, BIT2, GPIO_MODE_OUTPUT);
;;;390        GPIO_SetMode(PD, BIT0, GPIO_MODE_OUTPUT);
;;;391        GPIO_SetMode(PD, BIT1, GPIO_MODE_OUTPUT);
;;;392        GPIO_SetMode(PD, BIT3, GPIO_MODE_OUTPUT);
;;;393        GPIO_SetMode(PC, BIT2, GPIO_MODE_OUTPUT);  //PC2
;;;394    #endif
;;;395    }
000036  bd10              POP      {r4,pc}
;;;396    
                          ENDP

                  |L11.56|
                          DCD      0x40004000
                  |L11.60|
                          DCD      0x40004140

                          AREA ||i.SYS_Disable_AnalogPORCircuit||, CODE, READONLY, ALIGN=2

                  SYS_Disable_AnalogPORCircuit PROC
;;;570    /*---------------------------------------------------------------------------------------------------------*/
;;;571    void SYS_Disable_AnalogPORCircuit(void)
000000  4902              LDR      r1,|L12.12|
;;;572    {
;;;573        SYS->PORDISAN = 0x5AA5;
000002  4801              LDR      r0,|L12.8|
000004  62c8              STR      r0,[r1,#0x2c]
;;;574    }
000006  4770              BX       lr
;;;575    
                          ENDP

                  |L12.8|
                          DCD      0x00005aa5
                  |L12.12|
                          DCD      0x400001c0

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1341     */
;;;1342   __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1343   {
;;;1344       do {
;;;1345           SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L13.24|
;;;1346           SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;1347           SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L13.10|
00000a  6001              STR      r1,[r0,#0]            ;1345
00000c  6002              STR      r2,[r0,#0]            ;1346
00000e  6003              STR      r3,[r0,#0]
;;;1348       } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L13.10|
;;;1349   }
000016  bd10              POP      {r4,pc}
;;;1350   
                          ENDP

                  |L13.24|
                          DCD      0x40000100

                          AREA ||i.System_PowerDown||, CODE, READONLY, ALIGN=2

                  System_PowerDown PROC
;;;581     ************************************************************************/
;;;582    void System_PowerDown(void)
000000  b510              PUSH     {r4,lr}
;;;583    {
;;;584        if(BleRFMode_Get() == BLERFMODE_SLEEP)  //RF_sleep
000002  f7fffffe          BL       BleRFMode_Get
000006  2801              CMP      r0,#1
000008  d002              BEQ      |L14.16|
;;;585        {
;;;586            /* Check if all the debug messages are finished */
;;;587            UART_WAIT_TX_EMPTY(UART0);
;;;588    
;;;589            /* Unlock protected registers before entering Power-down mode */
;;;590            SYS_UnlockReg();
;;;591    
;;;592            /* LVR must be enabled and the POR will be enabled automatically */
;;;593            SYS_ENABLE_LVR();
;;;594    
;;;595            /* Turn off internal analog POR circuit */
;;;596            SYS_Disable_AnalogPORCircuit();
;;;597    
;;;598            /* Disable Power-on Reset */
;;;599            SYS_DISABLE_POR();
;;;600    
;;;601            /* Enter to Power-down mode */
;;;602            CLK_PowerDown();
;;;603    
;;;604            /* Lock protected registers */
;;;605            SYS_LockReg();
;;;606        }
;;;607        else
;;;608        {
;;;609            CLK_Idle();
00000a  f7fffffe          BL       CLK_Idle
;;;610        }
;;;611    }
00000e  bd10              POP      {r4,pc}
                  |L14.16|
000010  480b              LDR      r0,|L14.64|
                  |L14.18|
000012  6981              LDR      r1,[r0,#0x18]         ;587
000014  00c9              LSLS     r1,r1,#3              ;587
000016  d5fc              BPL      |L14.18|
000018  f7fffffe          BL       SYS_UnlockReg
00001c  2001              MOVS     r0,#1                 ;593
00001e  0780              LSLS     r0,r0,#30             ;593
000020  6981              LDR      r1,[r0,#0x18]         ;593
000022  2280              MOVS     r2,#0x80              ;593
000024  4311              ORRS     r1,r1,r2              ;593
000026  6181              STR      r1,[r0,#0x18]         ;593
000028  4a07              LDR      r2,|L14.72|
00002a  4906              LDR      r1,|L14.68|
00002c  62d1              STR      r1,[r2,#0x2c]         ;593
00002e  6241              STR      r1,[r0,#0x24]         ;599
000030  f7fffffe          BL       CLK_PowerDown
000034  4904              LDR      r1,|L14.72|
000036  2000              MOVS     r0,#0                 ;602
000038  39c0              SUBS     r1,r1,#0xc0           ;602
00003a  6008              STR      r0,[r1,#0]            ;602
00003c  bd10              POP      {r4,pc}
;;;612    
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      0x40070000
                  |L14.68|
                          DCD      0x00005aa5
                  |L14.72|
                          DCD      0x400001c0

                          AREA ||i.UART1_SendData||, CODE, READONLY, ALIGN=2

                  UART1_SendData PROC
;;;612    
;;;613    void UART1_SendData(Uint8* data, Uint8 len)
000000  b510              PUSH     {r4,lr}
;;;614    {
;;;615        UART_Write(UART1,data,len);
000002  460a              MOV      r2,r1
000004  4c04              LDR      r4,|L15.24|
000006  4601              MOV      r1,r0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       UART_Write
                  |L15.14|
;;;616        UART_WAIT_TX_EMPTY(UART1);
00000e  69a0              LDR      r0,[r4,#0x18]
000010  00c0              LSLS     r0,r0,#3
000012  d5fc              BPL      |L15.14|
;;;617    }
000014  bd10              POP      {r4,pc}
;;;618    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40071000

                          AREA ||i._CLK_Idle||, CODE, READONLY, ALIGN=2

                  _CLK_Idle PROC
;;;554    //------------------- CLK function -----------------------//
;;;555    void _CLK_Idle(void)
000000  4807              LDR      r0,|L16.32|
;;;556    {
;;;557        /* Set the processor uses sleep as its low power mode */
;;;558        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;559        SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
00000a  6901              LDR      r1,[r0,#0x10]
00000c  2210              MOVS     r2,#0x10
00000e  4311              ORRS     r1,r1,r2
000010  6101              STR      r1,[r0,#0x10]
;;;560    
;;;561        /* Set chip in idle mode because of WFI command */
;;;562        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
000012  4804              LDR      r0,|L16.36|
000014  6801              LDR      r1,[r0,#0]
000016  2280              MOVS     r2,#0x80
000018  4391              BICS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;563    
;;;564        /* Chip enter idle mode after CPU run WFI instruction */
;;;565        __WFE();
00001c  bf20              WFE      
;;;566    }
00001e  4770              BX       lr
;;;567    
                          ENDP

                  |L16.32|
                          DCD      0xe000ed00
                  |L16.36|
                          DCD      0x40000200

                          AREA ||i.spiGpioDelay||, CODE, READONLY, ALIGN=1

                  spiGpioDelay PROC
;;;284     **************************************************************************************/
;;;285    void spiGpioDelay(void)
000000  b510              PUSH     {r4,lr}
;;;286    {
;;;287        CLK_SysTickDelay(1);   //one 1M cycle=1us
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       CLK_SysTickDelay
;;;288    }
000008  bd10              POP      {r4,pc}
;;;289    
                          ENDP


                          AREA ||i.spiGpioWriteReg||, CODE, READONLY, ALIGN=2

                  spiGpioWriteReg PROC
;;;289    
;;;290    void spiGpioWriteReg(const unsigned char regAddr, const unsigned char regData)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;291    {
;;;292    
;;;293        unsigned char SPICount;                               // Counter used to clock out the data
;;;294        unsigned char SPIData;                                // Define a data structure for the SPI data.
;;;295    
;;;296        SPI_CS = 1;                                           // Make sure we start with /CS high
000002  4e2c              LDR      r6,|L18.180|
000004  b081              SUB      sp,sp,#4              ;291
000006  2001              MOVS     r0,#1
000008  60f0              STR      r0,[r6,#0xc]
;;;297        SPI_CK = 0;                                           // and CK low
00000a  2700              MOVS     r7,#0
00000c  60b7              STR      r7,[r6,#8]
;;;298    
;;;299        SPI_CS = 0;                                           // Set /CS low to start the SPI cycle 25nS
00000e  60f7              STR      r7,[r6,#0xc]
000010  f7fffffe          BL       CLK_SysTickDelay
;;;300        // Although SPIData could be implemented as an "int", resulting in one
;;;301        // loop, the routines run faster when two loops are implemented with
;;;302        // SPIData implemented as two "char"s.
;;;303    
;;;304        spiGpioDelay();
;;;305    
;;;306        //Address 1th byte
;;;307        SPIData = regAddr & 0x7F;
000014  9801              LDR      r0,[sp,#4]
;;;308        for (SPICount = 0; SPICount < 8; SPICount++)          // Prepare to clock out the Address byte
000016  2400              MOVS     r4,#0
000018  0645              LSLS     r5,r0,#25             ;307
00001a  0e6d              LSRS     r5,r5,#25             ;307
00001c  2701              MOVS     r7,#1                 ;296
                  |L18.30|
;;;309        {
;;;310            if (SPIData & 0x80)                                 // Check for a 1
00001e  0628              LSLS     r0,r5,#24
000020  d501              BPL      |L18.38|
;;;311                SPI_MOSI = 1;                                     // and set the MOSI line appropriately
000022  6037              STR      r7,[r6,#0]
000024  e001              B        |L18.42|
                  |L18.38|
;;;312            else
;;;313                SPI_MOSI = 0;
000026  2000              MOVS     r0,#0
000028  6030              STR      r0,[r6,#0]
                  |L18.42|
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       CLK_SysTickDelay
;;;314    
;;;315            spiGpioDelay();                                     // delay half clk cycle
;;;316            SPI_CK = 1;                                         // Toggle the clock line
000030  60b7              STR      r7,[r6,#8]
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       CLK_SysTickDelay
;;;317            spiGpioDelay();
;;;318            SPI_CK = 0;
000038  2000              MOVS     r0,#0
00003a  60b0              STR      r0,[r6,#8]
;;;319            SPIData <<= 1;                                      // Rotate to get the next bit
00003c  0669              LSLS     r1,r5,#25
00003e  1c64              ADDS     r4,r4,#1
000040  0e0d              LSRS     r5,r1,#24
000042  b2e4              UXTB     r4,r4                 ;308
000044  2c08              CMP      r4,#8                 ;308
000046  d3ea              BCC      |L18.30|
;;;320        }                                                     // and loop back to send the next bit
;;;321        // Repeat for the Data byte
;;;322        //Address 2nd byte
;;;323        SPIData = (regAddr & 0x80)>>7;
000048  9901              LDR      r1,[sp,#4]
00004a  09cd              LSRS     r5,r1,#7
;;;324        for (SPICount = 0; SPICount < 8; SPICount++)          // Prepare to clock out the Address byte
00004c  2400              MOVS     r4,#0
                  |L18.78|
;;;325        {
;;;326            if (SPIData & 0x80)                                 // Check for a 1
00004e  0628              LSLS     r0,r5,#24
000050  d501              BPL      |L18.86|
;;;327                SPI_MOSI = 1;                                     // and set the MOSI line appropriately
000052  6037              STR      r7,[r6,#0]
000054  e001              B        |L18.90|
                  |L18.86|
;;;328            else
;;;329                SPI_MOSI = 0;
000056  2000              MOVS     r0,#0
000058  6030              STR      r0,[r6,#0]
                  |L18.90|
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       CLK_SysTickDelay
;;;330    
;;;331            spiGpioDelay();                                     // delay half clk cycle
;;;332            SPI_CK = 1;                                         // Toggle the clock line
000060  60b7              STR      r7,[r6,#8]
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       CLK_SysTickDelay
;;;333            spiGpioDelay();
;;;334            SPI_CK = 0;
000068  2000              MOVS     r0,#0
00006a  60b0              STR      r0,[r6,#8]
;;;335            SPIData <<= 1;                                      // Rotate to get the next bit
00006c  0669              LSLS     r1,r5,#25
00006e  1c64              ADDS     r4,r4,#1
000070  0e0d              LSRS     r5,r1,#24
000072  b2e4              UXTB     r4,r4                 ;324
000074  2c08              CMP      r4,#8                 ;324
000076  d3ea              BCC      |L18.78|
;;;336        }
;;;337    
;;;338        //Data
;;;339        SPIData = regData;                                    // Preload the data to be sent with Data
;;;340        for (SPICount = 0; SPICount < 8; SPICount++)          // Prepare to clock out the Data
000078  9d02              LDR      r5,[sp,#8]
00007a  2400              MOVS     r4,#0
                  |L18.124|
;;;341        {
;;;342            if (SPIData & 0x80)
00007c  0628              LSLS     r0,r5,#24
00007e  d501              BPL      |L18.132|
;;;343                SPI_MOSI = 1;
000080  6037              STR      r7,[r6,#0]
000082  e001              B        |L18.136|
                  |L18.132|
;;;344            else
;;;345                SPI_MOSI = 0;
000084  2000              MOVS     r0,#0
000086  6030              STR      r0,[r6,#0]
                  |L18.136|
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       CLK_SysTickDelay
;;;346    
;;;347            spiGpioDelay();
;;;348            SPI_CK = 1;
00008e  60b7              STR      r7,[r6,#8]
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       CLK_SysTickDelay
;;;349            spiGpioDelay();
;;;350            SPI_CK = 0;
000096  2000              MOVS     r0,#0
000098  60b0              STR      r0,[r6,#8]
;;;351            SPIData <<= 1;
00009a  0668              LSLS     r0,r5,#25
00009c  1c64              ADDS     r4,r4,#1
00009e  0e05              LSRS     r5,r0,#24
0000a0  b2e4              UXTB     r4,r4                 ;340
0000a2  2c08              CMP      r4,#8                 ;340
0000a4  d3ea              BCC      |L18.124|
0000a6  2001              MOVS     r0,#1                 ;340
0000a8  f7fffffe          BL       CLK_SysTickDelay
;;;352        }
;;;353    
;;;354        spiGpioDelay();
;;;355    
;;;356        SPI_CS = 1;
0000ac  60f7              STR      r7,[r6,#0xc]
;;;357        SPI_MOSI = 0;
0000ae  2000              MOVS     r0,#0
0000b0  6030              STR      r0,[r6,#0]
;;;358    }
0000b2  bdfe              POP      {r1-r7,pc}
;;;359    
                          ENDP

                  |L18.180|
                          DCD      0x40004800

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\porting\\porting_misc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_porting_misc_c_a8a7f0ef____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_porting_misc_c_a8a7f0ef____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_porting_misc_c_a8a7f0ef____REVSH|
#line 402
|__asm___14_porting_misc_c_a8a7f0ef____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
