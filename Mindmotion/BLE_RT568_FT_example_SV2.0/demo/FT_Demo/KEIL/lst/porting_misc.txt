; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\porting_misc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\porting_misc.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\include -I..\..\..\porting -I..\..\..\include\rf_include -I..\..\..\porting\rf_porting -I..\..\FT_Demo -I..\FT_Func -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\porting_misc.crf ..\..\..\porting\porting_misc.c]
                          THUMB

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;503      */
;;;504    __STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L1.28|
;;;505    {
;;;506        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L1.32|
000008  6148              STR      r0,[r1,#0x14]
;;;507        SysTick->VAL  = (0x00);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;508        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L1.18|
;;;509    
;;;510        /* Waiting for down-count to zero */
;;;511        while ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L1.18|
;;;512    
;;;513        /* Disable SysTick counter */
;;;514        SysTick->CTRL = 0;
000018  610a              STR      r2,[r1,#0x10]
;;;515    }
00001a  4770              BX       lr
;;;516    
                          ENDP

                  |L1.28|
                          DCD      CyclesPerUs
                  |L1.32|
                          DCD      0xe000e000

                          AREA ||i.GPCDEF_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPCDEF_IRQHandler PROC
;;;68     #pragma Otime
;;;69     void GPCDEF_IRQHandler(void) __irq
000000  b508              PUSH     {r3,lr}
;;;70     {
;;;71         volatile uint32_t temp;
;;;72         extern void LL_GPIO_Isr(void);
;;;73     
;;;74         //Clear MCU GPIO Int status
;;;75         if(GPIO_GET_INT_FLAG(PF, BIT15))
000002  4806              LDR      r0,|L2.28|
000004  6a01              LDR      r1,[r0,#0x20]
000006  0409              LSLS     r1,r1,#16
000008  d501              BPL      |L2.14|
;;;76         {
;;;77             GPIO_CLR_INT_FLAG(PF, BIT15);
00000a  13c1              ASRS     r1,r0,#15
00000c  e001              B        |L2.18|
                  |L2.14|
;;;78         }
;;;79         else
;;;80         {
;;;81             // Un-expected interrupt. Just clear all PF interrupts
;;;82             temp = PF->INTSRC;
00000e  6a01              LDR      r1,[r0,#0x20]
000010  9100              STR      r1,[sp,#0]
                  |L2.18|
;;;83             PF->INTSRC = temp;
000012  6201              STR      r1,[r0,#0x20]
;;;84         }
;;;85     
;;;86         LL_GPIO_Isr();      // Put this on the top following the clearing MCU GPIO Int status process.
000014  f7fffffe          BL       LL_GPIO_Isr
;;;87     
;;;88     }
000018  bd08              POP      {r3,pc}
;;;89     #pragma pop
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40004140

                          AREA ||i.MCU_GpioIntDisable||, CODE, READONLY, ALIGN=2

                  MCU_GpioIntDisable PROC
;;;58     
;;;59     void MCU_GpioIntDisable(void)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61         GPIO_DisableInt(PF, 15);
000002  210f              MOVS     r1,#0xf
000004  4803              LDR      r0,|L3.20|
000006  f7fffffe          BL       GPIO_DisableInt
00000a  4903              LDR      r1,|L3.24|
00000c  2020              MOVS     r0,#0x20
00000e  6008              STR      r0,[r1,#0]
;;;62         NVIC_DisableIRQ(GPIO_PCPDPEPF_IRQn);          //disable irq in nvic
;;;63     }
000010  bd10              POP      {r4,pc}
;;;64     
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40004140
                  |L3.24|
                          DCD      0xe000e180

                          AREA ||i.MCU_GpioIntEnable||, CODE, READONLY, ALIGN=2

                  MCU_GpioIntEnable PROC
;;;39     
;;;40     void MCU_GpioIntEnable(void)
000000  b510              PUSH     {r4,lr}
;;;41     {
;;;42         // Configure PF.15 as Input mode and enable interrupt by rising edge trigger
;;;43         GPIO_SetMode(PF, BIT15, GPIO_MODE_INPUT);
000002  4c0b              LDR      r4,|L4.48|
000004  2101              MOVS     r1,#1
000006  2200              MOVS     r2,#0
000008  03c9              LSLS     r1,r1,#15
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       GPIO_SetMode
;;;44     
;;;45         if(ChipId_Get()==MP_A1)
000010  f7fffffe          BL       ChipId_Get
000014  2866              CMP      r0,#0x66
000016  d008              BEQ      |L4.42|
;;;46         {
;;;47             GPIO_EnableInt(PF, 15, GPIO_INT_RISING);
;;;48         }
;;;49         else
;;;50         {
;;;51             GPIO_EnableInt(PF, 15, GPIO_INT_HIGH);
000018  4a06              LDR      r2,|L4.52|
                  |L4.26|
00001a  210f              MOVS     r1,#0xf
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_EnableInt
000022  4905              LDR      r1,|L4.56|
000024  2020              MOVS     r0,#0x20
000026  6008              STR      r0,[r1,#0]
;;;52         }
;;;53         NVIC_EnableIRQ(GPIO_PCPDPEPF_IRQn);
;;;54     
;;;55     
;;;56     }
000028  bd10              POP      {r4,pc}
                  |L4.42|
00002a  2201              MOVS     r2,#1                 ;47
00002c  0412              LSLS     r2,r2,#16             ;47
00002e  e7f4              B        |L4.26|
;;;57     
                          ENDP

                  |L4.48|
                          DCD      0x40004140
                  |L4.52|
                          DCD      0x01010000
                  |L4.56|
                          DCD      0xe000e100

                          AREA ||i.MCU_GpioPinInit||, CODE, READONLY, ALIGN=2

                  MCU_GpioPinInit PROC
;;;34     //Assign GPIO INT pin, LED pin
;;;35     void MCU_GpioPinInit(void)
000000  b510              PUSH     {r4,lr}
;;;36     {
;;;37         GPIO_SetMode(PF, BIT15, GPIO_MODE_INPUT);
000002  2101              MOVS     r1,#1
000004  2200              MOVS     r2,#0
000006  03c9              LSLS     r1,r1,#15
000008  4801              LDR      r0,|L5.16|
00000a  f7fffffe          BL       GPIO_SetMode
;;;38     }
00000e  bd10              POP      {r4,pc}
;;;39     
                          ENDP

                  |L5.16|
                          DCD      0x40004140

                          AREA ||i.MCU_GpioReset||, CODE, READONLY, ALIGN=2

                  MCU_GpioReset PROC
;;;21     
;;;22     void MCU_GpioReset(void)
000000  b570              PUSH     {r4-r6,lr}
;;;23     {
;;;24         //Do Reset: pulse low
;;;25         RESET_RF = 1;
000002  4c07              LDR      r4,|L6.32|
000004  2501              MOVS     r5,#1
000006  6065              STR      r5,[r4,#4]
;;;26         CLK_SysTickDelay(1000);       //1ms
000008  267d              MOVS     r6,#0x7d
00000a  00f6              LSLS     r6,r6,#3
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       CLK_SysTickDelay
;;;27     
;;;28         RESET_RF = 0;
000012  2000              MOVS     r0,#0
000014  6060              STR      r0,[r4,#4]
;;;29         CLK_SysTickDelay(1000);       //1ms
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       CLK_SysTickDelay
;;;30     
;;;31         RESET_RF = 1;
00001c  6065              STR      r5,[r4,#4]
;;;32     }
00001e  bd70              POP      {r4-r6,pc}
;;;33     
                          ENDP

                  |L6.32|
                          DCD      0x40004880

                          AREA ||i.MCU_GpioResetInit||, CODE, READONLY, ALIGN=2

                  MCU_GpioResetInit PROC
;;;13     /*-------------------- GPIO peripheral ---------------------*/
;;;14     void MCU_GpioResetInit(void)
000000  b510              PUSH     {r4,lr}
;;;15     {
;;;16     
;;;17         GPIO_SetMode(PC, BIT1, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  2102              MOVS     r1,#2
000006  4803              LDR      r0,|L7.20|
000008  f7fffffe          BL       GPIO_SetMode
;;;18     
;;;19         RESET_RF = 1;  //RESET_RF defined in porting_misc.h//IRQ¸´Î»Òý½ÅPC1
00000c  4902              LDR      r1,|L7.24|
00000e  2001              MOVS     r0,#1
000010  6048              STR      r0,[r1,#4]
;;;20     }
000012  bd10              POP      {r4,pc}
;;;21     
                          ENDP

                  |L7.20|
                          DCD      0x40004080
                  |L7.24|
                          DCD      0x40004880

                          AREA ||i.RF_SpiIoMapping||, CODE, READONLY, ALIGN=2

                  RF_SpiIoMapping PROC
;;;182    //SPI IO mapping. Must do this after Power ON
;;;183    void RF_SpiIoMapping(void)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
;;;185        //(1) Set all SPI GPIO pin as output. Be careful not to set 5 pins as HIGH, it will trigger HW mapping SPI pin
;;;186        SPI_GPIO_Init();         //Here set all CLK,CS,MOSI,NISO,INT as output
000002  f7fffffe          BL       SPI_GPIO_Init
;;;187        SPI_CS=1;
000006  4c20              LDR      r4,|L8.136|
000008  2501              MOVS     r5,#1
00000a  60e5              STR      r5,[r4,#0xc]
;;;188        SPI_CK=0;
00000c  2000              MOVS     r0,#0
00000e  60a0              STR      r0,[r4,#8]
;;;189        SPI_MOSI=0;
000010  6020              STR      r0,[r4,#0]
;;;190        SPI_MISO=0;
000012  6060              STR      r0,[r4,#4]
;;;191        DEFAULT_INT=0;
000014  4e1d              LDR      r6,|L8.140|
000016  63f0              STR      r0,[r6,#0x3c]
;;;192        //(2) Write R248, R249 GPIO select
;;;193        //Write R248=8'b10,001,000, R249=8'b0,100,011,0
;;;194        //GPIO0[2:0]=0 - CS
;;;195        //GPIO1[2:0]=1 - CLK
;;;196        //GPIO2[2:0]=2 - MOSI
;;;197        //GPIO3[2:0]=3 - MISO
;;;198        //GPIO4[2:0]=4 - INT
;;;199        CLK_SysTickDelay(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       CLK_SysTickDelay
;;;200        spiGpioWriteReg(248, 0x88);
00001e  2188              MOVS     r1,#0x88
000020  20f8              MOVS     r0,#0xf8
000022  f7fffffe          BL       spiGpioWriteReg
;;;201        CLK_SysTickDelay(50);
000026  2032              MOVS     r0,#0x32
000028  f7fffffe          BL       CLK_SysTickDelay
;;;202        spiGpioWriteReg(249, 0x46);
00002c  2146              MOVS     r1,#0x46
00002e  20f9              MOVS     r0,#0xf9
000030  f7fffffe          BL       spiGpioWriteReg
;;;203        CLK_SysTickDelay(50);
000034  2032              MOVS     r0,#0x32
000036  f7fffffe          BL       CLK_SysTickDelay
;;;204    
;;;205        //(3) Output all pin as HIGH, last 10ms(>1ms). trigger HW take effect
;;;206        SPI_GPIO_Init();          //Set all as output
00003a  f7fffffe          BL       SPI_GPIO_Init
;;;207        SPI_CS=1;
00003e  60e5              STR      r5,[r4,#0xc]
;;;208        SPI_CK=1;
000040  60a5              STR      r5,[r4,#8]
;;;209        SPI_MOSI=1;
000042  6025              STR      r5,[r4,#0]
;;;210        SPI_MISO=1;
000044  6065              STR      r5,[r4,#4]
;;;211        DEFAULT_INT=1;
000046  63f5              STR      r5,[r6,#0x3c]
;;;212        CLK_SysTickDelay(10000);  //Delay 10ms
000048  4c11              LDR      r4,|L8.144|
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       CLK_SysTickDelay
;;;213        //(4) Init GPIO & SPI
;;;214        MCU_GpioPinInit();        //Set GPIO interrupt pin as input
000050  f7fffffe          BL       MCU_GpioPinInit
;;;215        MCU_SpiInit();            //Intial SPI pin, change MISO direction as INPUT
000054  f7fffffe          BL       MCU_SpiInit
;;;216    
;;;217        SPI_1BYT_SetTx(249, (0x46 | 0x80));  //set RF MISO, INT as output
000058  21c6              MOVS     r1,#0xc6
00005a  20f9              MOVS     r0,#0xf9
00005c  f7fffffe          BL       SPI_1BYT_SetTx
;;;218    
;;;219        //manual control
;;;220        SPI_1BYT_SetTx(53, 0xC0); //To gurantee DC/DC power on when set R40=0x90
000060  21c0              MOVS     r1,#0xc0
000062  2035              MOVS     r0,#0x35
000064  f7fffffe          BL       SPI_1BYT_SetTx
;;;221    
;;;222        //enable LDO
;;;223        SPI_1BYT_SetTx(40, 0xC0);
000068  21c0              MOVS     r1,#0xc0
00006a  2028              MOVS     r0,#0x28
00006c  f7fffffe          BL       SPI_1BYT_SetTx
;;;224        CLK_SysTickDelay(25000);        //Put delay after LDO_enable, or set register may have strange behavior!
000070  4808              LDR      r0,|L8.148|
000072  f7fffffe          BL       CLK_SysTickDelay
;;;225    
;;;226        //enable chip
;;;227        SPI_1BYT_SetTx(53, 0x80); //Enable chip
000076  2180              MOVS     r1,#0x80
000078  2035              MOVS     r0,#0x35
00007a  f7fffffe          BL       SPI_1BYT_SetTx
;;;228        CLK_SysTickDelay(10000);        //Put delay after chip_enable, or set register may have strange behavior!
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       CLK_SysTickDelay
;;;229    }
000084  bd70              POP      {r4-r6,pc}
                          ENDP

000086  0000              DCW      0x0000
                  |L8.136|
                          DCD      0x40004800
                  |L8.140|
                          DCD      0x40004940
                  |L8.144|
                          DCD      0x00002710
                  |L8.148|
                          DCD      0x000061a8

                          AREA ||i.SPI_GPIO_Init||, CODE, READONLY, ALIGN=2

                  SPI_GPIO_Init PROC
;;;172    
;;;173    void SPI_GPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;174    {
;;;175        GPIO_SetMode(PA, BIT2, GPIO_MODE_OUTPUT);
000002  4c0d              LDR      r4,|L9.56|
000004  2201              MOVS     r2,#1
000006  2104              MOVS     r1,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;176        GPIO_SetMode(PA, BIT0, GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;177        GPIO_SetMode(PA, BIT1, GPIO_MODE_OUTPUT);
000018  2201              MOVS     r2,#1
00001a  2102              MOVS     r1,#2
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;178        GPIO_SetMode(PA, BIT3, GPIO_MODE_OUTPUT);
000022  2201              MOVS     r2,#1
000024  2108              MOVS     r1,#8
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_SetMode
;;;179        GPIO_SetMode(PF, BIT15, GPIO_MODE_OUTPUT);  //PF15
00002c  2201              MOVS     r2,#1
00002e  03d1              LSLS     r1,r2,#15
000030  4802              LDR      r0,|L9.60|
000032  f7fffffe          BL       GPIO_SetMode
;;;180    }
000036  bd10              POP      {r4,pc}
;;;181    
                          ENDP

                  |L9.56|
                          DCD      0x40004000
                  |L9.60|
                          DCD      0x40004140

                          AREA ||i.spiGpioDelay||, CODE, READONLY, ALIGN=1

                  spiGpioDelay PROC
;;;96      **************************************************************************************/
;;;97     void spiGpioDelay(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99         CLK_SysTickDelay(1);   //one 1M cycle=1us
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       CLK_SysTickDelay
;;;100    }
000008  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i.spiGpioWriteReg||, CODE, READONLY, ALIGN=2

                  spiGpioWriteReg PROC
;;;101    
;;;102    void spiGpioWriteReg(const unsigned char regAddr, const unsigned char regData)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;103    {
;;;104    
;;;105        unsigned char SPICount;                               // Counter used to clock out the data
;;;106        unsigned char SPIData;                                // Define a data structure for the SPI data.
;;;107    
;;;108        SPI_CS = 1;                                           // Make sure we start with /CS high
000002  4e2c              LDR      r6,|L11.180|
000004  b081              SUB      sp,sp,#4              ;103
000006  2001              MOVS     r0,#1
000008  60f0              STR      r0,[r6,#0xc]
;;;109        SPI_CK = 0;                                           // and CK low
00000a  2700              MOVS     r7,#0
00000c  60b7              STR      r7,[r6,#8]
;;;110    
;;;111        SPI_CS = 0;                                           // Set /CS low to start the SPI cycle 25nS
00000e  60f7              STR      r7,[r6,#0xc]
000010  f7fffffe          BL       CLK_SysTickDelay
;;;112        // Although SPIData could be implemented as an "int", resulting in one
;;;113        // loop, the routines run faster when two loops are implemented with
;;;114        // SPIData implemented as two "char"s.
;;;115    
;;;116        spiGpioDelay();
;;;117    
;;;118        //Address 1th byte
;;;119        SPIData = regAddr & 0x7F;
000014  9801              LDR      r0,[sp,#4]
;;;120        for (SPICount = 0; SPICount < 8; SPICount++)          // Prepare to clock out the Address byte
000016  2400              MOVS     r4,#0
000018  0645              LSLS     r5,r0,#25             ;119
00001a  0e6d              LSRS     r5,r5,#25             ;119
00001c  2701              MOVS     r7,#1                 ;108
                  |L11.30|
;;;121        {
;;;122            if (SPIData & 0x80)                                 // Check for a 1
00001e  0628              LSLS     r0,r5,#24
000020  d501              BPL      |L11.38|
;;;123                SPI_MOSI = 1;                                     // and set the MOSI line appropriately
000022  6037              STR      r7,[r6,#0]
000024  e001              B        |L11.42|
                  |L11.38|
;;;124            else
;;;125                SPI_MOSI = 0;
000026  2000              MOVS     r0,#0
000028  6030              STR      r0,[r6,#0]
                  |L11.42|
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       CLK_SysTickDelay
;;;126    
;;;127            spiGpioDelay();                                     // delay half clk cycle
;;;128            SPI_CK = 1;                                         // Toggle the clock line
000030  60b7              STR      r7,[r6,#8]
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       CLK_SysTickDelay
;;;129            spiGpioDelay();
;;;130            SPI_CK = 0;
000038  2000              MOVS     r0,#0
00003a  60b0              STR      r0,[r6,#8]
;;;131            SPIData <<= 1;                                      // Rotate to get the next bit
00003c  0669              LSLS     r1,r5,#25
00003e  1c64              ADDS     r4,r4,#1
000040  0e0d              LSRS     r5,r1,#24
000042  b2e4              UXTB     r4,r4                 ;120
000044  2c08              CMP      r4,#8                 ;120
000046  d3ea              BCC      |L11.30|
;;;132        }                                                     // and loop back to send the next bit
;;;133        // Repeat for the Data byte
;;;134        //Address 2nd byte
;;;135        SPIData = (regAddr & 0x80)>>7;
000048  9901              LDR      r1,[sp,#4]
00004a  09cd              LSRS     r5,r1,#7
;;;136        for (SPICount = 0; SPICount < 8; SPICount++)          // Prepare to clock out the Address byte
00004c  2400              MOVS     r4,#0
                  |L11.78|
;;;137        {
;;;138            if (SPIData & 0x80)                                 // Check for a 1
00004e  0628              LSLS     r0,r5,#24
000050  d501              BPL      |L11.86|
;;;139                SPI_MOSI = 1;                                     // and set the MOSI line appropriately
000052  6037              STR      r7,[r6,#0]
000054  e001              B        |L11.90|
                  |L11.86|
;;;140            else
;;;141                SPI_MOSI = 0;
000056  2000              MOVS     r0,#0
000058  6030              STR      r0,[r6,#0]
                  |L11.90|
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       CLK_SysTickDelay
;;;142    
;;;143            spiGpioDelay();                                     // delay half clk cycle
;;;144            SPI_CK = 1;                                         // Toggle the clock line
000060  60b7              STR      r7,[r6,#8]
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       CLK_SysTickDelay
;;;145            spiGpioDelay();
;;;146            SPI_CK = 0;
000068  2000              MOVS     r0,#0
00006a  60b0              STR      r0,[r6,#8]
;;;147            SPIData <<= 1;                                      // Rotate to get the next bit
00006c  0669              LSLS     r1,r5,#25
00006e  1c64              ADDS     r4,r4,#1
000070  0e0d              LSRS     r5,r1,#24
000072  b2e4              UXTB     r4,r4                 ;136
000074  2c08              CMP      r4,#8                 ;136
000076  d3ea              BCC      |L11.78|
;;;148        }
;;;149    
;;;150        //Data
;;;151        SPIData = regData;                                    // Preload the data to be sent with Data
;;;152        for (SPICount = 0; SPICount < 8; SPICount++)          // Prepare to clock out the Data
000078  9d02              LDR      r5,[sp,#8]
00007a  2400              MOVS     r4,#0
                  |L11.124|
;;;153        {
;;;154            if (SPIData & 0x80)
00007c  0628              LSLS     r0,r5,#24
00007e  d501              BPL      |L11.132|
;;;155                SPI_MOSI = 1;
000080  6037              STR      r7,[r6,#0]
000082  e001              B        |L11.136|
                  |L11.132|
;;;156            else
;;;157                SPI_MOSI = 0;
000084  2000              MOVS     r0,#0
000086  6030              STR      r0,[r6,#0]
                  |L11.136|
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       CLK_SysTickDelay
;;;158    
;;;159            spiGpioDelay();
;;;160            SPI_CK = 1;
00008e  60b7              STR      r7,[r6,#8]
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       CLK_SysTickDelay
;;;161            spiGpioDelay();
;;;162            SPI_CK = 0;
000096  2000              MOVS     r0,#0
000098  60b0              STR      r0,[r6,#8]
;;;163            SPIData <<= 1;
00009a  0668              LSLS     r0,r5,#25
00009c  1c64              ADDS     r4,r4,#1
00009e  0e05              LSRS     r5,r0,#24
0000a0  b2e4              UXTB     r4,r4                 ;152
0000a2  2c08              CMP      r4,#8                 ;152
0000a4  d3ea              BCC      |L11.124|
0000a6  2001              MOVS     r0,#1                 ;152
0000a8  f7fffffe          BL       CLK_SysTickDelay
;;;164        }
;;;165    
;;;166        spiGpioDelay();
;;;167    
;;;168        SPI_CS = 1;
0000ac  60f7              STR      r7,[r6,#0xc]
;;;169        SPI_MOSI = 0;
0000ae  2000              MOVS     r0,#0
0000b0  6030              STR      r0,[r6,#0]
;;;170    }
0000b2  bdfe              POP      {r1-r7,pc}
;;;171    
                          ENDP

                  |L11.180|
                          DCD      0x40004800

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\porting\\porting_misc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_porting_misc_c_a8a7f0ef____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_porting_misc_c_a8a7f0ef____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_porting_misc_c_a8a7f0ef____REVSH|
#line 402
|__asm___14_porting_misc_c_a8a7f0ef____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
