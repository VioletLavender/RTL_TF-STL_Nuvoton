; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\porting_spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\porting_spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\include -I..\..\..\porting -I..\..\..\include\rf_include -I..\..\..\porting\rf_porting -I..\..\FT_Demo -I..\FT_Func -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\porting_spi.crf ..\..\..\porting\porting_spi.c]
                          THUMB

                          AREA ||i.MCU_SpiInit||, CODE, READONLY, ALIGN=2

                  MCU_SpiInit PROC
;;;23     //Initial SPI clock and pin
;;;24     void MCU_SpiInit(void)
000000  b538              PUSH     {r3-r5,lr}
;;;25     {
;;;26         /* Select PCLK1 as the clock source of SPI0*/
;;;27         CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
000002  4c11              LDR      r4,|L1.72|
000004  2200              MOVS     r2,#0
000006  2120              MOVS     r1,#0x20
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       CLK_SetModuleClock
;;;28         /* Enable SPI0 peripheral clock */
;;;29         CLK_EnableModuleClock(SPI0_MODULE);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       CLK_EnableModuleClock
;;;30         /* Enable PDMA clock source */
;;;31         CLK_EnableModuleClock(PDMA_MODULE);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       CLK_EnableModuleClock
;;;32     
;;;33         /* MCU SPI pin initialization */
;;;34         // Setup SPI0 multi-function pins //
;;;35         // PA.3 is SPI0_SS,   PA.2 is SPI0_CLK,
;;;36         // PA.1 is SPI0_MISO, PA.0 is SPI0_MOSI
;;;37         SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA3MFP_Msk |
00001a  07a0              LSLS     r0,r4,#30
00001c  6b01              LDR      r1,[r0,#0x30]
00001e  4a0b              LDR      r2,|L1.76|
000020  0c09              LSRS     r1,r1,#16
000022  0409              LSLS     r1,r1,#16
000024  1889              ADDS     r1,r1,r2
000026  6301              STR      r1,[r0,#0x30]
;;;38                                            SYS_GPA_MFPL_PA2MFP_Msk |
;;;39                                            SYS_GPA_MFPL_PA1MFP_Msk |
;;;40                                            SYS_GPA_MFPL_PA0MFP_Msk)) |
;;;41                         (SYS_GPA_MFPL_PA3MFP_SPI0_SS |
;;;42                          SYS_GPA_MFPL_PA2MFP_SPI0_CLK |
;;;43                          SYS_GPA_MFPL_PA1MFP_SPI0_MISO |
;;;44                          SYS_GPA_MFPL_PA0MFP_SPI0_MOSI);
;;;45     
;;;46     
;;;47         /* SPI master, clk=8M, mode 0, 8-bit, MSB first */
;;;48         SPI_Open(SPI0, SPI_MASTER, SPI_MODE_0, 8, SPI_CLK_FREQ);
000028  4809              LDR      r0,|L1.80|
00002a  4c0a              LDR      r4,|L1.84|
00002c  9000              STR      r0,[sp,#0]
00002e  2308              MOVS     r3,#8
000030  2204              MOVS     r2,#4
000032  2100              MOVS     r1,#0
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       SPI_Open
;;;49     
;;;50         /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active */
;;;51         SPI_EnableAutoSS(SPI0, SPI_SS, SPI_SS_ACTIVE_LOW);
00003a  2200              MOVS     r2,#0
00003c  2101              MOVS     r1,#1
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       SPI_EnableAutoSS
;;;52     }
000044  bd38              POP      {r3-r5,pc}
;;;53     
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      0x6640000d
                  |L1.76|
                          DCD      0x00004444
                  |L1.80|
                          DCD      0x00b71b00
                  |L1.84|
                          DCD      0x40061000

                          AREA ||i.SPI_1BYT_SetRx||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetRx PROC
;;;60     // Read RF 1 byte register
;;;61     uint8_t SPI_1BYT_SetRx(uint8_t regAddr)
000000  b410              PUSH     {r4}
;;;62     {
;;;63         uint32_t u32i;
;;;64     
;;;65         while(1)
;;;66         {
;;;67             InterruptDisable();
;;;68             if(SPI_IS_BUSY(SPI0)==0)      //if(SPI is free)
000002  491b              LDR      r1,|L2.112|
                  |L2.4|
000004  b672              CPSID    i                     ;67
000006  694a              LDR      r2,[r1,#0x14]
000008  07d2              LSLS     r2,r2,#31
00000a  d001              BEQ      |L2.16|
;;;69             {
;;;70                 SPI0_ClearRxFIFO();
;;;71                 SPI_WRITE_TX(SPI0, (regAddr|0x80));            //write 1st byte: (regAddr & 0x7F) | 0x80
;;;72                 SPI_DISABLE_RX_PDMA(SPI0);
;;;73                 if((regAddr&0x80))
;;;74                 {
;;;75                     SPI_WRITE_TX(SPI0, 0x01);                  //write 2nd byte: (regAddr & 0x80)>>7
;;;76                 }
;;;77                 else
;;;78                 {
;;;79                     SPI_WRITE_TX(SPI0, 0x00);
;;;80                 }
;;;81                 if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
;;;82                 {
;;;83                     u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
;;;84                     if(u32i)                                   //Check the PDMA transfer done flags
;;;85                     {
;;;86                         PDMA_CLR_TD_FLAG(PDMA, u32i);          //Clear the PDMA transfer done flags
;;;87                     }
;;;88                 }
;;;89                 break;
;;;90             }
;;;91             else
;;;92             {
;;;93                 // printf("assert!");
;;;94             }
;;;95             InterruptEnable();
00000c  b662              CPSIE    i
00000e  e7f9              B        |L2.4|
                  |L2.16|
000010  690b              LDR      r3,[r1,#0x10]         ;70
000012  22ff              MOVS     r2,#0xff              ;70
000014  3201              ADDS     r2,#1                 ;70
000016  4313              ORRS     r3,r3,r2              ;70
000018  610b              STR      r3,[r1,#0x10]         ;70
00001a  2380              MOVS     r3,#0x80              ;71
00001c  4303              ORRS     r3,r3,r0              ;71
00001e  620b              STR      r3,[r1,#0x20]         ;71
000020  68cb              LDR      r3,[r1,#0xc]          ;72
000022  2402              MOVS     r4,#2                 ;72
000024  43a3              BICS     r3,r3,r4              ;72
000026  60cb              STR      r3,[r1,#0xc]          ;72
000028  0600              LSLS     r0,r0,#24             ;73
00002a  d501              BPL      |L2.48|
00002c  2001              MOVS     r0,#1                 ;75
00002e  e000              B        |L2.50|
                  |L2.48|
000030  2000              MOVS     r0,#0                 ;79
                  |L2.50|
000032  6208              STR      r0,[r1,#0x20]         ;79
000034  4b0f              LDR      r3,|L2.116|
000036  69d8              LDR      r0,[r3,#0x1c]         ;81
000038  4c0f              LDR      r4,|L2.120|
00003a  4220              TST      r0,r4                 ;81
00003c  d004              BEQ      |L2.72|
00003e  6a58              LDR      r0,[r3,#0x24]         ;83
000040  2418              MOVS     r4,#0x18              ;83
000042  4020              ANDS     r0,r0,r4              ;83
000044  d000              BEQ      |L2.72|
000046  6258              STR      r0,[r3,#0x24]         ;86
                  |L2.72|
;;;96         }
;;;97     
;;;98         SPI_WRITE_TX(SPI0, 0xFF);        //1 more dummy byte
000048  20ff              MOVS     r0,#0xff
00004a  6208              STR      r0,[r1,#0x20]
;;;99         SPI_WRITE_TX(SPI0, 0xF5);        //write 1 dummy byte to read 1 byte data
00004c  20f5              MOVS     r0,#0xf5
00004e  6208              STR      r0,[r1,#0x20]
                  |L2.80|
;;;100    
;;;101        while(SPI_GET_RX_FIFO_COUNT(SPI0)!=4);
000050  6948              LDR      r0,[r1,#0x14]
;;;102        SPI_READ_RX(SPI0);
;;;103        SPI_READ_RX(SPI0);
;;;104        SPI_READ_RX(SPI0);
;;;105        u32i = SPI_READ_RX(SPI0);
;;;106    
;;;107        SPI0_ClearRxFIFO();
;;;108        InterruptEnable();
;;;109        return (uint8_t)u32i;
;;;110    }
000052  0100              LSLS     r0,r0,#4
000054  0f00              LSRS     r0,r0,#28
000056  2804              CMP      r0,#4                 ;101
000058  d1fa              BNE      |L2.80|
00005a  6b08              LDR      r0,[r1,#0x30]         ;102
00005c  6b08              LDR      r0,[r1,#0x30]         ;103
00005e  6b08              LDR      r0,[r1,#0x30]         ;104
000060  6b08              LDR      r0,[r1,#0x30]         ;105
000062  690b              LDR      r3,[r1,#0x10]         ;107
000064  4313              ORRS     r3,r3,r2              ;107
000066  610b              STR      r3,[r1,#0x10]         ;107
000068  b662              CPSIE    i                     ;108
00006a  b2c0              UXTB     r0,r0                 ;109
00006c  bc10              POP      {r4}
00006e  4770              BX       lr
;;;111    
                          ENDP

                  |L2.112|
                          DCD      0x40061000
                  |L2.116|
                          DCD      0x40008400
                  |L2.120|
                          DCD      0x00000303

                          AREA ||i.SPI_1BYT_SetRx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetRx_Isr PROC
;;;112    // Read RF 1 byte register or RX_FIFO in ISR
;;;113    uint8_t SPI_1BYT_SetRx_Isr(uint8_t regAddr)
000000  b430              PUSH     {r4,r5}
;;;114    {
;;;115        uint32_t u32i;
;;;116    
;;;117        while(1)
;;;118        {
;;;119            if(SPI_IS_BUSY(SPI0)==0)
000002  491f              LDR      r1,|L3.128|
                  |L3.4|
000004  694a              LDR      r2,[r1,#0x14]
000006  07d2              LSLS     r2,r2,#31
000008  d1fc              BNE      |L3.4|
;;;120            {
;;;121                SPI0_ClearRxFIFO();
00000a  690b              LDR      r3,[r1,#0x10]
00000c  22ff              MOVS     r2,#0xff
00000e  3201              ADDS     r2,#1
000010  4313              ORRS     r3,r3,r2
000012  610b              STR      r3,[r1,#0x10]
;;;122                SPI_WRITE_TX(SPI0, (regAddr|0x80));        //write 1st byte: (regAddr & 0x7F) | 0x80
000014  2380              MOVS     r3,#0x80
000016  4303              ORRS     r3,r3,r0
000018  620b              STR      r3,[r1,#0x20]
;;;123                SPI_DISABLE_RX_PDMA(SPI0);
00001a  68cb              LDR      r3,[r1,#0xc]
00001c  2402              MOVS     r4,#2
00001e  43a3              BICS     r3,r3,r4
000020  60cb              STR      r3,[r1,#0xc]
;;;124                if((regAddr&0x80))
000022  0603              LSLS     r3,r0,#24
000024  d501              BPL      |L3.42|
;;;125                {
;;;126                    SPI_WRITE_TX(SPI0, 0x01);              //write 2nd byte: (regAddr & 0x80)>>7
000026  2301              MOVS     r3,#1
000028  e000              B        |L3.44|
                  |L3.42|
;;;127                }
;;;128                else
;;;129                {
;;;130                    SPI_WRITE_TX(SPI0, 0x00);
00002a  2300              MOVS     r3,#0
                  |L3.44|
00002c  620b              STR      r3,[r1,#0x20]
;;;131                }
;;;132                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00002e  4c15              LDR      r4,|L3.132|
000030  69e3              LDR      r3,[r4,#0x1c]
000032  4d15              LDR      r5,|L3.136|
000034  422b              TST      r3,r5
000036  d004              BEQ      |L3.66|
;;;133                {
;;;134                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000038  6a63              LDR      r3,[r4,#0x24]
00003a  2518              MOVS     r5,#0x18
00003c  402b              ANDS     r3,r3,r5
;;;135                    if(u32i)                                //Check the PDMA transfer done flags
00003e  d000              BEQ      |L3.66|
;;;136                    {
;;;137                        PDMA_CLR_TD_FLAG(PDMA, u32i);       //Clear the PDMA transfer done flags
000040  6263              STR      r3,[r4,#0x24]
                  |L3.66|
000042  23ff              MOVS     r3,#0xff              ;114
;;;138                    }
;;;139                }
;;;140                break;
;;;141            }
;;;142            else
;;;143            {
;;;144                //printf("assert!");
;;;145            }
;;;146        }
;;;147    
;;;148        if(regAddr==RX_BUFFER_READ_PORT)   //read RX_FIFO
;;;149        {
;;;150            SPI_WRITE_TX(SPI0, 0xFF);                 //1 more dummy byte for MP read RX_FIFO
;;;151            SPI_WRITE_TX(SPI0, 0xFF);                 //1 more dummy byte for MP read RX_FIFO
;;;152    
;;;153            SPI_WRITE_TX(SPI0, 0xF5);                 //write 1 dummy byte to read 1 byte data
000044  24f5              MOVS     r4,#0xf5
000046  28ff              CMP      r0,#0xff              ;148
;;;154    
;;;155            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=5);
;;;156            SPI_READ_RX(SPI0);
;;;157            SPI_READ_RX(SPI0);
;;;158            SPI_READ_RX(SPI0);
;;;159            SPI_READ_RX(SPI0);
;;;160        }
;;;161        else            //read register
;;;162        {
;;;163            SPI_WRITE_TX(SPI0, 0xFF);                 //1 more dummy byte for MP read register
000048  620b              STR      r3,[r1,#0x20]
00004a  d00f              BEQ      |L3.108|
;;;164    
;;;165            SPI_WRITE_TX(SPI0, 0xF5);                 //write 1 dummy byte to read 1 byte data
00004c  620c              STR      r4,[r1,#0x20]
                  |L3.78|
;;;166    
;;;167            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=4);
00004e  6948              LDR      r0,[r1,#0x14]
;;;168            SPI_READ_RX(SPI0);
;;;169            SPI_READ_RX(SPI0);
;;;170            SPI_READ_RX(SPI0);
;;;171        }
;;;172    
;;;173        u32i = SPI_READ_RX(SPI0);
;;;174        SPI0_ClearRxFIFO();
;;;175    
;;;176        return (uint8_t)u32i;
;;;177    }
000050  0100              LSLS     r0,r0,#4
000052  0f00              LSRS     r0,r0,#28
000054  2804              CMP      r0,#4                 ;167
000056  d1fa              BNE      |L3.78|
                  |L3.88|
000058  6b08              LDR      r0,[r1,#0x30]         ;168
00005a  6b08              LDR      r0,[r1,#0x30]         ;169
00005c  6b08              LDR      r0,[r1,#0x30]         ;170
00005e  6b08              LDR      r0,[r1,#0x30]         ;173
000060  690b              LDR      r3,[r1,#0x10]         ;174
000062  4313              ORRS     r3,r3,r2              ;174
000064  610b              STR      r3,[r1,#0x10]         ;174
000066  bc30              POP      {r4,r5}
000068  b2c0              UXTB     r0,r0                 ;176
00006a  4770              BX       lr
                  |L3.108|
00006c  620b              STR      r3,[r1,#0x20]         ;151
00006e  620c              STR      r4,[r1,#0x20]         ;153
                  |L3.112|
000070  6948              LDR      r0,[r1,#0x14]         ;155
000072  0100              LSLS     r0,r0,#4
000074  0f00              LSRS     r0,r0,#28
000076  2805              CMP      r0,#5                 ;155
000078  d1fa              BNE      |L3.112|
00007a  6b08              LDR      r0,[r1,#0x30]         ;156
00007c  e7ec              B        |L3.88|
;;;178    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
                          DCD      0x40061000
                  |L3.132|
                          DCD      0x40008400
                  |L3.136|
                          DCD      0x00000303

                          AREA ||i.SPI_1BYT_SetTx||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetTx PROC
;;;179    // Write RF 1 byte register (not use for writing TX buffer)
;;;180    void SPI_1BYT_SetTx(uint8_t regAddr, uint8_t u8SrcData)
000000  b430              PUSH     {r4,r5}
;;;181    {
;;;182        uint32_t u32i;
;;;183    
;;;184        while(1)
;;;185        {
;;;186            InterruptDisable();
;;;187            if(SPI_IS_BUSY(SPI0)==0)
000002  4a0f              LDR      r2,|L4.64|
                  |L4.4|
000004  b672              CPSID    i                     ;186
000006  6953              LDR      r3,[r2,#0x14]
000008  07db              LSLS     r3,r3,#31
00000a  d001              BEQ      |L4.16|
;;;188            {
;;;189                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
;;;190                {
;;;191                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
;;;192                    if(u32i)                             //Check the PDMA transfer done flags
;;;193                    {
;;;194                        PDMA_CLR_TD_FLAG(PDMA, u32i);    //Clear the PDMA transfer done flags
;;;195                    }
;;;196                }
;;;197                break;
;;;198            }
;;;199            else
;;;200            {
;;;201                //printf("assert!");
;;;202            }
;;;203            InterruptEnable();
00000c  b662              CPSIE    i
00000e  e7f9              B        |L4.4|
                  |L4.16|
000010  4c0c              LDR      r4,|L4.68|
000012  69e3              LDR      r3,[r4,#0x1c]         ;189
000014  4d0c              LDR      r5,|L4.72|
000016  422b              TST      r3,r5                 ;189
000018  d004              BEQ      |L4.36|
00001a  6a63              LDR      r3,[r4,#0x24]         ;191
00001c  2518              MOVS     r5,#0x18              ;191
00001e  402b              ANDS     r3,r3,r5              ;191
000020  d000              BEQ      |L4.36|
000022  6263              STR      r3,[r4,#0x24]         ;194
                  |L4.36|
;;;204        }
;;;205        SPI_WRITE_TX(SPI0, (regAddr&0x7F));  //write 1st byte: regAddr & 0x7F
000024  0643              LSLS     r3,r0,#25
000026  0e5b              LSRS     r3,r3,#25
000028  6213              STR      r3,[r2,#0x20]
;;;206    
;;;207        if((regAddr&0x80))
00002a  0600              LSLS     r0,r0,#24
00002c  d501              BPL      |L4.50|
;;;208        {
;;;209            SPI_WRITE_TX(SPI0, 0x01);        //write 2nd byte: (regAddr & 0x80) >> 7
00002e  2001              MOVS     r0,#1
000030  e000              B        |L4.52|
                  |L4.50|
;;;210        }
;;;211        else
;;;212        {
;;;213            SPI_WRITE_TX(SPI0, 0x00);
000032  2000              MOVS     r0,#0
                  |L4.52|
000034  6210              STR      r0,[r2,#0x20]
;;;214        }
;;;215    
;;;216        SPI_WRITE_TX(SPI0, u8SrcData);
000036  6211              STR      r1,[r2,#0x20]
;;;217    
;;;218        InterruptEnable();
000038  b662              CPSIE    i
;;;219    }
00003a  bc30              POP      {r4,r5}
00003c  4770              BX       lr
;;;220    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      0x40061000
                  |L4.68|
                          DCD      0x40008400
                  |L4.72|
                          DCD      0x00000303

                          AREA ||i.SPI_1BYT_SetTx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_1BYT_SetTx_Isr PROC
;;;222    // Write RF 1 byte register in ISR (not use for writing TX buffer)
;;;223    void SPI_1BYT_SetTx_Isr(uint8_t regAddr, uint8_t u8SrcData)
000000  b430              PUSH     {r4,r5}
;;;224    {
;;;225        uint32_t u32i;
;;;226        while(1)
;;;227        {
;;;228            if(SPI_IS_BUSY(SPI0)==0)
000002  4a0d              LDR      r2,|L5.56|
                  |L5.4|
000004  6953              LDR      r3,[r2,#0x14]
000006  07db              LSLS     r3,r3,#31
000008  d1fc              BNE      |L5.4|
;;;229            {
;;;230                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000a  4c0c              LDR      r4,|L5.60|
00000c  69e3              LDR      r3,[r4,#0x1c]
00000e  4d0c              LDR      r5,|L5.64|
000010  422b              TST      r3,r5
000012  d004              BEQ      |L5.30|
;;;231                {
;;;232                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000014  6a63              LDR      r3,[r4,#0x24]
000016  2518              MOVS     r5,#0x18
000018  402b              ANDS     r3,r3,r5
;;;233                    if(u32i)                             //Check the PDMA transfer done flags
00001a  d000              BEQ      |L5.30|
;;;234                    {
;;;235                        PDMA_CLR_TD_FLAG(PDMA, u32i);    //Clear the PDMA transfer done flags
00001c  6263              STR      r3,[r4,#0x24]
                  |L5.30|
;;;236                    }
;;;237                }
;;;238                break;
;;;239            }
;;;240            else
;;;241            {
;;;242                // printf("assert!");
;;;243            }
;;;244        }
;;;245        SPI_WRITE_TX(SPI0, (regAddr&0x7F));     //write 1st byte: regAddr & 0x7F
00001e  0643              LSLS     r3,r0,#25
000020  0e5b              LSRS     r3,r3,#25
000022  6213              STR      r3,[r2,#0x20]
;;;246        if((regAddr&0x80))
000024  0600              LSLS     r0,r0,#24
000026  d501              BPL      |L5.44|
;;;247        {
;;;248            SPI_WRITE_TX(SPI0, 0x01);           //write 2nd byte: (regAddr & 0x80) >> 7
000028  2001              MOVS     r0,#1
00002a  e000              B        |L5.46|
                  |L5.44|
;;;249        }
;;;250        else
;;;251        {
;;;252            SPI_WRITE_TX(SPI0, 0x00);
00002c  2000              MOVS     r0,#0
                  |L5.46|
00002e  6210              STR      r0,[r2,#0x20]
;;;253        }
;;;254    
;;;255        SPI_WRITE_TX(SPI0, u8SrcData);
000030  6211              STR      r1,[r2,#0x20]
;;;256    
;;;257    }
000032  bc30              POP      {r4,r5}
000034  4770              BX       lr
;;;258    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40061000
                  |L5.60|
                          DCD      0x40008400
                  |L5.64|
                          DCD      0x00000303

                          AREA ||i.SPI_2BYT_SetTx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_2BYT_SetTx_Isr PROC
;;;259    // Write RF 2 byte registers in ISR
;;;260    void SPI_2BYT_SetTx_Isr(uint8_t regAddr, uint8_t *u8SrcAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
;;;262        uint32_t u32i;
;;;263    
;;;264        while(1)
;;;265        {
;;;266            if(SPI_IS_BUSY(SPI0)==0)
000002  4c13              LDR      r4,|L6.80|
000004  460d              MOV      r5,r1                 ;261
                  |L6.6|
000006  6962              LDR      r2,[r4,#0x14]
000008  07d2              LSLS     r2,r2,#31
00000a  d1fc              BNE      |L6.6|
;;;267            {
;;;268                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4a11              LDR      r2,|L6.84|
00000e  69d1              LDR      r1,[r2,#0x1c]
000010  4b11              LDR      r3,|L6.88|
000012  4219              TST      r1,r3
000014  d004              BEQ      |L6.32|
;;;269                {
;;;270                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a51              LDR      r1,[r2,#0x24]
000018  2318              MOVS     r3,#0x18
00001a  4019              ANDS     r1,r1,r3
;;;271                    if(u32i)                             //Check the PDMA transfer done flags
00001c  d000              BEQ      |L6.32|
;;;272                    {
;;;273                        PDMA_CLR_TD_FLAG(PDMA, u32i);    //Clear the PDMA transfer done flags
00001e  6251              STR      r1,[r2,#0x24]
                  |L6.32|
;;;274                    }
;;;275                }
;;;276                break;
;;;277            }
;;;278            else
;;;279            {
;;;280                //printf("assert!");
;;;281            }
;;;282        }
;;;283        SPI_WRITE_TX(SPI0, (regAddr&0x7F));    //write 1st byte: regAddr & 0x7F
000020  0641              LSLS     r1,r0,#25
000022  0e49              LSRS     r1,r1,#25
000024  6221              STR      r1,[r4,#0x20]
;;;284    
;;;285        if((regAddr&0x80))
000026  0601              LSLS     r1,r0,#24
000028  d501              BPL      |L6.46|
;;;286        {
;;;287            SPI_WRITE_TX(SPI0, 0x01);          //write 2nd byte: (regAddr & 0x80) >> 7
00002a  2101              MOVS     r1,#1
00002c  e000              B        |L6.48|
                  |L6.46|
;;;288        }
;;;289        else
;;;290        {
;;;291            SPI_WRITE_TX(SPI0, 0x00);
00002e  2100              MOVS     r1,#0
                  |L6.48|
000030  6221              STR      r1,[r4,#0x20]
;;;292        }
;;;293    
;;;294        if(regAddr==TX_BUFFER_WRITE_PORT)                   //if (writing to TX_buffer)
000032  28fe              CMP      r0,#0xfe
000034  d106              BNE      |L6.68|
;;;295        {
;;;296            uint32_t ram_start_addr;
;;;297    
;;;298            ram_start_addr = BleTxFIFOAddr_Get();
000036  f7fffffe          BL       BleTxFIFOAddr_Get
;;;299            SPI_WRITE_TX(SPI0, (ram_start_addr & 0xFF));       //write 3rd byte: ram_start_addr & 0xFF
00003a  b2c1              UXTB     r1,r0
00003c  6221              STR      r1,[r4,#0x20]
;;;300            SPI_WRITE_TX(SPI0, (ram_start_addr & 0x0100)>>8);  //write 4th byte: (ram_start_addr & 0x0100)>>8 | (b7<<7),  b7=1/0 means fill payload/header
00003e  05c0              LSLS     r0,r0,#23
000040  0fc0              LSRS     r0,r0,#31
000042  6220              STR      r0,[r4,#0x20]
                  |L6.68|
;;;301        }
;;;302        SPI_WRITE_TX(SPI0, *(u8SrcAddr));
000044  7828              LDRB     r0,[r5,#0]
000046  6220              STR      r0,[r4,#0x20]
;;;303        SPI_WRITE_TX(SPI0, *(u8SrcAddr+1));
000048  7868              LDRB     r0,[r5,#1]
00004a  6220              STR      r0,[r4,#0x20]
;;;304    }
00004c  bd70              POP      {r4-r6,pc}
;;;305    
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
                          DCD      0x40061000
                  |L6.84|
                          DCD      0x40008400
                  |L6.88|
                          DCD      0x00000303

                          AREA ||i.SPI_PDMA_Init||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_Init PROC
;;;307    //SPI PDMA init
;;;308    void SPI_PDMA_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;309    {
000002  b083              SUB      sp,sp,#0xc
;;;310    
;;;311        //Reset PDMA module
;;;312        SYS_ResetModule(PDMA_RST);
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       SYS_ResetModule
;;;313    
;;;314        //Enable PDMA channels
;;;315        PDMA_Open(PDMA, SPI_OPENED_CH);
00000a  4d1f              LDR      r5,|L7.136|
00000c  2118              MOVS     r1,#0x18
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       PDMA_Open
;;;316    
;;;317        //Single request type. SPI only support PDMA single request type.
;;;318        PDMA_SetBurstType(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000014  2300              MOVS     r3,#0
000016  2204              MOVS     r2,#4
000018  2103              MOVS     r1,#3
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       PDMA_SetBurstType
;;;319        PDMA_SetBurstType(PDMA, SPI_MASTER_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
000020  2204              MOVS     r2,#4
000022  2300              MOVS     r3,#0
000024  4611              MOV      r1,r2
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       PDMA_SetBurstType
;;;320    
;;;321        //Set source/destination attributes
;;;322        PDMA_SetTransferAddr(PDMA, SPI_MASTER_TX_DMA_CH, NULL, PDMA_SAR_INC, (uint32_t)&SPI0->TX, PDMA_DAR_FIX);
00002c  2103              MOVS     r1,#3
00002e  0289              LSLS     r1,r1,#10
000030  4816              LDR      r0,|L7.140|
000032  2300              MOVS     r3,#0
000034  9101              STR      r1,[sp,#4]
000036  9000              STR      r0,[sp,#0]
000038  461a              MOV      r2,r3
00003a  2103              MOVS     r1,#3
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       PDMA_SetTransferAddr
;;;323        PDMA_SetTransferAddr(PDMA, SPI_MASTER_RX_DMA_CH, (uint32_t)&SPI0->RX, PDMA_SAR_FIX, NULL, PDMA_DAR_INC);
000042  2400              MOVS     r4,#0
000044  2303              MOVS     r3,#3
000046  9400              STR      r4,[sp,#0]
000048  021b              LSLS     r3,r3,#8
00004a  4a11              LDR      r2,|L7.144|
00004c  2104              MOVS     r1,#4
00004e  4628              MOV      r0,r5
000050  9401              STR      r4,[sp,#4]
000052  f7fffffe          BL       PDMA_SetTransferAddr
;;;324    
;;;325        //Set request source; set basic mode.
;;;326        PDMA_SetTransferMode(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_SPI0_TX, FALSE, 0);
000056  2300              MOVS     r3,#0
000058  2212              MOVS     r2,#0x12
00005a  2103              MOVS     r1,#3
00005c  4628              MOV      r0,r5
00005e  9400              STR      r4,[sp,#0]
000060  f7fffffe          BL       PDMA_SetTransferMode
;;;327        PDMA_SetTransferMode(PDMA, SPI_MASTER_RX_DMA_CH, PDMA_SPI0_RX, FALSE, 0);
000064  2300              MOVS     r3,#0
000066  2213              MOVS     r2,#0x13
000068  2104              MOVS     r1,#4
00006a  4628              MOV      r0,r5
00006c  9400              STR      r4,[sp,#0]
00006e  f7fffffe          BL       PDMA_SetTransferMode
;;;328    
;;;329        //Disable table interrupt
;;;330        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000072  6b28              LDR      r0,[r5,#0x30]
000074  2180              MOVS     r1,#0x80
000076  4308              ORRS     r0,r0,r1
000078  6328              STR      r0,[r5,#0x30]
;;;331        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
00007a  4806              LDR      r0,|L7.148|
00007c  6802              LDR      r2,[r0,#0]
00007e  430a              ORRS     r2,r2,r1
000080  6002              STR      r2,[r0,#0]
;;;332    
;;;333    }
000082  b003              ADD      sp,sp,#0xc
000084  bd30              POP      {r4,r5,pc}
;;;334    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x40008000
                  |L7.140|
                          DCD      0x40061020
                  |L7.144|
                          DCD      0x40061030
                  |L7.148|
                          DCD      0x40008040

                          AREA ||i.SPI_PDMA_SetRx_Isr||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_SetRx_Isr PROC
;;;376    //SPI PDMA read RF in ISR
;;;377    void SPI_PDMA_SetRx_Isr(uint8_t regAddr, uint32_t u32DstAddr, uint32_t u32TransCount)
000000  b4f0              PUSH     {r4-r7}
;;;378    {
;;;379        uint32_t u32i;
;;;380        extern const Uint8 TAB_ZERO_128[];
;;;381    
;;;382        while(1)
;;;383        {
;;;384            if(SPI_IS_BUSY(SPI0)==0)
000002  4c2c              LDR      r4,|L8.180|
000004  468c              MOV      r12,r1                ;378
                  |L8.6|
000006  6961              LDR      r1,[r4,#0x14]
000008  07c9              LSLS     r1,r1,#31
00000a  d1fc              BNE      |L8.6|
;;;385            {
;;;386                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4b2a              LDR      r3,|L8.184|
00000e  69d9              LDR      r1,[r3,#0x1c]
000010  4d2a              LDR      r5,|L8.188|
000012  4229              TST      r1,r5
000014  d004              BEQ      |L8.32|
;;;387                {
;;;388                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a59              LDR      r1,[r3,#0x24]
000018  2518              MOVS     r5,#0x18
00001a  4029              ANDS     r1,r1,r5
;;;389                    if(u32i)                           //Check the PDMA transfer done flags
00001c  d000              BEQ      |L8.32|
;;;390                    {
;;;391                        PDMA_CLR_TD_FLAG(PDMA, u32i);  //Clear the PDMA transfer done flags
00001e  6259              STR      r1,[r3,#0x24]
                  |L8.32|
;;;392                    }
;;;393                }
;;;394                break;
;;;395            }
;;;396        }
;;;397        SPI0_ClearRxFIFO();
000020  6921              LDR      r1,[r4,#0x10]
000022  23ff              MOVS     r3,#0xff
000024  3301              ADDS     r3,#1
000026  4319              ORRS     r1,r1,r3
000028  6121              STR      r1,[r4,#0x10]
;;;398        SPI_WRITE_TX(SPI0, ((regAddr & 0x7F)|0x80));  //1st byte (regAddr & 0x7F) | 0x80
00002a  2180              MOVS     r1,#0x80
00002c  4301              ORRS     r1,r1,r0
00002e  6221              STR      r1,[r4,#0x20]
;;;399        if((regAddr&0x80))
000030  0601              LSLS     r1,r0,#24
;;;400        {
;;;401            SPI_WRITE_TX(SPI0, 0x01);                 //2nd byte (regAddr & 0x80)>>7
000032  2601              MOVS     r6,#1
000034  2900              CMP      r1,#0                 ;399
000036  da01              BGE      |L8.60|
000038  6226              STR      r6,[r4,#0x20]
00003a  e001              B        |L8.64|
                  |L8.60|
;;;402        }
;;;403        else
;;;404        {
;;;405            SPI_WRITE_TX(SPI0, 0x00);
00003c  2100              MOVS     r1,#0
00003e  6221              STR      r1,[r4,#0x20]
                  |L8.64|
000040  21ff              MOVS     r1,#0xff              ;378
;;;406        }
;;;407    
;;;408        if(regAddr==RX_BUFFER_READ_PORT)   //read RX_FIFO
000042  28ff              CMP      r0,#0xff
;;;409        {
;;;410            SPI_WRITE_TX(SPI0, 0xFF);                   //1 more dummy byte for MP read RX_FIFO
;;;411            SPI_WRITE_TX(SPI0, 0xFF);                   //1 more dummy byte for MP read RX_FIFO
;;;412        }
;;;413        else            //read register
;;;414        {
;;;415            SPI_WRITE_TX(SPI0, 0xFF);                   //1 more dummy byte for MP read register
000044  6221              STR      r1,[r4,#0x20]
000046  d100              BNE      |L8.74|
000048  6221              STR      r1,[r4,#0x20]         ;411
                  |L8.74|
;;;416        }
;;;417    
;;;418        SPI_DISABLE_RX_PDMA(SPI0);
00004a  68e3              LDR      r3,[r4,#0xc]
00004c  2102              MOVS     r1,#2
00004e  438b              BICS     r3,r3,r1
000050  60e3              STR      r3,[r4,#0xc]
;;;419        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].SA = (uint32_t)TAB_ZERO_128; //In SPI read, Master write dummy data to generate SPI clock
000052  4b1c              LDR      r3,|L8.196|
000054  491a              LDR      r1,|L8.192|
000056  6359              STR      r1,[r3,#0x34]
;;;420    
;;;421        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL &= ~(PDMA_DSCT_CTL_TXCNT_Msk | PDMA_DSCT_CTL_TXWIDTH_Msk | PDMA_DSCT_CTL_OPMODE_Msk);
000058  6b1d              LDR      r5,[r3,#0x30]
00005a  491b              LDR      r1,|L8.200|
00005c  400d              ANDS     r5,r5,r1
00005e  631d              STR      r5,[r3,#0x30]
;;;422        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= ((PDMA_WIDTH_8|PDMA_OP_BASIC) | ((u32TransCount - 1UL) << PDMA_DSCT_CTL_TXCNT_Pos));
000060  6b1d              LDR      r5,[r3,#0x30]
000062  0417              LSLS     r7,r2,#16
000064  4a19              LDR      r2,|L8.204|
000066  18ba              ADDS     r2,r7,r2
000068  4315              ORRS     r5,r5,r2
00006a  631d              STR      r5,[r3,#0x30]
;;;423        SPI_TRIGGER_TX_PDMA(SPI0);
00006c  68e3              LDR      r3,[r4,#0xc]
00006e  4333              ORRS     r3,r3,r6
000070  60e3              STR      r3,[r4,#0xc]
;;;424        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].DA = u32DstAddr;
000072  4b17              LDR      r3,|L8.208|
000074  4665              MOV      r5,r12
000076  609d              STR      r5,[r3,#8]
;;;425        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL &= ~(PDMA_DSCT_CTL_TXCNT_Msk | PDMA_DSCT_CTL_TXWIDTH_Msk | PDMA_DSCT_CTL_OPMODE_Msk);
000078  681d              LDR      r5,[r3,#0]
00007a  400d              ANDS     r5,r5,r1
00007c  601d              STR      r5,[r3,#0]
;;;426        PDMA->DSCT[SPI_MASTER_RX_DMA_CH].CTL |= ((PDMA_WIDTH_8|PDMA_OP_BASIC) | ((u32TransCount - 1UL) << PDMA_DSCT_CTL_TXCNT_Pos));
00007e  6819              LDR      r1,[r3,#0]
000080  4311              ORRS     r1,r1,r2
000082  6019              STR      r1,[r3,#0]
;;;427    
;;;428        if(regAddr==RX_BUFFER_READ_PORT)   //read RX_FIFO
000084  28ff              CMP      r0,#0xff
000086  d00d              BEQ      |L8.164|
                  |L8.136|
;;;429        {
;;;430            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=4);
;;;431            SPI_READ_RX(SPI0);
;;;432            SPI_READ_RX(SPI0);
;;;433            SPI_READ_RX(SPI0);
;;;434            SPI_READ_RX(SPI0);
;;;435        }
;;;436        else   //read register
;;;437        {
;;;438            while(SPI_GET_RX_FIFO_COUNT(SPI0)!=3);
000088  6960              LDR      r0,[r4,#0x14]
;;;439            SPI_READ_RX(SPI0);
;;;440            SPI_READ_RX(SPI0);
;;;441            SPI_READ_RX(SPI0);
;;;442        }
;;;443    
;;;444        SPI_TRIGGER_RX_PDMA(SPI0);
;;;445    }
00008a  0100              LSLS     r0,r0,#4
00008c  0f00              LSRS     r0,r0,#28
00008e  2803              CMP      r0,#3                 ;438
000090  d1fa              BNE      |L8.136|
                  |L8.146|
000092  6b20              LDR      r0,[r4,#0x30]         ;439
000094  6b20              LDR      r0,[r4,#0x30]         ;440
000096  6b20              LDR      r0,[r4,#0x30]         ;441
000098  68e0              LDR      r0,[r4,#0xc]          ;444
00009a  2102              MOVS     r1,#2                 ;444
00009c  4308              ORRS     r0,r0,r1              ;444
00009e  60e0              STR      r0,[r4,#0xc]          ;444
0000a0  bcf0              POP      {r4-r7}
0000a2  4770              BX       lr
                  |L8.164|
0000a4  6960              LDR      r0,[r4,#0x14]         ;430
0000a6  0100              LSLS     r0,r0,#4
0000a8  0f00              LSRS     r0,r0,#28
0000aa  2804              CMP      r0,#4                 ;430
0000ac  d1fa              BNE      |L8.164|
0000ae  6b20              LDR      r0,[r4,#0x30]         ;431
0000b0  e7ef              B        |L8.146|
;;;446    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L8.180|
                          DCD      0x40061000
                  |L8.184|
                          DCD      0x40008400
                  |L8.188|
                          DCD      0x00000303
                  |L8.192|
                          DCD      TAB_ZERO_128
                  |L8.196|
                          DCD      0x40008000
                  |L8.200|
                          DCD      0x0000cffc
                  |L8.204|
                          DCD      0xffff0001
                  |L8.208|
                          DCD      0x40008040

                          AREA ||i.SPI_PDMA_SetTx||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_SetTx PROC
;;;449    //SPI PDMA write RF
;;;450    void SPI_PDMA_SetTx(uint8_t regAddr, uint32_t u32SrcAddr, uint32_t u32TransCount)
000000  b5f8              PUSH     {r3-r7,lr}
;;;451    {
;;;452        uint32_t u32i;
;;;453    
;;;454        while(1)
;;;455        {
;;;456            if(SPI_IS_BUSY(SPI0)==0)
000002  4c1a              LDR      r4,|L9.108|
000004  4615              MOV      r5,r2                 ;451
                  |L9.6|
000006  6963              LDR      r3,[r4,#0x14]
000008  07da              LSLS     r2,r3,#31
00000a  d1fc              BNE      |L9.6|
;;;457            {
;;;458                if(((PDMA_GET_INT_STATUS(PDMA))&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4b18              LDR      r3,|L9.112|
00000e  69da              LDR      r2,[r3,#0x1c]
000010  4e18              LDR      r6,|L9.116|
000012  4232              TST      r2,r6
000014  d004              BEQ      |L9.32|
;;;459                {
;;;460                    u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a5a              LDR      r2,[r3,#0x24]
000018  2618              MOVS     r6,#0x18
00001a  4032              ANDS     r2,r2,r6
;;;461                    if(u32i)                               //Check the PDMA transfer done flags
00001c  d000              BEQ      |L9.32|
;;;462                    {
;;;463                        PDMA_CLR_TD_FLAG(PDMA, u32i);      //Clear the PDMA transfer done flags
00001e  625a              STR      r2,[r3,#0x24]
                  |L9.32|
;;;464                    }
;;;465                }
;;;466                break;
;;;467            }
;;;468        }
;;;469        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].SA = u32SrcAddr;
000020  4e15              LDR      r6,|L9.120|
000022  6371              STR      r1,[r6,#0x34]
;;;470        SPI_WRITE_TX(SPI0, (regAddr&0x7F));       //write 1st byte: regAddr & 0x7F
000024  0641              LSLS     r1,r0,#25
000026  0e49              LSRS     r1,r1,#25
000028  6221              STR      r1,[r4,#0x20]
;;;471    
;;;472        if((regAddr&0x80))
00002a  0601              LSLS     r1,r0,#24
;;;473        {
;;;474            SPI_WRITE_TX(SPI0, 0x01);             //write 2nd byte: (regAddr & 0x80) >> 7
00002c  2701              MOVS     r7,#1
00002e  2900              CMP      r1,#0                 ;472
000030  da01              BGE      |L9.54|
000032  6227              STR      r7,[r4,#0x20]
000034  e001              B        |L9.58|
                  |L9.54|
;;;475        }
;;;476        else
;;;477        {
;;;478            SPI_WRITE_TX(SPI0, 0x00);
000036  2100              MOVS     r1,#0
000038  6221              STR      r1,[r4,#0x20]
                  |L9.58|
;;;479        }
;;;480    
;;;481        if(regAddr==TX_BUFFER_WRITE_PORT)                             //if (writing to TX_buffer)
00003a  28fe              CMP      r0,#0xfe
00003c  d107              BNE      |L9.78|
;;;482        {
;;;483            uint32_t ram_start_addr;
;;;484    
;;;485            ram_start_addr = BleTxFIFOAddr_Get();
00003e  f7fffffe          BL       BleTxFIFOAddr_Get
;;;486            SPI_WRITE_TX(SPI0, (ram_start_addr & 0xFF));                 //write 3rd byte: ram_start_addr & 0xFF
000042  b2c1              UXTB     r1,r0
000044  6221              STR      r1,[r4,#0x20]
;;;487            SPI_WRITE_TX(SPI0, ((ram_start_addr & 0x0100)>>8) | 0x80);   //write 4th byte: (ram_start_addr & 0x0100)>>8 | (b7<<7),  b7=1/0 means fill payload/header
000046  05c0              LSLS     r0,r0,#23
000048  0fc0              LSRS     r0,r0,#31
00004a  3080              ADDS     r0,r0,#0x80
00004c  6220              STR      r0,[r4,#0x20]
                  |L9.78|
;;;488        }
;;;489    
;;;490        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL &= ~(PDMA_DSCT_CTL_TXCNT_Msk | PDMA_DSCT_CTL_TXWIDTH_Msk | PDMA_DSCT_CTL_OPMODE_Msk);
00004e  6b30              LDR      r0,[r6,#0x30]
000050  490a              LDR      r1,|L9.124|
000052  4008              ANDS     r0,r0,r1
000054  6330              STR      r0,[r6,#0x30]
;;;491        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= ((PDMA_WIDTH_8|PDMA_OP_BASIC) | ((u32TransCount - 1UL) << PDMA_DSCT_CTL_TXCNT_Pos));
000056  6b30              LDR      r0,[r6,#0x30]
000058  4a09              LDR      r2,|L9.128|
00005a  0429              LSLS     r1,r5,#16
00005c  1889              ADDS     r1,r1,r2
00005e  4308              ORRS     r0,r0,r1
000060  6330              STR      r0,[r6,#0x30]
;;;492    
;;;493        SPI_TRIGGER_TX_PDMA(SPI0);  //Enable SPI master DMA function
000062  68e0              LDR      r0,[r4,#0xc]
000064  4338              ORRS     r0,r0,r7
000066  60e0              STR      r0,[r4,#0xc]
;;;494    }
000068  bdf8              POP      {r3-r7,pc}
;;;495    
                          ENDP

00006a  0000              DCW      0x0000
                  |L9.108|
                          DCD      0x40061000
                  |L9.112|
                          DCD      0x40008400
                  |L9.116|
                          DCD      0x00000303
                  |L9.120|
                          DCD      0x40008000
                  |L9.124|
                          DCD      0x0000cffc
                  |L9.128|
                          DCD      0xffff0001

                          AREA ||i.SPI_PDMA_waitFinish||, CODE, READONLY, ALIGN=2

                  SPI_PDMA_waitFinish PROC
;;;337    //wait PDMA finish operation
;;;338    uint32_t SPI_PDMA_waitFinish(void)
000000  480e              LDR      r0,|L10.60|
                  |L10.2|
;;;339    {
;;;340        uint32_t u32i;
;;;341    
;;;342        while(SPI_IS_BUSY(SPI0));
000002  6941              LDR      r1,[r0,#0x14]
000004  07c9              LSLS     r1,r1,#31
000006  d1fc              BNE      |L10.2|
;;;343        u32i = PDMA_GET_INT_STATUS(PDMA);               //Get interrupt status
000008  490d              LDR      r1,|L10.64|
00000a  69c8              LDR      r0,[r1,#0x1c]
;;;344        if((u32i&(PDMA_INTSTS_TDIF_Msk|PDMA_INTSTS_ABTIF_Msk|PDMA_INTSTS_REQTOF0_Msk|PDMA_INTSTS_REQTOF1_Msk)))
00000c  4a0d              LDR      r2,|L10.68|
00000e  4210              TST      r0,r2
000010  d006              BEQ      |L10.32|
;;;345        {
;;;346            if(u32i & PDMA_INTSTS_TDIF_Msk)             //Check the PDMA transfer done interrupt flag
000012  0782              LSLS     r2,r0,#30
000014  d506              BPL      |L10.36|
;;;347            {
;;;348                u32i = (PDMA_GET_TD_STS(PDMA) & SPI_OPENED_CH);
000016  6a48              LDR      r0,[r1,#0x24]
000018  2218              MOVS     r2,#0x18
00001a  4010              ANDS     r0,r0,r2
;;;349                if(u32i)                                //Check the PDMA transfer done flags
00001c  d000              BEQ      |L10.32|
;;;350                {
;;;351                    PDMA_CLR_TD_FLAG(PDMA, u32i);       //Clear the PDMA transfer done flags
00001e  6248              STR      r0,[r1,#0x24]
                  |L10.32|
;;;352                }
;;;353                u32i = SUCCESS;
;;;354            }
;;;355            else if(u32i & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))             //Check the DMA time-out interrupt flag
;;;356            {
;;;357                PDMA->INTSTS = u32i & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk);  //Clear the time-out flag
;;;358                u32i = FAIL;
;;;359            }
;;;360            else                                        //Check the DMA transfer abort interrupt flag, (ui32 & PDMA_INTSTS_ABTIF_Msk)
;;;361            {
;;;362                u32i = PDMA_GET_ABORT_STS(PDMA);        //Get the target abort flag
;;;363                PDMA_CLR_ABORT_FLAG(PDMA, u32i);        //Clear the target abort flag
;;;364                u32i = FAIL;
;;;365            }
;;;366        }
;;;367        else
;;;368        {
;;;369            u32i = SUCCESS;
000020  2000              MOVS     r0,#0
;;;370        }
;;;371        return u32i;
;;;372    }
000022  4770              BX       lr
                  |L10.36|
000024  0582              LSLS     r2,r0,#22             ;355
000026  0f92              LSRS     r2,r2,#30             ;355
000028  d004              BEQ      |L10.52|
00002a  2203              MOVS     r2,#3                 ;357
00002c  0212              LSLS     r2,r2,#8              ;357
00002e  4010              ANDS     r0,r0,r2              ;357
000030  61c8              STR      r0,[r1,#0x1c]         ;357
000032  e001              B        |L10.56|
                  |L10.52|
000034  6a08              LDR      r0,[r1,#0x20]         ;362
000036  6208              STR      r0,[r1,#0x20]         ;363
                  |L10.56|
000038  2001              MOVS     r0,#1                 ;364
00003a  4770              BX       lr
;;;373    
                          ENDP

                  |L10.60|
                          DCD      0x40061000
                  |L10.64|
                          DCD      0x40008400
                  |L10.68|
                          DCD      0x00000303

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\porting\\porting_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_porting_spi_c_7d2ac375____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_porting_spi_c_7d2ac375____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_porting_spi_c_7d2ac375____REVSH|
#line 402
|__asm___13_porting_spi_c_7d2ac375____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
